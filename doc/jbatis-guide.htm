<html><head><title>jbatis-guide</title>
<meta charset="UTF-8">
<style type="text/css" charset="UTF-8">
html{font-family:sans-serif;font-size:10pt;font-style:normal;font-weight:normal}
body,h1,h2,h3,h4,h5,h6,p,table,td,caption,th,ul,ol,dl,li,dd,dt{font-size:1em}
pre,code{font-family:Consolas,monospace}
body{overflow:auto;margin-top:0;margin-bottom:.5em;margin-left:.3em;margin-right:0}
h1{margin-top:.3em;margin-bottom:.04em}
h2{margin-top:2em;margin-bottom:.25em}
h3{margin-top:1.7em;margin-bottom:.25em}
h4{margin-top:2em;margin-bottom:.3em}
h5{margin-top:0;margin-bottom:0}
p{margin-top:1em;margin-bottom:1em}
pre{margin-left:.6em;border:1px solid;min-width:60%;max-width:90%;padding:.5em;display:inline-block;background-color:white}
ul{margin-top:0;margin-bottom:1em;margin-left:1em;padding-left:1em}
li{margin-top:0;margin-bottom:0}
li p{margin-top:0;margin-bottom:0}
ol{margin-top:0;margin-bottom:1em;margin-left:1em;padding-left:1em}
dl{margin-top:0;margin-bottom:1em}
dt{margin-top:0;margin-bottom:0;font-weight:bold}
dd{margin-top:0;margin-bottom:0}
a:link{color:#00f}
a:hover{color:#000080}
a:visited{text-decoration:underline}
a.header:link{text-decoration:none;color:#000000}
a.header:visited{text-decoration:none;color:#000000}
a.header:hover{text-decoration:underline;color:#000080}
h4{font-style:italic}
strong{font-weight:bold}
em{font-style:italic}
var{font-style:italic}
th{font-weight:bold}
table{margin-left:.5em;min-width:40%;max-width:90%;background-color:#fffff5}
table,th,td{border-collapse:collapse;padding:6px}
ul.blockList li.blockList,ul.blockListLast li.blockList{list-style:none}
ul.blockList ul.blockList ul.blockList ul.blockList li.blockListLast{list-style:none}
a.headerlink{margin-left:.5em;visibility:hidden}
h1:hover>a.headerlink,h2:hover>a.headerlink,h3:hover>a.headerlink,h4:hover>a.headerlink,h5:hover>a.headerlink{visibility:visible}
.hljs{display:block;overflow-x:auto;background:white;color:black}
.hljs-comment,.hljs-quote,.hljs-variable{color:#008000}
.hljs-keyword,.hljs-selector-tag,.hljs-built_in,.hljs-name,.hljs-tag{color:#00f}
.hljs-string,.hljs-title,.hljs-section,.hljs-attribute,.hljs-literal,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-addition{color:#a31515}
.hljs-deletion,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-meta{color:#2b91af}
.hljs-doctag{color:#808080}
.hljs-attr{color:#f00}
.hljs-symbol,.hljs-bullet,.hljs-link{color:#00b0e8}
.hljs-emphasis{font-style:italic}
.hljs-strong{font-weight:bold}
</style>
</head><body text="#000000" bgcolor="#ffffe1"><table border="1">
  <thead></thead>
  <tbody>
    <tr><td align="right">Version</td><td align="left">2.4.8</td></tr>
    <tr><td align="right">Date</td><td align="left">2018-10-30</td></tr>
  </tbody>
  <caption><strong>jBATIS Persistence Framework Guide</strong></caption>
</table>
<div>
  <h1>Table of Content</h1>
  <ul>
    <li><a id="_toc_introduction" href="#introduction">Introduction</a>
      <ul>
        <li><a id="_toc_concept" href="#concept">Concept</a></li>
        <li><a id="_toc_how-does-it-work" href="#how-does-it-work">How does it work?</a></li>
      </ul>
    </li>
    <li><a id="_toc_installation" href="#installation">Installation</a>
      <ul>
        <li><a id="_toc_jar-files-and-dependencies" href="#jar-files-and-dependencies">JAR Files and Dependencies</a></li>
      </ul>
    </li>
    <li><a id="_toc_the-sql-map-xml-configuration-file" href="#the-sql-map-xml-configuration-file">The SQL Map XML Configuration File</a>
      <ul>
        <li><a id="_toc_ibatisini" href="#ibatisini"><code>ibatis.ini</code></a></li>
        <li><a id="_toc_the-properties-element" href="#the-properties-element">The <code>&lt;properties&gt;</code> Element</a></li>
        <li><a id="_toc_the-settings-element" href="#the-settings-element">The <code>&lt;settings&gt;</code> Element</a></li>
        <li><a id="_toc_the-resultobjectfactory-element" href="#the-resultobjectfactory-element">The <code>&lt;resultObjectFactory&gt;</code> Element</a></li>
        <li><a id="_toc_the-typealias-element" href="#the-typealias-element">The <code>&lt;typeAlias&gt;</code> Element</a></li>
        <li><a id="_toc_the-transactionmanager-element" href="#the-transactionmanager-element">The <code>&lt;transactionManager&gt;</code> Element</a></li>
        <li><a id="_toc_the-datasource-element" href="#the-datasource-element">The <code>&lt;dataSource&gt;</code> Element</a>
          <ul>
            <li><a id="_toc_simpledatasourcefactory" href="#simpledatasourcefactory">SimpleDataSourceFactory</a></li>
            <li><a id="_toc_dbcpdatasourcefactory" href="#dbcpdatasourcefactory">DbcpDataSourceFactory</a></li>
            <li><a id="_toc_jndidatasourcefactory" href="#jndidatasourcefactory">JndiDataSourceFactory</a></li>
          </ul>
        </li>
        <li><a id="_toc_the-sqlmap-element" href="#the-sqlmap-element">The <code>&lt;sqlMap&gt;</code> Element</a></li>
        <li><a id="_toc_the-global-properties" href="#the-global-properties">The Global Properties</a></li>
      </ul>
    </li>
    <li><a id="_toc_the-sql-map-xml-file" href="#the-sql-map-xml-file">The SQL Map XML File</a>
      <ul>
        <li><a id="_toc_doctypes-in-jbatis" href="#doctypes-in-jbatis">Doctypes in jBATIS</a></li>
      </ul>
    </li>
    <li><a id="_toc_mapped-statements" href="#mapped-statements">Mapped Statements</a>
      <ul>
        <li><a id="_toc_statement-types" href="#statement-types">Statement Types</a></li>
        <li><a id="_toc_the-sql" href="#the-sql">The SQL</a></li>
        <li><a id="_toc_reusing-sql-fragments" href="#reusing-sql-fragments">Reusing SQL Fragments</a></li>
        <li><a id="_toc_auto-generated-keys" href="#auto-generated-keys">Auto-Generated Keys</a></li>
        <li><a id="_toc_stored-procedures" href="#stored-procedures">Stored Procedures</a></li>
        <li><a id="_toc_statement-attributes" href="#statement-attributes">Statement Attributes</a>
          <ul>
            <li><a id="_toc_parameterclass" href="#parameterclass">parameterClass</a></li>
            <li><a id="_toc_parametermap" href="#parametermap">parameterMap</a>
              <ul>
                <li><a id="_toc_a-quick-glance-at-inline-parameters" href="#a-quick-glance-at-inline-parameters">A Quick Glance at Inline Parameters</a></li>
              </ul>
            </li>
            <li><a id="_toc_resultclass" href="#resultclass">resultClass</a></li>
            <li><a id="_toc_resultmap" href="#resultmap">resultMap</a></li>
            <li><a id="_toc_cachemodel" href="#cachemodel">cacheModel</a></li>
            <li><a id="_toc_remapresults" href="#remapresults">remapResults</a></li>
            <li><a id="_toc_resultsettype" href="#resultsettype">resultSetType</a></li>
            <li><a id="_toc_fetchsize" href="#fetchsize">fetchSize</a></li>
            <li><a id="_toc_timeout" href="#timeout">timeout</a></li>
            <li><a id="_toc_nobatch" href="#nobatch">noBatch</a></li>
            <li><a id="_toc_canbatch" href="#canbatch">canBatch</a></li>
          </ul>
        </li>
        <li><a id="_toc_duplicate-statements" href="#duplicate-statements">Duplicate Statements</a></li>
      </ul>
    </li>
    <li><a id="_toc_parameter-maps-and-inline-parameters" href="#parameter-maps-and-inline-parameters">Parameter Maps and Inline Parameters</a>
      <ul>
        <li><a id="_toc_parameter-elements" href="#parameter-elements"><code>&lt;parameter&gt;</code> Elements</a>
          <ul>
            <li><a id="_toc_property" href="#property">property</a></li>
            <li><a id="_toc_jdbctype" href="#jdbctype">jdbcType</a></li>
            <li><a id="_toc_javatype" href="#javatype">javaType</a></li>
            <li><a id="_toc_typename" href="#typename">typeName</a></li>
            <li><a id="_toc_nullvalue" href="#nullvalue">nullValue</a></li>
            <li><a id="_toc_resultmap-1" href="#resultmap-1">resultMap</a></li>
            <li><a id="_toc_mode" href="#mode">mode</a></li>
            <li><a id="_toc_typehandler" href="#typehandler">typeHandler</a></li>
            <li><a id="_toc_numericscale" href="#numericscale">numericScale</a></li>
          </ul>
        </li>
        <li><a id="_toc_a-parametermap-example" href="#a-parametermap-example">A <code>&lt;parameterMap&gt;</code> Example</a></li>
        <li><a id="_toc_inline-parameter-maps" href="#inline-parameter-maps">Inline Parameter Maps</a>
          <ul>
            <li><a id="_toc_inline-parameter-map-syntax" href="#inline-parameter-map-syntax">Inline Parameter Map Syntax</a></li>
            <li><a id="_toc_param" href="#param"><code>#%param%#</code></a></li>
          </ul>
        </li>
        <li><a id="_toc_primitive-type-parameters" href="#primitive-type-parameters">Primitive Type Parameters</a></li>
        <li><a id="_toc_map-type-parameters" href="#map-type-parameters">Map Type Parameters</a></li>
      </ul>
    </li>
    <li><a id="_toc_result-maps" href="#result-maps">Result Maps</a>
      <ul>
        <li><a id="_toc_attributes-in-result-element" href="#attributes-in-result-element">Attributes in <code>&lt;result&gt;</code> element</a>
          <ul>
            <li><a id="_toc_property-1" href="#property-1">property</a></li>
            <li><a id="_toc_column" href="#column">column</a></li>
            <li><a id="_toc_columnindex" href="#columnindex">columnIndex</a></li>
            <li><a id="_toc_jdbctype-1" href="#jdbctype-1">jdbcType</a></li>
            <li><a id="_toc_javatype-1" href="#javatype-1">javaType</a></li>
            <li><a id="_toc_nullvalue-1" href="#nullvalue-1">nullValue</a></li>
            <li><a id="_toc_select" href="#select">select</a></li>
            <li><a id="_toc_resultmap-2" href="#resultmap-2">resultMap</a></li>
            <li><a id="_toc_typehandler-1" href="#typehandler-1">typeHandler</a></li>
          </ul>
        </li>
        <li><a id="_toc_implicit-result-maps" href="#implicit-result-maps">Implicit Result Maps</a></li>
        <li><a id="_toc_primitive-results" href="#primitive-results">Primitive Results</a></li>
        <li><a id="_toc_map-results" href="#map-results">Map Results</a></li>
        <li><a id="_toc_complex-properties" href="#complex-properties">Complex Properties</a></li>
        <li><a id="_toc_avoiding-n1-selects-11" href="#avoiding-n1-selects-11">Avoiding N+1 Selects (1:1)</a></li>
        <li><a id="_toc_lazy-loading-vs-joins-11" href="#lazy-loading-vs-joins-11">Lazy Loading vs. Joins (1:1)</a></li>
        <li><a id="_toc_complex-collection-properties" href="#complex-collection-properties">Complex Collection Properties</a></li>
        <li><a id="_toc_avoiding-n1-selects-1m-and-mn" href="#avoiding-n1-selects-1m-and-mn">Avoiding N+1 Selects (1:M and M:N)</a>
          <ul>
            <li><a id="_toc_1n--mn-solution" href="#1n--mn-solution">1:N &amp; M:N Solution</a></li>
            <li><a id="_toc_lazy-loading-vs-joins-1m-and-mn" href="#lazy-loading-vs-joins-1m-and-mn">Lazy Loading vs. Joins (1:M and M:N)</a></li>
          </ul>
        </li>
        <li><a id="_toc_composite-keys-or-multiple-complex-parameters-properties" href="#composite-keys-or-multiple-complex-parameters-properties">Composite Keys or Multiple Complex Parameters Properties</a></li>
      </ul>
    </li>
    <li><a id="_toc_supported-types-for-parameter-maps-and-resultmaps" href="#supported-types-for-parameter-maps-and-resultmaps">Supported Types for Parameter Maps and ResultMaps</a>
      <ul>
        <li><a id="_toc_creating-custom-type-handlers" href="#creating-custom-type-handlers">Creating custom Type Handlers</a></li>
      </ul>
    </li>
    <li><a id="_toc_jbatis-caching" href="#jbatis-caching">jBATIS Caching</a>
      <ul>
        <li><a id="_toc_jbatis-caching-architecture" href="#jbatis-caching-architecture">jBATIS Caching Architecture</a></li>
        <li><a id="_toc_read-only-vs-readwrite" href="#read-only-vs-readwrite"><del>Read-Only vs. Read/Write</del></a></li>
        <li><a id="_toc_serializable-readwrite-caches" href="#serializable-readwrite-caches"><del>Serializable Read/Write Caches</del></a></li>
        <li><a id="_toc_cache-types" href="#cache-types">Cache Types</a>
          <ul>
            <li><a id="_toc_memory" href="#memory"><code>MEMORY</code></a></li>
            <li><a id="_toc_lru" href="#lru"><code>LRU</code></a></li>
            <li><a id="_toc_fifo" href="#fifo"><code>FIFO</code></a></li>
            <li><a id="_toc_oscache" href="#oscache"><code>OSCACHE</code></a></li>
            <li><a id="_toc_ehcache" href="#ehcache"><code>EHCACHE</code></a></li>
          </ul>
        </li>
        <li><a id="_toc_cache-flush" href="#cache-flush">Cache Flush</a>
          <ul>
            <li><a id="_toc_monitor-cache-flush" href="#monitor-cache-flush">Monitor Cache Flush</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a id="_toc_dynamic-mapped-statements" href="#dynamic-mapped-statements">Dynamic Mapped Statements</a>
      <ul>
        <li><a id="_toc_dynamic-element" href="#dynamic-element">Dynamic Element</a></li>
        <li><a id="_toc_binary-conditional-elements" href="#binary-conditional-elements">Binary Conditional Elements</a></li>
        <li><a id="_toc_unary-conditional-elements" href="#unary-conditional-elements">Unary Conditional Elements</a></li>
        <li><a id="_toc_other-elements" href="#other-elements">Other Elements</a>
          <ul>
            <li><a id="_toc_parameter-present" href="#parameter-present">Parameter Present</a></li>
            <li><a id="_toc_iterate" href="#iterate">Iterate</a></li>
          </ul>
        </li>
        <li><a id="_toc_simple-dynamic-sql-elements" href="#simple-dynamic-sql-elements">Simple Dynamic SQL Elements</a>
          <ul>
            <li><a id="_toc_param-1" href="#param-1"><code>$@param$</code></a></li>
          </ul>
        </li>
        <li><a id="_toc_structure-of-all-statements" href="#structure-of-all-statements">Structure of All Statements</a></li>
      </ul>
    </li>
    <li><a id="_toc_jbatis-with-springframework" href="#jbatis-with-springframework">jBATIS with SpringFramework</a>
      <ul>
        <li><a id="_toc_orgibatisspringsqlmapclientfactorybean" href="#orgibatisspringsqlmapclientfactorybean">org.ibatis.spring.SqlMapClientFactoryBean</a></li>
        <li><a id="_toc_orgibatisspringsqlmapclientfactorybeanx" href="#orgibatisspringsqlmapclientfactorybeanx">org.ibatis.spring.SqlMapClientFactoryBeanX</a></li>
        <li><a id="_toc_integration-with-atomikos" href="#integration-with-atomikos">Integration with Atomikos</a></li>
      </ul>
    </li>
    <li><a id="_toc_programming-with-jbatis" href="#programming-with-jbatis">Programming with jBATIS</a>
      <ul>
        <li><a id="_toc_configuration" href="#configuration">Configuration</a></li>
        <li><a id="_toc_orgibatisclientdialect" href="#orgibatisclientdialect">org.ibatis.client.Dialect</a>
          <ul>
            <li><a id="_toc_query-optimization" href="#query-optimization">Query optimization</a></li>
            <li><a id="_toc_replacement-of-statement" href="#replacement-of-statement">Replacement of statement</a></li>
          </ul>
        </li>
        <li><a id="_toc_orgibatisclientsqlmapclient-and-orgibatisspringsqlmapclienttemplate" href="#orgibatisclientsqlmapclient-and-orgibatisspringsqlmapclienttemplate">org.ibatis.client.SqlMapClient and org.ibatis.spring.SqlMapClientTemplate</a></li>
        <li><a id="_toc_transactions" href="#transactions">Transactions</a></li>
        <li><a id="_toc_automatic-transactions" href="#automatic-transactions">Automatic Transactions</a></li>
        <li><a id="_toc_global-distributed-transactions" href="#global-distributed-transactions">Global (DISTRIBUTED) Transactions</a>
          <ul>
            <li><a id="_toc_externalprogrammatic-global-transactions" href="#externalprogrammatic-global-transactions">External/Programmatic Global Transactions</a></li>
            <li><a id="_toc_managed-global-transactions" href="#managed-global-transactions">Managed Global Transactions</a></li>
          </ul>
        </li>
        <li><a id="_toc_multi-threaded-programming" href="#multi-threaded-programming">Multi Threaded Programming</a></li>
        <li><a id="_toc_batchs" href="#batchs">Batchs</a></li>
      </ul>
    </li>
    <li><a id="_toc_jbatis-persistence-api" href="#jbatis-persistence-api">jBATIS Persistence API</a>
      <ul>
        <li><a id="_toc_jbatis-persistence-entitymanager" href="#jbatis-persistence-entitymanager">jBATIS Persistence EntityManager</a></li>
      </ul>
    </li>
    <li><a id="_toc_simpledatasource" href="#simpledatasource">SimpleDataSource</a></li>
    <li><a id="_toc_dignostic-jbatis-framework" href="#dignostic-jbatis-framework">Dignostic jBATIS Framework</a>
      <ul>
        <li><a id="_toc_setup-runtime-stats" href="#setup-runtime-stats">Setup runtime stats</a></li>
        <li><a id="_toc_get-runtime-stats" href="#get-runtime-stats">Get runtime stats</a></li>
      </ul>
    </li>
  </ul>
</div>
<h2 id="introduction">Introduction<a class="headerlink" href="#_toc_introduction">←</a></h2>
<p><strong>The jBATIS persistence framework is a succeeding framework for iBATIS Sql Map framework which was stopped at version 2.3.4.726.</strong></p>
<p>The iBATIS persistence framework will help you to significantly reduce the amount of Java code that you normally need to access a relational database.
iBATIS simply maps JavaBeans to SQL statements using a very simple XML descriptor.</p>
<p>Simplicity is the key advantage of iBATIS over other frameworks and object relational mapping tools.
To use the iBATIS SQL Map you need only be familiar with JavaBeans, XML and SQL.</p>
<p>There is very little else to learn. There is no complex scheme required to join tables or execute complex queries.
Using SQL Map you have the full power of real SQL at your fingertips.</p>
<h3 id="concept">Concept<a class="headerlink" href="#_toc_concept">←</a></h3>
<p>The iBATIS SQL Map API allows programmers to easily map JavaBeans objects to PreparedStatement parameters and ResultSets.
The philosophy behind SQL Map is simple:  provide a simple framework to provide 80% of JDBC functionality using only 20% of the code.</p>
<h3 id="how-does-it-work">How does it work?<a class="headerlink" href="#_toc_how-does-it-work">←</a></h3>
<p>SQL Map provides a very simple framework for using XML descriptors to map JavaBeans, Map implementations, primitive wrapper types (String, Integer...) to an SQL statement.</p>
<p>The following is a high level description of the lifecycle:</p>
<ol>
  <li>Provide an object as a parameter (either a JavaBean, Map or primitive wrapper).
  The parameter object will be used to set input values in an update statement, or where clause values in a query, ...</li>
  <li>Execute the mapped statement. This step is where the magic happens.
  The SQL Map framework will create a PreparedStatement instance, set any parameters using the provided parameter object,
  execute the statement and build a result object from the ResultSet.</li>
  <li>In the case of an update, the number of rows effected is returned.
  In the case of a query, a single object, or a collection of objects is returned.
  Like parameters, result objects can be a JavaBean, a Map, a primitive type wrapper.</li>
</ol>
<p>The diagram below illustrates the flow as described.</p>
<p><img alt="Image" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4wLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLVNWRy0yMDAxMDkwNC9EVEQvc3ZnMTAuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iOTM0IiBoZWlnaHQ9IjQwNiIgdGV4dC1yZW5kZXJpbmc9ImF1dG8iIHNoYXBlLXJlbmRlcmluZz0iYXV0byI+CjxkZWZzPjxjbGlwUGF0aCBpZD0iX2U4a3d3NF8wIj48cGF0aCBkPSJNMCwwIEwxNDQsMCBMMTQ0LDg0IEwwLDg0IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF8xIj48cGF0aCBkPSJNMCwwIEwxNDQsMCBMMTQ0LDcyIEwwLDcyIEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF8yIj48cGF0aCBkPSJNMCwwIEwyNzYsMCBMMjc2LDQ4IEwwLDQ4IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF8zIj48cGF0aCBkPSJNMCwwIEwzOTYsMCBMMzk2LDEyMCBMMCwxMjAgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfZThrd3c0XzQiPjxwYXRoIGQ9Ik0wLDAgTDAsMjAgTDM5MCwyMCBMMzkwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF81Ij48cGF0aCBkPSJNMCwwIEwxMDgsMCBMMTA4LDg0IEwwLDg0IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF82Ij48cGF0aCBkPSJNMCwwIEwwLDM3IEwxMDIsMzcgTDEwMiwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il9lOGt3dzRfNyI+PHBhdGggZD0iTTAsMCBMMTMyLDAgTDEzMiw4NCBMMCw4NCBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il9lOGt3dzRfOCI+PHBhdGggZD0iTTAsMCBMMCwzNyBMMTI2LDM3IEwxMjYsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfZThrd3c0XzkiPjxwYXRoIGQ9Ik0wLDAgTDE0NCwwIEwxNDQsNDggTDAsNDggTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfZThrd3c0XzEwIj48cGF0aCBkPSJNMCwwIEwxNjksMCBMMTY5LDI1IEwwLDI1IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF8xMSI+PHBhdGggZD0iTTAsMCBMMTY5LDAgTDE2OSw4NSBMMCw4NSBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il9lOGt3dzRfMTIiPjxwYXRoIGQ9Ik0wLDAgTDg1LDAgTDg1LDI1IEwwLDI1IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF8xMyI+PHBhdGggZD0iTTAsMCBMMjUsMCBMMjUsODUgTDAsODUgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfZThrd3c0XzE0Ij48cGF0aCBkPSJNMCwwIEwxNjksMCBMMTY5LDczIEwwLDczIEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iX2U4a3d3NF8xNSI+PHBhdGggZD0iTTAsMCBMMTIxLDAgTDEyMSw3MyBMMCw3MyBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il9lOGt3dzRfMTYiPjxwYXRoIGQ9Ik0wLDAgTDEyMSwwIEwxMjEsMjUgTDAsMjUgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfZThrd3c0XzE3Ij48cGF0aCBkPSJNMCwwIEwxMjEsMCBMMTIxLDg1IEwwLDg1IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjwvZGVmcz4KPGcgc3R5bGU9ImZvbnQtZmFtaWx5Ok1pY3Jvc29mdCBZYUhlaTtmb250LXNpemU6MTRweDtzdHJva2UtbGluZWNhcDpzcXVhcmU7c3Ryb2tlLW9wYWNpdHk6MTtmaWxsLW9wYWNpdHk6MTsiPgo8ZWxsaXBzZSBjeD0iNzEiIGN5PSI0MSIgcng9IjcxIiByeT0iNDEiIHN0eWxlPSJmaWxsOiM4MGMwZmY7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzg1LDc3KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMCkiLz4KPGVsbGlwc2UgY3g9IjcxIiBjeT0iNDEiIHJ4PSI3MSIgcnk9IjQxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3ODUsNzcpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8wKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDc4NSw3NykiPjx0ZXh0IHg9IjM5IiB5PSI0NyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzApIj5KYXZhIEJlYW48L3RleHQ+PC9nPgo8ZWxsaXBzZSBjeD0iNzEiIGN5PSIzNSIgcng9IjcxIiByeT0iMzUiIHN0eWxlPSJmaWxsOiM4MGMwZmY7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzg1LDE5NykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIi8+CjxlbGxpcHNlIGN4PSI3MSIgY3k9IjM1IiByeD0iNzEiIHJ5PSIzNSIgc3R5bGU9InN0cm9rZTojOTkwMDMzO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzg1LDE5NykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzg1LDE5NykiPjx0ZXh0IHg9IjU3IiB5PSIyMyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIj5NYXA8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDc4NSwxOTcpIj48dGV4dCB4PSIzNiIgeT0iNDAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xKSI+KEhhc2hNYXAsPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3ODUsMTk3KSI+PHRleHQgeD0iMzMiIHk9IjU3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMSkiPiBUcmVlTWFwLi4uKTwvdGV4dD48L2c+CjxlbGxpcHNlIGN4PSI3MSIgY3k9IjM1IiByeD0iNzEiIHJ5PSIzNSIgc3R5bGU9ImZpbGw6IzgwZmY4MDtmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDE5NykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIi8+CjxlbGxpcHNlIGN4PSI3MSIgY3k9IjM1IiByeD0iNzEiIHJ5PSIzNSIgc3R5bGU9InN0cm9rZTojOTkwMDMzO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwxOTcpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMTk3KSI+PHRleHQgeD0iNTciIHk9IjIzIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMSkiPk1hcDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwxOTcpIj48dGV4dCB4PSIzNiIgeT0iNDAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xKSI+KEhhc2hNYXAsPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDE5NykiPjx0ZXh0IHg9IjMzIiB5PSI1NyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIj4gVHJlZU1hcC4uLik8L3RleHQ+PC9nPgo8ZWxsaXBzZSBjeD0iNzEiIGN5PSIzNSIgcng9IjcxIiByeT0iMzUiIHN0eWxlPSJmaWxsOiM4MGZmODA7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw4OSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIi8+CjxlbGxpcHNlIGN4PSI3MSIgY3k9IjM1IiByeD0iNzEiIHJ5PSIzNSIgc3R5bGU9InN0cm9rZTojOTkwMDMzO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw4OSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw4OSkiPjx0ZXh0IHg9IjM5IiB5PSI0MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIj5KYXZhIEJlYW48L3RleHQ+PC9nPgo8ZWxsaXBzZSBjeD0iNzEiIGN5PSIzNSIgcng9IjcxIiByeT0iMzUiIHN0eWxlPSJmaWxsOiM4MGZmODA7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwzMTcpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xKSIvPgo8ZWxsaXBzZSBjeD0iNzEiIGN5PSIzNSIgcng9IjcxIiByeT0iMzUiIHN0eWxlPSJzdHJva2U6Izk5MDAzMztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMzE3KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMSkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDMxNykiPjx0ZXh0IHg9IjM3IiB5PSIyMyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIj4mcXVvdDtQcmltaXRpdmUmcXVvdDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMzE3KSI+PHRleHQgeD0iNDQiIHk9IjQwIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMSkiPihJbnRlZ2VyLDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwzMTcpIj48dGV4dCB4PSI0MyIgeT0iNTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xKSI+IFN0cmluZy4uLik8L3RleHQ+PC9nPgo8ZWxsaXBzZSBjeD0iNzEiIGN5PSIzNSIgcng9IjcxIiByeT0iMzUiIHN0eWxlPSJmaWxsOiM4MGMwZmY7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzg1LDMxNykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIi8+CjxlbGxpcHNlIGN4PSI3MSIgY3k9IjM1IiByeD0iNzEiIHJ5PSIzNSIgc3R5bGU9InN0cm9rZTojOTkwMDMzO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzg1LDMxNykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzg1LDMxNykiPjx0ZXh0IHg9IjM3IiB5PSIyMyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEpIj4mcXVvdDtQcmltaXRpdmUmcXVvdDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDc4NSwzMTcpIj48dGV4dCB4PSI0NCIgeT0iNDAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xKSI+KEludGVnZXIsPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3ODUsMzE3KSI+PHRleHQgeD0iNDMiIHk9IjU3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMSkiPiBTdHJpbmcuLi4pPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjI3NSIgaGVpZ2h0PSI0NyIgc3R5bGU9ImZpbGw6I2YwZTY4YztmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNDEsMzUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMikiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMjc0IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNDEsMzUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMikiLz4KPGxpbmUgeDE9IjI3NSIgeTE9IjAiIHgyPSIyNzUiIHkyPSI0NiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNDEsMzUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMikiLz4KPGxpbmUgeDE9IjI3NSIgeTE9IjQ3IiB4Mj0iMSIgeTI9IjQ3IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwzNTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8yKSIvPgo8bGluZSB4MT0iMCIgeTE9IjQ3IiB4Mj0iMCIgeTI9IjEiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzQxLDM1MykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzIpIi8+CjxsaW5lIHgxPSI3IiB5MT0iMCIgeDI9IjciIHkyPSI0NyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNDEsMzUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMikiLz4KPGxpbmUgeDE9IjI2OSIgeTE9IjAiIHgyPSIyNjkiIHkyPSI0NyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNDEsMzUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMikiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNDEsMzUzKSI+PHRleHQgeD0iMTIxIiB5PSIyOSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzIpIj5KREJDPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjM5NSIgaGVpZ2h0PSIxMTkiIHN0eWxlPSJmaWxsOiNmZmFmYWY7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjkzLDE3MykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzMpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjM5NCIgeTI9IjAiIHN0eWxlPSJzdHJva2Utd2lkdGg6MjtzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjkzLDE3MykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzMpIi8+CjxsaW5lIHgxPSIzOTUiIHkxPSIwIiB4Mj0iMzk1IiB5Mj0iMTE4IiBzdHlsZT0ic3Ryb2tlLXdpZHRoOjI7c3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5MywxNzMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8zKSIvPgo8bGluZSB4MT0iMzk1IiB5MT0iMTE5IiB4Mj0iMSIgeTI9IjExOSIgc3R5bGU9InN0cm9rZS13aWR0aDoyO3N0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOTMsMTczKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMykiLz4KPGxpbmUgeDE9IjAiIHkxPSIxMTkiIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZS13aWR0aDoyO3N0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOTMsMTczKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMykiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOTMsMTczKSI+PHRleHQgeD0iMTgxIiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8zKSI+wqs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5MywxNzMpIj48dGV4dCB4PSIxODgiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMykiPnNxbDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjkzLDE3MykiPjx0ZXh0IHg9IjIwNyIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMykiPsK7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOTMsMTczKSI+PHRleHQgeD0iMTcwIiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzMpIj5TcWwgTWFwPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjM4MyIgaGVpZ2h0PSIxOSIgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDIxMCkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjM4MiIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDIxMCkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIzODMiIHkxPSIwIiB4Mj0iMzgzIiB5Mj0iMTgiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDIxMCkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIzODMiIHkxPSIxOSIgeDI9IjEiIHkyPSIxOSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOTksMjEwKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIxOSIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5OSwyMTApIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF80KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5OSwyMTApIj48dGV4dCB4PSIxMzIiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNCkiPk1hcHBlZFNhdGVtZW50PC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjM4MyIgaGVpZ2h0PSIxOSIgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDIzMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjM4MiIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDIzMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIzODMiIHkxPSIwIiB4Mj0iMzgzIiB5Mj0iMTgiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDIzMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIzODMiIHkxPSIxOSIgeDI9IjEiIHkyPSIxOSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOTksMjMzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIxOSIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5OSwyMzMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF80KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5OSwyMzMpIj48dGV4dCB4PSIxMzIiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNCkiPk1hcHBlZFNhdGVtZW50PC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjM4MyIgaGVpZ2h0PSIxOSIgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDI1NikiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjM4MiIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDI1NikiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIzODMiIHkxPSIwIiB4Mj0iMzgzIiB5Mj0iMTgiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjk5LDI1NikiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzQpIi8+CjxsaW5lIHgxPSIzODMiIHkxPSIxOSIgeDI9IjEiIHkyPSIxOSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOTksMjU2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIxOSIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5OSwyNTYpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF80KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5OSwyNTYpIj48dGV4dCB4PSIxMzIiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNCkiPk1hcHBlZFNhdGVtZW50PC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwNyIgaGVpZ2h0PSI4MyIgc3R5bGU9ImZpbGw6I2ZmZDcwMDtmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNTcsMjkpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSIxMDYiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOjI7c3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1NywyOSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIi8+CjxsaW5lIHgxPSIxMDciIHkxPSIwIiB4Mj0iMTA3IiB5Mj0iODIiIHN0eWxlPSJzdHJva2Utd2lkdGg6MjtzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjU3LDI5KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNSkiLz4KPGxpbmUgeDE9IjEwNyIgeTE9IjgzIiB4Mj0iMSIgeTI9IjgzIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOjI7c3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1NywyOSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIi8+CjxsaW5lIHgxPSIwIiB5MT0iODMiIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZS13aWR0aDoyO3N0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNTcsMjkpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1NywyOSkiPjx0ZXh0IHg9IjM1IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSI+wqs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1NywyOSkiPjx0ZXh0IHg9IjQyIiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIj54bWw8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1NywyOSkiPjx0ZXh0IHg9IjY2IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSI+wrs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1NywyOSkiPjx0ZXh0IHg9IjE1IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIj5TcWxNYXAueG1sPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9Ijk1IiBoZWlnaHQ9IjM2IiBzdHlsZT0iZmlsbDojZmVmZGZjO2ZpbGwtb3BhY2l0eTowOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNjMsNjYpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF82KSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSI5NCIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjYzLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiLz4KPGxpbmUgeDE9Ijk1IiB5MT0iMCIgeDI9Ijk1IiB5Mj0iMzUiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjYzLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiLz4KPGxpbmUgeDE9Ijk1IiB5MT0iMzYiIHgyPSIxIiB5Mj0iMzYiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjYzLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiLz4KPGxpbmUgeDE9IjAiIHkxPSIzNiIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI2Myw2NikiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzYpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjYzLDY2KSI+PHRleHQgeD0iMzAiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiPi0tLS0tLTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjYzLDY2KSI+PHRleHQgeD0iMzAiIHk9IjM0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiPi0tLS0tLTwvdGV4dD48L2c+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMzEiIGhlaWdodD0iODMiIHN0eWxlPSJmaWxsOiNmZmQ3MDA7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDI1LDI5KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNykiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTMwIiB5Mj0iMCIgc3R5bGU9InN0cm9rZS13aWR0aDoyO3N0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MjUsMjkpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF83KSIvPgo8bGluZSB4MT0iMTMxIiB5MT0iMCIgeDI9IjEzMSIgeTI9IjgyIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOjI7c3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQyNSwyOSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzcpIi8+CjxsaW5lIHgxPSIxMzEiIHkxPSI4MyIgeDI9IjEiIHkyPSI4MyIgc3R5bGU9InN0cm9rZS13aWR0aDoyO3N0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MjUsMjkpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF83KSIvPgo8bGluZSB4MT0iMCIgeTE9IjgzIiB4Mj0iMCIgeTI9IjEiIHN0eWxlPSJzdHJva2Utd2lkdGg6MjtzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDI1LDI5KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNykiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MjUsMjkpIj48dGV4dCB4PSI0NyIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNykiPsKrPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MjUsMjkpIj48dGV4dCB4PSI1NCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF83KSI+eG1sPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MjUsMjkpIj48dGV4dCB4PSI3OCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNykiPsK7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MjUsMjkpIj48dGV4dCB4PSI1IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzcpIj5TcWxNYXBDb25maWcueG1sPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjExOSIgaGVpZ2h0PSIzNiIgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDMxLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfOCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTE4IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MzEsNjYpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF84KSIvPgo8bGluZSB4MT0iMTE5IiB5MT0iMCIgeDI9IjExOSIgeTI9IjM1IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQzMSw2NikiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzgpIi8+CjxsaW5lIHgxPSIxMTkiIHkxPSIzNiIgeDI9IjEiIHkyPSIzNiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MzEsNjYpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF84KSIvPgo8bGluZSB4MT0iMCIgeTE9IjM2IiB4Mj0iMCIgeTI9IjEiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDMxLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfOCkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MzEsNjYpIj48dGV4dCB4PSI0MiIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF84KSI+LS0tLS0tPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MzEsNjYpIj48dGV4dCB4PSI0MiIgeT0iMzQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF84KSI+LS0tLS0tPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwNyIgaGVpZ2h0PSI4MyIgc3R5bGU9ImZpbGw6I2ZmZDcwMDtmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2MTcsMjkpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSIxMDYiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOjI7c3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDYxNywyOSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIi8+CjxsaW5lIHgxPSIxMDciIHkxPSIwIiB4Mj0iMTA3IiB5Mj0iODIiIHN0eWxlPSJzdHJva2Utd2lkdGg6MjtzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjE3LDI5KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNSkiLz4KPGxpbmUgeDE9IjEwNyIgeTE9IjgzIiB4Mj0iMSIgeTI9IjgzIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOjI7c3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDYxNywyOSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIi8+CjxsaW5lIHgxPSIwIiB5MT0iODMiIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZS13aWR0aDoyO3N0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2MTcsMjkpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDYxNywyOSkiPjx0ZXh0IHg9IjM1IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSI+wqs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDYxNywyOSkiPjx0ZXh0IHg9IjQyIiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIj54bWw8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDYxNywyOSkiPjx0ZXh0IHg9IjY2IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF81KSI+wrs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDYxNywyOSkiPjx0ZXh0IHg9IjE1IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzUpIj5TcWxNYXAueG1sPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9Ijk1IiBoZWlnaHQ9IjM2IiBzdHlsZT0iZmlsbDojZmVmZGZjO2ZpbGwtb3BhY2l0eTowOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2MjMsNjYpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF82KSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSI5NCIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjIzLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiLz4KPGxpbmUgeDE9Ijk1IiB5MT0iMCIgeDI9Ijk1IiB5Mj0iMzUiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjIzLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiLz4KPGxpbmUgeDE9Ijk1IiB5MT0iMzYiIHgyPSIxIiB5Mj0iMzYiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjIzLDY2KSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiLz4KPGxpbmUgeDE9IjAiIHkxPSIzNiIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDYyMyw2NikiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzYpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjIzLDY2KSI+PHRleHQgeD0iMzAiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiPi0tLS0tLTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjIzLDY2KSI+PHRleHQgeD0iMzAiIHk9IjM0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfNikiPi0tLS0tLTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTcsNSkiPjx0ZXh0IHg9IjMiIHk9IjE4IiBzdHlsZT0iZmlsbDojMjI4YjIyO2ZvbnQtc2l6ZToxNXB4OyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfOSkiPlBhcmFtZXRlciBPYmplY3Q8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE3LDUpIj48dGV4dCB4PSIzIiB5PSIzNiIgc3R5bGU9ImZpbGw6IzIyOGIyMjtmb250LXNpemU6MTVweDsiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzkpIj4oaW5wdXQpPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3ODUsNSkiPjx0ZXh0IHg9IjMiIHk9IjE4IiBzdHlsZT0iZmlsbDpibHVlO2ZvbnQtc2l6ZToxNXB4OyIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfOSkiPlJlc3VsdCBPYmplY3Q8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDc4NSw1KSI+PHRleHQgeD0iMyIgeT0iMzYiIHN0eWxlPSJmaWxsOmJsdWU7Zm9udC1zaXplOjE1cHg7IiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF85KSI+KG91dHB1dCk8L3RleHQ+PC9nPgo8bGluZSB4MT0iMTU2IiB5MT0iMTIiIHgyPSI4NCIgeTI9IjEyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMzcsMjIxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTApIi8+CjxsaW5lIHgxPSI4NCIgeTE9IjEyIiB4Mj0iMTIiIHkyPSIxMiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDIyMSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEwKSIvPgo8bGluZSB4MT0iMTU1IiB5MT0iMTIiIHgyPSIxNDMiIHkyPSIxOCIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDIyMSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEwKSIvPgo8bGluZSB4MT0iMTU1IiB5MT0iMTIiIHgyPSIxNDMiIHkyPSI2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMzcsMjIxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTApIi8+CjxnIHN0eWxlPSJmaWxsOndoaXRlOzsgc3Ryb2tlOiBub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywyMjEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMCkiPjxwYXRoIGQ9Ik0xNTUsMTIgTDE0MywxOCBMMTQzLDYgWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywyMjEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMCkiPjxwYXRoIGQ9Ik0xNTUsMTIgTDE0MywxOCBMMTQzLDYgWiIvPjwvZz4KPGxpbmUgeDE9IjE1NiIgeTE9IjEyIiB4Mj0iODQiIHkyPSI0MiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzExKSIvPgo8bGluZSB4MT0iODQiIHkxPSI0MiIgeDI9IjEyIiB5Mj0iNzIiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMSkiLz4KPGxpbmUgeDE9IjE1NSIgeTE9IjEyIiB4Mj0iMTQ2IiB5Mj0iMjIiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMSkiLz4KPGxpbmUgeDE9IjE1NSIgeTE9IjEyIiB4Mj0iMTQyIiB5Mj0iMTIiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMSkiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzExKSI+PHBhdGggZD0iTTE1NSwxMiBMMTQ2LDIyIEwxNDIsMTIgWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMSkiPjxwYXRoIGQ9Ik0xNTUsMTIgTDE0NiwyMiBMMTQyLDEyIFoiLz48L2c+CjxsaW5lIHgxPSI3MiIgeTE9IjEyIiB4Mj0iNDIiIHkyPSIxMiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzUzLDUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTIpIi8+CjxsaW5lIHgxPSI0MiIgeTE9IjEyIiB4Mj0iMTIiIHkyPSIxMiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzUzLDUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTIpIi8+CjxsaW5lIHgxPSI3MiIgeTE9IjEyIiB4Mj0iNjAiIHkyPSIxOCIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzUzLDUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTIpIi8+CjxsaW5lIHgxPSI3MiIgeTE9IjEyIiB4Mj0iNjAiIHkyPSI2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNTMsNTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMikiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzUzLDUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTIpIj48cGF0aCBkPSJNNzIsMTIgTDYwLDE4IEw2MCw2IFoiLz48L2c+CjxnIHN0eWxlPSJzdHJva2U6YmxhY2s7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNTMsNTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMikiPjxwYXRoIGQ9Ik03MiwxMiBMNjAsMTggTDYwLDYgWiIvPjwvZz4KPGxpbmUgeDE9IjEyIiB5MT0iNzIiIHgyPSIxMiIgeTI9IjQyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MDEsMjgxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTMpIi8+CjxsaW5lIHgxPSIxMiIgeTE9IjQyIiB4Mj0iMTIiIHkyPSIxMiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDAxLDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEzKSIvPgo8bGluZSB4MT0iMTIiIHkxPSI3MiIgeDI9IjYiIHkyPSI2MCIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDAxLDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEzKSIvPgo8bGluZSB4MT0iMTIiIHkxPSI3MiIgeDI9IjE4IiB5Mj0iNjAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQwMSwyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMykiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDAxLDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEzKSI+PHBhdGggZD0iTTEyLDcyIEw2LDYwIEwxOCw2MCBaIi8+PC9nPgo8ZyBzdHlsZT0ic3Ryb2tlOmJsYWNrO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDAxLDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEzKSI+PHBhdGggZD0iTTEyLDcyIEw2LDYwIEwxOCw2MCBaIi8+PC9nPgo8bGluZSB4MT0iMTIiIHkxPSIxMiIgeDI9IjEyIiB5Mj0iNDIiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMykiLz4KPGxpbmUgeDE9IjEyIiB5MT0iNDIiIHgyPSIxMiIgeTI9IjcyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMjgxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTMpIi8+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iMTgiIHkyPSIyNCIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEzKSIvPgo8bGluZSB4MT0iMTIiIHkxPSIxMiIgeDI9IjYiIHkyPSIyNCIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzEzKSIvPgo8ZyBzdHlsZT0iZmlsbDp3aGl0ZTs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMjgxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTMpIj48cGF0aCBkPSJNMTIsMTIgTDE4LDI0IEw2LDI0IFoiLz48L2c+CjxnIHN0eWxlPSJzdHJva2U6YmxhY2s7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMjgxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTMpIj48cGF0aCBkPSJNMTIsMTIgTDE4LDI0IEw2LDI0IFoiLz48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iNDIiIHkyPSIxMiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTQ1LDUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTIpIi8+CjxsaW5lIHgxPSI0MiIgeTE9IjEyIiB4Mj0iNzIiIHkyPSIxMiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTQ1LDUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTIpIi8+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iMjQiIHkyPSI2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1NDUsNTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMikiLz4KPGxpbmUgeDE9IjEyIiB5MT0iMTIiIHgyPSIyNCIgeTI9IjE4IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1NDUsNTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMikiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTQ1LDUzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTIpIj48cGF0aCBkPSJNMTIsMTIgTDI0LDYgTDI0LDE4IFoiLz48L2c+CjxnIHN0eWxlPSJzdHJva2U6YmxhY2s7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1NDUsNTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xMikiPjxwYXRoIGQ9Ik0xMiwxMiBMMjQsNiBMMjQsMTggWiIvPjwvZz4KPGxpbmUgeDE9IjE1NiIgeTE9IjYwIiB4Mj0iODQiIHkyPSIzNiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDExMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE0KSIvPgo8bGluZSB4MT0iODQiIHkxPSIzNiIgeDI9IjEyIiB5Mj0iMTIiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywxMTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNCkiLz4KPGxpbmUgeDE9IjE1NSIgeTE9IjYwIiB4Mj0iMTQyIiB5Mj0iNjEiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywxMTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNCkiLz4KPGxpbmUgeDE9IjE1NSIgeTE9IjYwIiB4Mj0iMTQ2IiB5Mj0iNTEiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywxMTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNCkiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDExMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE0KSI+PHBhdGggZD0iTTE1NSw2MCBMMTQyLDYxIEwxNDYsNTEgWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNywxMTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNCkiPjxwYXRoIGQ9Ik0xNTUsNjAgTDE0Miw2MSBMMTQ2LDUxIFoiLz48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjYwIiB4Mj0iNjAiIHkyPSIzNiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDExMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE1KSIvPgo8bGluZSB4MT0iNjAiIHkxPSIzNiIgeDI9IjEwOCIgeTI9IjEyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NzcsMTEzKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTUpIi8+CjxsaW5lIHgxPSIxMyIgeTE9IjYwIiB4Mj0iMjEiIHkyPSI0OSIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDExMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE1KSIvPgo8bGluZSB4MT0iMTMiIHkxPSI2MCIgeDI9IjI3IiB5Mj0iNjAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDY3NywxMTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNSkiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDExMykiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE1KSI+PHBhdGggZD0iTTEzLDYwIEwyMSw0OSBMMjcsNjAgWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDY3NywxMTMpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNSkiPjxwYXRoIGQ9Ik0xMyw2MCBMMjEsNDkgTDI3LDYwIFoiLz48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iNjAiIHkyPSIxMiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDIyMSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE2KSIvPgo8bGluZSB4MT0iNjAiIHkxPSIxMiIgeDI9IjEwOCIgeTI9IjEyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NzcsMjIxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTYpIi8+CjxsaW5lIHgxPSIxMyIgeTE9IjEyIiB4Mj0iMjUiIHkyPSI2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NzcsMjIxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTYpIi8+CjxsaW5lIHgxPSIxMyIgeTE9IjEyIiB4Mj0iMjUiIHkyPSIxOCIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDIyMSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE2KSIvPgo8ZyBzdHlsZT0iZmlsbDp3aGl0ZTs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NzcsMjIxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTYpIj48cGF0aCBkPSJNMTMsMTIgTDI1LDYgTDI1LDE4IFoiLz48L2c+CjxnIHN0eWxlPSJzdHJva2U6YmxhY2s7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NzcsMjIxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTYpIj48cGF0aCBkPSJNMTMsMTIgTDI1LDYgTDI1LDE4IFoiLz48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iNjAiIHkyPSI0MiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE3KSIvPgo8bGluZSB4MT0iNjAiIHkxPSI0MiIgeDI9IjEwOCIgeTI9IjcyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NzcsMjgxKSIgY2xpcC1wYXRoPSJ1cmwoI19lOGt3dzRfMTcpIi8+CjxsaW5lIHgxPSIxMyIgeTE9IjEyIiB4Mj0iMjYiIHkyPSIxMyIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE3KSIvPgo8bGluZSB4MT0iMTMiIHkxPSIxMiIgeDI9IjIwIiB5Mj0iMjMiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDY3NywyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNykiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjc3LDI4MSkiIGNsaXAtcGF0aD0idXJsKCNfZThrd3c0XzE3KSI+PHBhdGggZD0iTTEzLDEyIEwyNiwxMyBMMjAsMjMgWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDY3NywyODEpIiBjbGlwLXBhdGg9InVybCgjX2U4a3d3NF8xNykiPjxwYXRoIGQ9Ik0xMywxMiBMMjYsMTMgTDIwLDIzIFoiLz48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMCwwKSI+PHRleHQgeD0iMiIgeT0iNDA0IiBzdHlsZT0iZmlsbDojYzBjMGMwO2ZvbnQtZmFtaWx5OkltcGFjdDtmb250LXNpemU6MTFweDsiID4oYylqYmF0aXMub3JnPC90ZXh0PjwvZz48L2c+PC9zdmc+Cg=="></p>
<h2 id="installation">Installation<a class="headerlink" href="#_toc_installation">←</a></h2>
<p>Installing the iBATIS SQL Map framework is simply a matter of placing the appropriate JAR files on the classpath.
This can either be the classpath specified at JVM startup time (java -cp argument), or it could be the /WEB-INF/lib directory of a web application.</p>
<p>iBATIS comes with the following JAR files that should be on the classpath:</p>
<table border="1">
  <thead>
    <tr><th>File Name</th><th>Description</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr><td>jbatis-2.4.7.jar</td><td>iBATIS Persistence Framework</td><td>YES</td></tr>
  </tbody>
</table>
<h3 id="jar-files-and-dependencies">JAR Files and Dependencies<a class="headerlink" href="#_toc_jar-files-and-dependencies">←</a></h3>
<p>When a framework has too many dependencies, it makes it difficult to integrate into an application and with other frameworks.
The following is a summary of when you would need to use the optional packages.</p>
<table border="1">
  <thead>
    <tr><th>Description</th><th>When to Use</th><th>Dependency</th></tr>
  </thead>
  <tbody>
    <tr><td>Legacy JDK Support</td><td>If your JDK and app server doesn't already supply these JARs, then you will need these optional packages.</td><td>JDBC 3.0+, JTA 1.1+, Xerces 2.7.0+</td></tr>
    <tr><td>DataSource Implementation</td><td>If you want to use the Jakarta DBCP connection pool.</td><td>DBCP 1.2+</td></tr>
    <tr><td>Distributed Caching</td><td>If you want to use OSCache or Ehcache for centralized or distributed caching support.</td><td>OSCache 2.4+ or Ehcache 2.6+, and JGroups 3.6+</td></tr>
    <tr><td>Springframework</td><td>If you want to use spring framework</td><td>Springframework 3.2+</td></tr>
    <tr><td>Logging Solution</td><td>Please use Jakarta Commons Logging or Logback's JCL over SLF4J</td><td>Jakarta Commons Logging 1.1+ or JCL over SLF4J 1.7+</td></tr>
  </tbody>
</table>
<p>In additional, don't forget you also need your database specified JDBC Drivers.</p>
<h2 id="the-sql-map-xml-configuration-file">The SQL Map XML Configuration File<a class="headerlink" href="#_toc_the-sql-map-xml-configuration-file">←</a></h2>
<p>SQL Map is configured using a central XML configuration file, which provides configuration details for DataSources,
SQL Map and other options like thread management..
The following is an example of the SQL Map configuration file: SqlMapConfig.xml</p>
<pre><code class="language-xsql hljs"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE sqlMapConfig
    PUBLIC "-//ibatis.apache.org//DTD SQL Map Config 2.0//EN" "sql-map-config-2.dtd"&gt;</span>
<span class="hljs-comment">&lt;!-- Always ensure to use the correct XML header as above! --&gt;</span>
<span class="hljs-symbol">&lt;sqlMapConfig&gt;</span><span class="undefined">
    </span><span class="hljs-comment">&lt;!-- The properties (name=value) in the file specified here can be used 
        placeholders in this config file (e.g. "${driver}". The file is relative 
        to the classpath and is completely optional. --&gt;</span>
    <span class="hljs-symbol">&lt;properties
        <span class="hljs-attr">resource</span>=<span class="hljs-string">"examples/sqlmap/maps/SqlMapConfigExample.properties"</span> /&gt;</span><span class="undefined">

    </span><span class="hljs-comment">&lt;!-- These settings control SqlMapClient configuration details, primarily 
        to do with transaction management. They are all optional (more detail later 
        in this document). --&gt;</span>
    <span class="hljs-symbol">&lt;settings <span class="hljs-attr">cacheModelsEnabled</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">enhancementEnabled</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">lazyLoadingEnabled</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">useStatementNamespaces</span>=<span class="hljs-string">"false"</span>
        <span class="hljs-attr">defaultStatementTimeout</span>=<span class="hljs-string">"5"</span> /&gt;</span><span class="undefined">

    </span><span class="hljs-comment">&lt;!-- This element declares a factory class that iBATIS will use for creating 
        result objects. This element is optional (more detail later in this document). --&gt;</span>
    <span class="hljs-symbol">&lt;resultObjectFactory
        <span class="hljs-attr">type</span>=<span class="hljs-string">"com.mydomain.MyResultObjectFactory"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"someProperty"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"someValue"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultObjectFactory&gt;</span><span class="undefined">
    </span><span class="hljs-comment">&lt;!-- Type aliases allow you to use a shorter name for long fully qualified 
        class names. --&gt;</span>
    <span class="hljs-symbol">&lt;typeAlias <span class="hljs-attr">alias</span>=<span class="hljs-string">"order"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"testdomain.Order"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-comment">&lt;!-- Configure a datasource to use with this SQL Map using SimpleDataSource. 
        Notice the use of the properties from the above resource --&gt;</span>
    <span class="hljs-symbol">&lt;transactionManager <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;dataSource <span class="hljs-attr">type</span>=<span class="hljs-string">"SIMPLE"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${driver}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.ConnectionURL"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${url}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${username}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${password}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.DefaultAutoCommit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumActiveConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumIdleConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumCheckoutTime"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"120000"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.TimeToWait"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"500"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingQuery"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"select 1 from ACCOUNT"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingConnectionsOlderThan"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingConnectionsNotUsedFor"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/dataSource&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/transactionManager&gt;</span><span class="undefined">
    </span><span class="hljs-comment">&lt;!-- Identify all SQL Map XML files to be loaded by this SQL map. Notice 
        the paths are relative to the classpath. For now, we only have one... --&gt;</span>
    <span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">resource</span>=<span class="hljs-string">"examples/sqlmap/maps/Person.xml"</span> /&gt;</span><span class="undefined">
</span><span class="hljs-symbol">&lt;/sqlMapConfig&gt;</span><span class="undefined">
</span></code></pre>
<p>The following sections of this document discuss the various sections of the SQL Map configuration file.</p>
<h3 id="ibatisini"><code>ibatis.ini</code><a class="headerlink" href="#_toc_ibatisini">←</a></h3>
<p><code>ibatis.ini</code> in classpath is used by jBATIS Framework and SimpleDataSource as global default properties and loaded automatically.
Normally, <code>ibatis.ini</code> wrote as following:</p>
<pre><code class="language-prop hljs properties">Pool.PingIdleConnectionsAfter=<span class="hljs-string">100000
</span>Pool.EraseIdleConnectionsAfter=<span class="hljs-string">900000
</span>cglib_cache_size=<span class="hljs-string">2048
</span>sql_executor_class=<span class="hljs-string">org.ibatis.client.SqlExecutor
</span>sql_executor_threshold=<span class="hljs-string">2000
</span>sql_executor_page_threshold=<span class="hljs-string">60000
</span>sql_executor_debug_sql=<span class="hljs-string">true
</span>sql_executor_stats_sql=<span class="hljs-string">true
</span>sql_executor_check_sql=<span class="hljs-string">true
</span>run_stats_file=<span class="hljs-string">/path/file
</span></code></pre>
<p>In above, using <code>org.ibatis.client.SqlExecutor</code> to debug and stats runtime info.
if <code>sql_executor_debug_sql</code> is <code>true</code>, each executed sql and its arguments and elapsed time will be log out.
if <code>sql_executor_check_sql</code> is <code>true</code>, sql statements will be checked at startup.
if <code>sql_executor_stats_sql</code> is <code>true</code>, each executed sql and its elapsed time will be counted.</p>
<h3 id="the-properties-element">The <code>&lt;properties&gt;</code> Element<a class="headerlink" href="#_toc_the-properties-element">←</a></h3>
<p>The SQL Map can have a single <code>&lt;properties&gt;</code> element that allows a standard Java properties file to be associated with the SQL Map XML configuration document.
By doing so, each named value in the properties file can become a variable that can be referred to in the SQL Map configuration file and all SQL Map referenced within.</p>
<p>For example, if the properties file contains the following:</p>
<pre><code class="language-prop hljs properties">    driver=<span class="hljs-string">org.hsqldb.jdbcDriver
</span></code></pre>
<p>Then the SQL Map configuration file or each SQL Map referenced by the configuration document can use the placeholder ${driver} as a value that will be replaced by org.hsqldb.jdbcDriver.
For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${driver:com.mysql.jdbc.Driver}"</span>/&gt;</span><span class="undefined">
</span></code></pre>
<p>Note that <code>com.mysql.jdbc.Driver</code> is the default value if not <code>driver</code> property found in jBATIS's global properties.</p>
<p>This comes in handy during building, testing and deployment. It makes it easy to reconfigure your app for multiple environments or use automated tools for configuration (e.g. Ant).
The properties can be loaded from the classpath (use the resource attribute) or from any valid URL (use the url attribute).</p>
<p>For example, to load a fixed path file, use:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;properties <span class="hljs-attr">url</span>=<span class="hljs-string">"file:///c:/config/my.properties"</span> /&gt;</span><span class="undefined">
</span></code></pre>
<p><strong>Specially, properties in <code>ibatis.ini</code> would override the properties in <code>&lt;properties&gt;</code> element.</strong></p>
<h3 id="the-settings-element">The <code>&lt;settings&gt;</code> Element<a class="headerlink" href="#_toc_the-settings-element">←</a></h3>
<p>The <code>&lt;settings&gt;</code> element allows you to configure various options and optimizations for the SqlMapClient instance that will be built using this XML file.
The settings element and all of its attributes are completely optional. The attributes supported and their various behaviors are described in the following table:</p>
<table border="1">
  <thead>
    <tr><th>Property name</th><th>Description</th><th>Example</th><th>Default value</th></tr>
  </thead>
  <tbody>
    <tr><td>cacheModelsEnabled</td><td>This setting globally enables or disables all cache models for an SqlMapClient. This can come in handy for debugging.</td><td>cacheModelsEnabled="true"</td><td>true (enabled)</td></tr>
    <tr><td>lazyLoadingEnabled</td><td>This setting globally enables or disables all lazy loading for an SqlMapClient. This can come in handy for debugging.</td><td>lazyLoadingEnabled="true"</td><td>false (disabled)</td></tr>
    <tr><td>enhancementEnabled</td><td>This setting enables runtime bytecode enhancement to facilitate optimized JavaBean property access as well as enhanced lazy loading.</td><td>enhancementEnabled="true"</td><td>true (enabled)</td></tr>
    <tr><td>classInfoCacheEnabled</td><td>This setting globally enables or disables caching the class info for runtime bytecode generation.</td><td>classInfoCacheEnabled="true"</td><td>true (enabled)</td></tr>
    <tr><td>useStatementNamespaces</td><td>With this setting enabled, you must always refer to mapped statements by their fully qualified name, which is the combination of the sqlMap name and the statement name.</td><td>useStatementNamespaces="false"</td><td>false (disabled)</td></tr>
    <tr><td>defaultStatementTimeout</td><td>This setting is an integer value that will be applied as the JDBC query timeout for all statements. This value can be overridden with the "statement" attribute of any mapped statement.</td><td>defaultStatementTimeout="10000"</td><td>n/a</td></tr>
    <tr><td>statementCachingEnabled</td><td>Enables or disables cache prepared statement in current session scope for better performance.</td><td>statementCachingEnabled="true"</td><td>true (enabled)</td></tr>
    <tr><td>useColumnLabel</td><td>Enables or disables use column label to retrieve data from jdbc resultset</td><td>useColumnLabel="true"</td><td>false (disabled, use column name)</td></tr>
    <tr><td>forceMultipleResultSetSupport</td><td>Forcely support retrieve multiple result set from jdbc statement.</td><td>forceMultipleResultSetSupport="true"</td><td>false (disabled)</td></tr>
    <tr><td>jdbcTypeForNull</td><td>Specify the defualt JDBC type for null parameter.</td><td>jdbcTypeForNull="VARCHAR" for oracle</td><td>n/a</td></tr>
    <tr><td>defaultCacheModelType</td><td>Default cache model type such as LRU or OSCACHE.</td><td>defaultCacheModelType="EHCACHE"</td><td>n/a</td></tr>
    <tr><td>forceCacheModelType</td><td>Forcely default cache model type such as LRU or OSCACHE.</td><td>forceCacheModelType="EHCACHE"</td><td>n/a</td></tr>
    <tr><td>databasePagingQueryEnabled</td><td>Enables or disables modify sql before jdbc exection to use database limit/offset support.</td><td>databasePagingQueryEnabled="true"</td><td>true (enabled)</td></tr>
  </tbody>
</table>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>Because <code>lazyLoadingEnabled=true</code> would broken the n-Tier layer structure, so disabled by default.</li>
    <li><code>enhancementEnabled</code> and <code>classInfoCacheEnabled</code> is enabled by default for better performance.</li>
  </ul>
</blockquote>
<h3 id="the-resultobjectfactory-element">The <code>&lt;resultObjectFactory&gt;</code> Element<a class="headerlink" href="#_toc_the-resultobjectfactory-element">←</a></h3>
<p>The <code>resultObjectFactory</code> element allows you to specify a factory class for creating objects resulting from the execution of SQL statements.</p>
<p>This element is optional - if you don't specify the element, iBATIS will use internal mechanisms to create result objects (<code>class.newInstance()</code>).</p>
<p>iBATIS creates result objects in these cases:</p>
<ol>
  <li>When mapping rows returned from a ResultSet (the most common case)</li>
  <li>When you use a nested select statement on a result element in a resultMap.
  If the nested select statement declares a parameterClass, then iBATIS will create and populate an instance of the class before executing the nested select</li>
  <li>When executing stored procedures - iBATIS will create objects for OUTPUT parameters</li>
  <li>When processing nested result maps.
  If the nested result map is used in conjunction with the <code>groupBy</code> support for avoiding N+1 queries,
  then the object will typically be an implementation of type Collection, List, or Set.
  You can provide custom implementations of these interfaces through the result object factory if you wish. In a 1:1 join with a nested result map,
  then iBATIS will create an instance of the specified domain object through this factory.</li>
</ol>
<p>If you choose to implement a factory, your factory class must implement the interface <code>com.ibatis.sqlmap.engine.mapping.result.ResultObjectFactory</code>,
and your class must have a public default constructor. The ResultObjectFactory interface has two methods - one to create an object,
and one to accept any property values specified in the configuration.
For example, suppose you specify a resultObjectFactory configuration element like this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultObjectFactory <span class="hljs-attr">type</span>=<span class="hljs-string">"com.mydomain.MyResultObjectFactory"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"someProperty"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"someValue"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultObjectFactory&gt;</span><span class="undefined">
</span></code></pre>
<p>Then you should code a result object factory class like this:</p>
<pre><code class="language-java hljs"><span class="hljs-keyword">package</span> com.mydomain;

<span class="hljs-keyword">import</span> com.ibatis.sqlmap.engine.mapping.result.ResultObjectFactory;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResultObjectFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResultObjectFactory</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyResultObjectFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">createInstance</span><span class="hljs-params">(String statementId, Class clazz)</span>
        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>{
        <span class="hljs-comment">// create and return instances of clazz here...</span>

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperty</span><span class="hljs-params">(String name, String value)</span> </span>{
        <span class="hljs-comment">// save property values here...</span>
    }
}
</code></pre>
<p>iBATIS will call the <code>setProperty</code> method once for each property specified in the configuration.
All properties will be set before any call to the <code>createInstance</code> method is processed.</p>
<p>iBATIS will call the <code>createInstance</code> method every time an object needs to be created according to the cases mentioned above.
If you return null from the <code>createInstance</code> method, then iBATIS will attempt to create the object through its normal means (<code>class.newInstance()</code>).
If you return null from a request to create <code>java.util.Collection</code> or <code>java.util.List</code>, then iBATIS will create <code>java.util.ArrayList</code>.
If you return null from a request to create <code>java.util.Set</code>, then iBATIS will create <code>java.util.HashSet</code>.
iBATIS passes the current statement id to let you know the context in which the object create is requested.</p>
<h3 id="the-typealias-element">The <code>&lt;typeAlias&gt;</code> Element<a class="headerlink" href="#_toc_the-typealias-element">←</a></h3>
<p>The <code>typeAlias</code> element simply allows you to specify a shorter name to refer to what is usually a long, fully qualified class name.</p>
<p>For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;typeAlias <span class="hljs-attr">alias</span>=<span class="hljs-string">"shortname"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.long.class.path.Class"</span> /&gt;</span><span class="undefined">
</span></code></pre>
<p>There are some predefined aliases used in the SQL Map Config file. They are:</p>
<table border="1">
  <thead></thead>
  <tbody>
    <tr><td>JDBC</td><td>com.ibatis.sqlmap.engine.transaction.jdbc.JdbcTransactionConfig</td></tr>
    <tr><td>JTA</td><td>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</td></tr>
    <tr><td>EXTERNAL</td><td>com.ibatis.sqlmap.engine.transaction.external.ExternalTransactionConfig</td></tr>
  </tbody>
  <caption>Transaction Manager Aliases</caption>
</table>
<table border="1">
  <thead></thead>
  <tbody>
    <tr><td>SIMPLE</td><td>com.ibatis.sqlmap.engine.datasource.SimpleDataSourceFactory</td></tr>
    <tr><td>DBCP</td><td>com.ibatis.sqlmap.engine.datasource.DbcpDataSourceFactory</td></tr>
    <tr><td>JNDI</td><td>com.ibatis.sqlmap.engine.datasource.JndiDataSourceFactory</td></tr>
  </tbody>
  <caption>Data Source Factory Aliases</caption>
</table>
<h3 id="the-transactionmanager-element">The <code>&lt;transactionManager&gt;</code> Element<a class="headerlink" href="#_toc_the-transactionmanager-element">←</a></h3>
<p>The <code>&lt;transactionManager&gt;</code> element allows you to configure the transaction management services for an SQL Map.
The type attribute indicates which transaction manager to use.
The value can either be a class name or a type alias.
The three transaction managers included with the framework are: JDBC, JTA and EXTERNAL.</p>
<table border="1">
  <thead></thead>
  <tbody>
    <tr><td>JDBC</td><td>This allows JDBC to control the transaction via the usual Connection commit() and rollback() methods.</td></tr>
    <tr><td>JTA</td><td>This transaction manager uses a JTA global transaction . This configuration requires a UserTransaction property set to locate the user transaction from a JNDI resource. See the JNDI datasource example below for an example of this configuration.</td></tr>
    <tr><td>EXTERNAL</td><td>This allows you to manage transactions on your own. You can still configure a data source, but transactions will not be committed or rolled back as part of the framework lifecycle.</td></tr>
  </tbody>
</table>
<p>The <code>&lt;transactionManager&gt;</code> element also allows an optional attribute commitRequired that can be true or false.
Normally iBATIS will not commit transactions unless an insert, update, or delete operation has been performed.</p>
<p><strong>This is true even if you explicitly call the commitTransaction() method.</strong> This behavior creates problems in some cases.
If you want iBATIS to always commit transactions, even if no insert, update, or delete operation has been performed,
then set the value of the commitRequired attribute to true.</p>
<p>Examples of where this attribute is useful include:</p>
<ol>
  <li>If you call a stored procedures that updates data as well as returning rows.
  In that case you would call the procedure with the queryForList() operation - so iBATIS would not normally commit the transaction.
  But then the updates would be rolled back.</li>
  <li>In a WebSphere environment when you are using connection pooling and you use the JNDI <code>&lt;dataSource&gt;</code> and the JDBC or JTA transaction manager.
  WebSphere requires all transactions on pooled connections to be committed or the connection will not be returned to the pool.</li>
</ol>
<p>Note that the commitRequired attribute has no effect when using the EXTERNAL transaction manager.
Some of the transaction managers allow extra configuration properties.</p>
<p>The following table shows extra properties that are available for the various transaction managers:</p>
<table border="1">
  <thead>
    <tr><th>Transaction Manager</th><th>Property</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td>EXTERNAL</td><td>DefaultAutoCommit</td><td>If "true", then setAutoCommit(true) will be called on the underlying connection for each transaction if that is not the value supplied by the underlying datasource. This behavior can be overridden with the "SetAutoCommitAllowed" property.</td></tr>
    <tr><td>EXTERNAL</td><td>SetAutoCommitAllowed</td><td>If "true" or unspecified, then the behavior specified in the "DefaultAutoCommit" property will occur. If "false", then iBATIS will not call setAutoCommit in any case - this is useful in environments like WebSphere where the setAutoCommit method should not be called in any circumstance.</td></tr>
    <tr><td>JTA</td><td>UserTransaction</td><td>This property is required. The value of the user transaction. Note that in many cases this should be set to "java:comp/UserTransaction"</td></tr>
  </tbody>
</table>
<h3 id="the-datasource-element">The <code>&lt;dataSource&gt;</code> Element<a class="headerlink" href="#_toc_the-datasource-element">←</a></h3>
<p>Included as part of the transaction manager configuration is a dataSource element and a set of properties to configure a DataSource for use with your SQL Map.
There are currently three datasource factories provided with the framework, but you can also write your own. The included DataSourceFactory implementations are discussed in further detail below and example configurations are provided for each.</p>
<h4 id="simpledatasourcefactory">SimpleDataSourceFactory<a class="headerlink" href="#_toc_simpledatasourcefactory">←</a></h4>
<p>The SimpleDataSource factory provides a basic implementation of a pooling DataSource that is ideal for providing connections in cases
where there is no container provided DataSource. It is based on the iBATIS SimpleDataSource connection pool implementation.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;transactionManager <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;dataSource <span class="hljs-attr">type</span>=<span class="hljs-string">"SIMPLE"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"org.postgresql.Driver"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.ConnectionURL"</span>
                <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:postgresql://server:5432/dbname"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"user"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"password"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-comment">&lt;!-- OPTIONAL PROPERTIES BELOW --&gt;</span>
            <span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.DefaultAutoCommit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumActiveConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumIdleConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumCheckoutTime"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"120000"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.TimeToWait"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10000"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingQuery"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"select * from dual"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingConnectionsOlderThan"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.PingConnectionsNotUsedFor"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Driver.DriverSpecificProperty"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SomeValue"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/dataSource&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/transactionManager&gt;</span><span class="undefined">
</span></code></pre>
<p>Note that any property prefixed with "Driver." will be added as a property to the underlying JDBC driver.</p>
<h4 id="dbcpdatasourcefactory">DbcpDataSourceFactory<a class="headerlink" href="#_toc_dbcpdatasourcefactory">←</a></h4>
<p>This implementation uses Jakarta DBCP (Database Connection Pool) to provide connection pooling services via the DataSource API.
This DataSource is ideal where the application/web container cannot provide a DataSource implementation, or you're running a standalone application.
iBATIS provides direct access to setting the properties of a DBCP datasource by allowing you to specify any DBCP property name you desire in the configuration.</p>
<p>For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;transactionManager <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;dataSource <span class="hljs-attr">type</span>=<span class="hljs-string">"DBCP"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${driver}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${url}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${username}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${password}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-comment">&lt;!-- OPTIONAL PROPERTIES BELOW --&gt;</span>
            <span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"maxActive"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"maxIdle"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"maxWait"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"60000"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-comment">&lt;!-- Use of the validation query can be problematic. If you have difficulty, 
                try without it. --&gt;</span>
            <span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"validationQuery"</span>
                <span class="hljs-attr">value</span>=<span class="hljs-string">"select * from ACCOUNT"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"logAbandoned"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"removeAbandoned"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"removeAbandonedTimeout"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"50000"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Driver.DriverSpecificProperty"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SomeValue"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/datasource&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/transactionManager&gt;</span><span class="undefined">
</span></code></pre>
<p>You can see all available properties here: <a href="http://commons.apache.org/proper/commons-dbcp/configuration.html">http://commons.apache.org/proper/commons-dbcp/configuration.html</a></p>
<p>Note that any property prefixed with "Driver." will be added as a property to the underlying JDBC driver as shown above.</p>
<p>iBATIS also supports a less flexible legacy configuration option as show below. However, we recommend that you use the configuration option shown above.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;transactionManager <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>&gt;</span><span class="undefined">  </span><span class="hljs-comment">&lt;!-- Legacy DBCP Configuration --&gt;</span>
        <span class="hljs-symbol">&lt;dataSource <span class="hljs-attr">type</span>=<span class="hljs-string">"DBCP"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${driver}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.ConnectionURL"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${url}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${username}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"JDBC.Password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${password}"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-comment">&lt;!-- OPTIONAL PROPERTIES BELOW --&gt;</span>
            <span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumActiveConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumIdleConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.MaximumWait"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"60000"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-comment">&lt;!-- Use of the validation query can be problematic. If you have difficulty, 
                try without it. --&gt;</span>
            <span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Pool.ValidationQuery"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"select * from ACCOUNT"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"Driver.DriverSpecificProperty"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SomeValue"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/datasource&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/transactionManager&gt;</span><span class="undefined">
</span></code></pre>
<p>The properties shown are the only properties recognized by iBATIS when using the legacy configuration option.
Note that any property prefixed with "Driver." will be added as a property to the underlying JDBC driver as shown above.</p>
<h4 id="jndidatasourcefactory">JndiDataSourceFactory<a class="headerlink" href="#_toc_jndidatasourcefactory">←</a></h4>
<p>This implementation will retrieve a DataSource implementation from a JNDI context from within an application container.
This is typically used when an application server is in use and a container managed connection pool and associated DataSource implementation are provided.
The standard way to access a JDBC DataSource implementation is via a JNDI context. JndiDataSourceFactory provides functionality to access such a DataSource via JNDI.
The configuration parameters that must be specified in the datasource stanza are as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;transactionManager <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;dataSource <span class="hljs-attr">type</span>=<span class="hljs-string">"JNDI"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"DataSource"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"java:comp/env/jdbc/jpetstore"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/dataSource&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/transactionManager&gt;</span><span class="undefined">
</span></code></pre>
<p>The above configuration will use normal JDBC transaction management.
But with a container managed resource, you might also want to configure it for global transactions as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;transactionManager <span class="hljs-attr">type</span>=<span class="hljs-string">"JTA"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"UserTransaction"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"java:/comp/UserTransaction"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;dataSource <span class="hljs-attr">type</span>=<span class="hljs-string">"JNDI"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"DataSource"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"java:comp/env/jdbc/jpetstore"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/dataSource&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/transactionManager&gt;</span><span class="undefined">
</span></code></pre>
<p>Notice the <code>UserTransaction</code> property that points to the JNDI location where the UserTransaction instance can be found.
This is required for JTA transaction management so that your SQL Map take part in a wider scoped transaction involving other databases and transactional resources.
JNDI context properties can be added before the lookup by specifying additional properties with a prefix of "context.". For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"context.java.naming.provider.url"</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"ldap://somehost:389"</span>/&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="the-sqlmap-element">The <code>&lt;sqlMap&gt;</code> Element<a class="headerlink" href="#_toc_the-sqlmap-element">←</a></h3>
<p>The sqlMap element is used to explicitly include an SQL Map or another SQL Map Configuration file.
Each SQL Map XML file that is going to be used by this SqlMapClient instance, must be declared.
The SQL Map XML files will be loaded as a stream resource from the classpath or from a URL.
You must specify any and all SQL Map (as many as there are). Here are some examples:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-comment">&lt;!-- CLASSPATH RESOURCES --&gt;</span>
    <span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/ibatis/examples/sql/Customer.xml"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/ibatis/examples/sql/Account.xml"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/ibatis/examples/sql/Product.xml"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-comment">&lt;!-- URL RESOURCES --&gt;</span>
    <span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">url</span>=<span class="hljs-string">"file:///c:/config/Customer.xml"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">url</span>=<span class="hljs-string">"file:///c:/config/Account.xml"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">url</span>=<span class="hljs-string">"file:///c:/config/Product.xml"</span> /&gt;</span><span class="undefined">
</span></code></pre>
<p>The next several sections detail the structure of these SQL Map XML files.</p>
<h3 id="the-global-properties">The Global Properties<a class="headerlink" href="#_toc_the-global-properties">←</a></h3>
<p>jBATIS holds alwarys a global properties for variable calculation at runtime. The global properties is setup in following order:</p>
<ol>
  <li>Populate from <code>System.getProperties()</code>, thus they can be overrided by subsequent sources.</li>
  <li>From <code>&lt;sqlMapConfig&gt;&lt;properties ...&gt;</code> if exists.</li>
  <li>From <code>org.ibatis.client.SqlMapClientBuilder.buildSqlMapClient(..., Properties ...)</code> or <code>org.ibatis.spring.SqlMapClientFactoryBean#sqlMapClientProperties</code> if exists.</li>
  <li>From <code>ibatis.ini</code> in classpath if exists.</li>
</ol>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Some properties may only be read from <code>ibatis.ini</code> because they are used outside of a jBATIS Framework instance or at static class level.</p>
</blockquote>
<table border="1">
  <thead>
    <tr><th>User</th><th>Property Name</th><th>Description</th><th>Default Value</th></tr>
  </thead>
  <tbody>
    <tr><td><code>MEMORY</code> Cache</td><td><code>memory.mcast.enable</code></td><td>Enable memory multicast its flush event</td><td><code>false</code></td></tr>
    <tr><td><code>MEMORY</code> Cache</td><td><code>memory.mcast.properties</code></td><td>Used by JGroups</td><td>n/a</td></tr>
    <tr><td><code>MEMORY</code> Cache</td><td><code>memory.mcast.addr</code></td><td>JGroups multicast address</td><td><code>231.6.7.8</code></td></tr>
    <tr><td><code>MEMORY</code> Cache</td><td><code>memory.mcast.port</code></td><td>JGroups multicast port</td><td><code>44566</code></td></tr>
    <tr><td>SimpleDataSource</td><td>Any property name, override the params of its constructor <code>SimpleDataSource(Map&lt;Object, Object&gt;)</code></td><td>For any use</td><td>n/a</td></tr>
    <tr><td>Bytecode Cache</td><td><code>cglib_cache_size</code></td><td>Max number of cache entries</td><td>2048</td></tr>
  </tbody>
  <caption>Properties always from <code>ibatis.ini</code></caption>
</table>
<p>User can also obtain a global property by API <code>org.ibatis.client.PropertyProvider.getGlobalProperty(String)</code>
via <code>org.ibatis.client.SqlMapClient</code> or <code>org.ibatis.spring.SqlMapClientTemplate</code>.</p>
<p>If want to obtain properties of <code>ibatis.ini</code>, One can use API <code>com.ibatis.common.resources.Resources.getIbatisIniProperties()</code>.</p>
<h2 id="the-sql-map-xml-file">The SQL Map XML File<a class="headerlink" href="#_toc_the-sql-map-xml-file">←</a></h2>
<p>In the examples above, we saw the most simple forms of SQL Map.
There are other options available within the SQL Map document structure.
Here is an example of a mapped statement that makes use of more features.</p>
<pre><code class="language-xsql hljs"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>

<span class="hljs-meta">&lt;!DOCTYPE sqlMap PUBLIC "-//iBATIS.org//DTD SQL Map 2.4//EN" "sql-map-2.4.dtd"&gt;</span>
<span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">namespace</span>=<span class="hljs-string">"Product"</span>&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"productCache"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"LRU"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"size"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;typeAlias <span class="hljs-attr">alias</span>=<span class="hljs-string">"product"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.ibatis.example.Product"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;parameterMap <span class="hljs-attr">id</span>=<span class="hljs-string">"productParam"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/parameterMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"productResult"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">parameterMap</span>=<span class="hljs-string">"productParam"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"productResult"</span> <span class="hljs-attr">cacheModel</span>=<span class="hljs-string">"product-cache"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_ID = ?
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span><span class="hljs-symbol">&lt;/sqlMap&gt;</span><span class="undefined">
</span></code></pre>
<p><strong>TOO MUCH?</strong>  Although the framework is doing a lot for you, that might seem like a lot of extra work (XML) for a simple select statement.
Worry not. Here's a shorthand version of the above.</p>
<pre><code class="language-xsql hljs"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>

<span class="hljs-meta">&lt;!DOCTYPE sqlMap PUBLIC "-//iBATIS.org//DTD SQL Map 2.4//EN" "sql-map-2.4.dtd"&gt;</span>
<span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">namespace</span>=<span class="hljs-string">"Product"</span>&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.ibatis.example.Product"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            PRD_ID          <span class="hljs-keyword">AS</span> id,
            PRD_DESCRIPTION <span class="hljs-keyword">AS</span> description
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_ID = #id#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span><span class="hljs-symbol">&lt;/sqlMap&gt;</span><span class="undefined">
</span></code></pre>
<p>Now, these statements aren't exactly equal in terms of the SQL Map behavior -there are some differences.
First, the latter statement does not define a cache, and therefore every request will hit the database.
Second, the latter statement uses auto-mapping features of the framework, which can create some overhead.
However, both of these statements would be executed exactly the same way from your Java code and therefore
you can start with the simpler solution first and move to the more advanced mapping as needed in the future.</p>
<p>Simplest solution first is best practice in many modern methodologies.
A single SQL Map XML file can contain as many cache models, parameter maps, result maps and statements as you like.
Use discretion and organize the statements and maps appropriately for your application (group them logically).</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>There are 2 DTDs for SQL Map XML file in jBATIS, one is <code>sql-map-2.dtd</code>, it erase dom/xml support in iBATIS, and another is <code>sql-map-2.4.dtd</code>,
  it provide more dynamic tag alias and more cache operations from <code>sql-map-2.dtd</code>.</p>
</blockquote>
<h3 id="doctypes-in-jbatis">Doctypes in jBATIS<a class="headerlink" href="#_toc_doctypes-in-jbatis">←</a></h3>
<table border="1">
  <thead>
    <tr><th align="right">Doctype</th><th>Public ID</th><th>System ID</th><th>Real DTD</th></tr>
  </thead>
  <tbody>
    <tr><td align="right"><code>sqlMapConfig</code></td><td><code>-//iBATIS.com//DTD SQL Map Config 2.0//EN</code></td><td></td><td>sql-map-config-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMapConfig</code></td><td></td><td><code>http://www.ibatis.com/dtd/sql-map-config-2.dtd</code></td><td>sql-map-config-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMapConfig</code></td><td><code>-//ibatis.apache.org//DTD SQL Map Config 2.0//EN</code></td><td></td><td>sql-map-config-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMapConfig</code></td><td></td><td><code>http://ibatis.apache.org/dtd/sql-map-config-2.dtd</code></td><td>sql-map-config-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMap</code></td><td><code>-//iBATIS.com//DTD SQL Map 2.0//EN</code></td><td></td><td>sql-map-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMap</code></td><td></td><td><code>http://www.ibatis.com/dtd/sql-map-2.dtd</code></td><td>sql-map-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMap</code></td><td><code>-//ibatis.apache.org//DTD SQL Map 2.0//EN</code></td><td></td><td>sql-map-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMap</code></td><td></td><td><code>http://ibatis.apache.org/dtd/sql-map-2.dtd</code></td><td>sql-map-2.dtd</td></tr>
    <tr><td align="right"><code>sqlMap</code></td><td><code>-//iBATIS.org//DTD SQL Map 2.4//EN</code></td><td></td><td><strong>sql-map-2.4.dtd</strong></td></tr>
  </tbody>
  <caption>Doctypes in jBATIS</caption>
</table>
<h2 id="mapped-statements">Mapped Statements<a class="headerlink" href="#_toc_mapped-statements">←</a></h2>
<p>The SQL Map concept is centered around mapped statements.
Mapped statements can be any SQL statement and can have parameter maps (input) and result maps (output).
If the case is simple, the mapped statement can be configured directly to a class for parameters and results.
The mapped statement can also be configured to use a cache model to cache popular results in memory.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;statement <span class="hljs-attr">id</span>=<span class="hljs-string">"statementName"</span> 
           [<span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"some.class.Name"</span>]
           [<span class="hljs-attr">resultClass</span>=<span class="hljs-string">"some.class.Name"</span>]
           [<span class="hljs-attr">parameterMap</span>=<span class="hljs-string">"nameOfParameterMap"</span>]
           [<span class="hljs-attr">resultMap</span>=<span class="hljs-string">"nameOfResultMap"</span>]
           [<span class="hljs-attr">cacheModel</span>=<span class="hljs-string">"nameOfCache"</span>]
           [<span class="hljs-attr">timeout</span>=<span class="hljs-string">"5"</span>]&gt;</span><span class="sql">
        <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> PRODUCT <span class="hljs-keyword">where</span> PRD_ID = [?|#propertyName#]
        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> [$simpleDynamic$]
    </span><span class="hljs-symbol">&lt;/statement&gt;</span><span class="undefined">
</span></code></pre>
<p>Where statement can be any of insert, update, delete, select, procedure, or statement.
In the above statement, the <strong>[bracketed]</strong> parts are optional and in some cases only certain combinations are allowed.
So it is perfectly legal to have a Mapped Statement with as simple as this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertTestProduct"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                <span class="hljs-number">1</span>,
                <span class="hljs-string">"Shih Tzu"</span>
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<p>The above example is obviously unlikely, however this can come in handy if you want to simply make use of the SQL Map framework for executing arbitrary SQL statements.
However, it will be more common to make use of the JavaBeans mapping features using Parameter Maps and Result Maps, as that is where the true power is.
The next several sections describe the structure and attributes and how they effect the mapped statement.</p>
<h3 id="statement-types">Statement Types<a class="headerlink" href="#_toc_statement-types">←</a></h3>
<p>The <code>&lt;statement&gt;</code> element is a general "catch all" statement that can be used for any type of SQL statement.
Generally it is a good idea to use one of the more specific statement elements.
The more specific elements provide a more intuitive XML DTD and sometimes provides additional features that a normal <code>&lt;statement&gt;</code> element cannot.
The following table summarizes the statement elements and their supported attributes and features:</p>
<table border="1">
  <thead>
    <tr><th>Statement Element</th><th>Attributes</th><th>Child Elements</th><th>Methods</th></tr>
  </thead>
  <tbody>
    <tr><td><code>&lt;sql&gt;</code></td><td><code>id</code></td><td>All dynamic elements, <code>&lt;include&gt;</code></td><td>n/a</td></tr>
    <tr><td><code>&lt;include&gt;</code></td><td><code>refid</code></td><td>n/a</td><td>n/a</td></tr>
    <tr><td><code>&lt;statement&gt;</code></td><td><code>id parameterClass resultClass parameterMap resultMap cacheModel resultSetType fetchSize remapResults timeout canBatch</code></td><td>All dynamic elements and <code>&lt;include&gt;</code></td><td>insert update delete, All query methods</td></tr>
    <tr><td><code>&lt;insert&gt;</code></td><td><code>id parameterClass parameterMap timeout noBatch</code></td><td>All dynamic elements, <code>&lt;selectKey&gt;</code> and <code>&lt;include&gt;</code></td><td>insert update delete</td></tr>
    <tr><td><code>&lt;selectKey&gt;</code></td><td><code>resultClass keyProperty type</code></td><td>n/a</td><td>n/a</td></tr>
    <tr><td><code>&lt;update&gt;</code></td><td><code>id parameterClass parameterMap timeout noBatch</code></td><td>All dynamic elements and <code>&lt;include&gt;</code></td><td>insert update delete</td></tr>
    <tr><td><code>&lt;delete&gt;</code></td><td><code>id parameterClass parameterMap timeout noBatch</code></td><td>All dynamic elements and <code>&lt;include&gt;</code></td><td>insert update delete</td></tr>
    <tr><td><code>&lt;select&gt;</code></td><td><code>id parameterClass resultClass parameterMap resultMap cacheModel resultSetType fetchSize remapResults timeout</code></td><td>All dynamic elements and <code>&lt;include&gt;</code></td><td>All query methods</td></tr>
    <tr><td><code>&lt;procedure&gt;</code></td><td><code>id parameterClass resultClass parameterMap resultMap cacheModel fetchSize remapResults timeout canBatch</code></td><td>All dynamic elements and <code>&lt;include&gt;</code></td><td>insert update delete, All query methods</td></tr>
  </tbody>
</table>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>You need use <code>sql-map-2.4.dtd</code> for SQL Map XML to use <code>noBatch</code> or <code>canBatch</code> attributes.</p>
</blockquote>
<h3 id="the-sql">The SQL<a class="headerlink" href="#_toc_the-sql">←</a></h3>
<p>The SQL is obviously the most important part of the map. It can be any SQL that is valid for your database and JDBC driver.
You can use any functions available and even send multiple statements as long as your driver supports it.
Because you are combining SQL and XML in a single document, there is potential for conflicting special characters.
The most common obviously is the greater-than and less-than symbols (<code>&lt;&gt;</code>). These are commonly required in SQL and are reserved symbols in XML.</p>
<p>There is a simple solution to deal with <code>&lt;</code> as <code>&amp;lt;</code> and <code>&gt;</code> as <code>&amp;gt;</code>,
Then some advanced IDE such as <strong>jbatis-ide</strong> can format them normally and even convert them automatically.</p>
<p>For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getPersonsByAge"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"examples.domain.Person"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PERSON
        <span class="hljs-keyword">WHERE</span>
            AGE &amp;gt; #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="reusing-sql-fragments">Reusing SQL Fragments<a class="headerlink" href="#_toc_reusing-sql-fragments">←</a></h3>
<p>When writing SqlMaps, you often encounter duplicate fragments of SQL, for example a FROM-clause or constraint-statement.
iBATIS offers a simple yet powerful tag to reuse them.</p>
<p>For the sake of simplicity, let's assume we want to get some items and we want to do a count on them.
Normally, you would write something like this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItemCount"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"int"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> total
        <span class="hljs-keyword">FROM</span>
            items
        <span class="hljs-keyword">WHERE</span>
            parentid = <span class="hljs-number">6</span>
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItems"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"Item"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            id,
            name
        <span class="hljs-keyword">FROM</span>
            items
        <span class="hljs-keyword">WHERE</span>
            parentid = <span class="hljs-number">6</span>
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>To eliminate this duplication, we use the tags <code>&lt;sql&gt;</code> and <code>&lt;include&gt;</code>.
The <code>&lt;sql&gt;</code> tag contains the fragment to reuse, the <code>&lt;include&gt;</code> tag includes such a fragment in a statement.</p>
<p>For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;sql <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItem_fragment"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">FROM</span>
            items
        <span class="hljs-keyword">WHERE</span>
            parentid = <span class="hljs-number">6</span>
    </span><span class="hljs-symbol">&lt;/sql&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItemCount"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"int"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> total
        </span><span class="hljs-symbol">&lt;include <span class="hljs-attr">refid</span>=<span class="hljs-string">"selectItem_fragment"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItems"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"Item"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            id,
            name
        </span><span class="hljs-symbol">&lt;include <span class="hljs-attr">refid</span>=<span class="hljs-string">"selectItem_fragment"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>The <code>&lt;include&gt;</code> tag is namespace aware so you can refer to fragments even when they are located in another map
(however, due to the way iBATIS loads the SqlMaps, the included fragment should be loaded before the including statement).</p>
<p>The fragments are included and processed on query-execution so parameters can be used too:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;sql <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItem_fragment"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">FROM</span>
            items
        <span class="hljs-keyword">WHERE</span>
            parentid = #value#
    </span><span class="hljs-symbol">&lt;/sql&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItemCount"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"int"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> total
        </span><span class="hljs-symbol">&lt;include <span class="hljs-attr">refid</span>=<span class="hljs-string">"selectItem_fragment"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"selectItems"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"Item"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            id,
            name
        </span><span class="hljs-symbol">&lt;include <span class="hljs-attr">refid</span>=<span class="hljs-string">"selectItem_fragment"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="auto-generated-keys">Auto-Generated Keys<a class="headerlink" href="#_toc_auto-generated-keys">←</a></h3>
<p>Many relational database systems support auto-generation of primary key fields. This feature of the RDBMS is often (if not always) proprietary.</p>
<p>SQL Map supports auto-generated keys via the <code>&lt;selectKey&gt;</code> stanza of the <code>&lt;insert&gt;</code> element.
Both pre-generated keys (e.g. Oracle) and post-generated (MS-SQL Server) keys are supported.
Here are a couple of examples:</p>
<pre><code class="language-xsql hljs">
    <span class="hljs-comment">&lt;!-- Oracle SEQUENCE Example --&gt;</span>
    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct-ORACLE"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;selectKey <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"int"</span>&gt;</span><span class="sql">
            <span class="hljs-keyword">SELECT</span> STOCKIDSEQUENCE.NEXTVAL <span class="hljs-keyword">AS</span> ID <span class="hljs-keyword">FROM</span> DUAL
        </span><span class="hljs-symbol">&lt;/selectKey&gt;</span><span class="sql">
            <span class="hljs-keyword">INSERT</span>
            <span class="hljs-keyword">INTO</span>
                PRODUCT
                (
                    PRD_ID,
                    PRD_DESCRIPTION
                )
            <span class="hljs-keyword">VALUES</span>
                (
                    #id#,
                    #description#
                )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
    </span><span class="hljs-comment">&lt;!-- Microsoft SQL Server IDENTITY Column Example --&gt;</span>
    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct-MS-SQL"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                #description#
            )
        </span><span class="hljs-symbol">&lt;selectKey <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"int"</span>&gt;</span><span class="sql"><span class="hljs-keyword">SELECT</span> @@IDENTITY <span class="hljs-keyword">AS</span> ID</span><span class="hljs-symbol">&lt;/selectKey&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
    </span><span class="hljs-comment">&lt;!-- JDBC Example, use java.sql.Statement#getGeneratedKeys() --&gt;</span>
    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                #description#
            )
        </span><span class="hljs-symbol">&lt;selectKey <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"long"</span>/&gt;</span><span class="undefined">
        </span><span class="hljs-comment">&lt;!-- Empty selectKey element means use JDBC's Statement.getGeneratedKeys() API. --&gt;</span>
    <span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<p>The <code>selectKey</code> statement is executed before the insert statement if it is placed before the insert SQL,
otherwise the <code>selectKey</code> statement is executed after the insert statement.</p>
<p>In the previous examples, the Oracle example shows that the selectKey will be executed before the insert statement (as is appropriate for a sequence).
The SQL Server example shows that the selectKey statement will be executed after the insert statement (as is appropriate for an identity column).
With jBATIS, you can explicitly state the order of execution of the statements if you wish.
The <code>selectKey</code> element supports an attribute type that can be used to explicitly set the execution order.</p>
<p>The value of the type attribute can be either "pre" or "post" - meaning that the statement will be executed before or after the insert statement.
If you specify the type attribute, then the value you specify will be used regardless of the position of the selectKey element.
For example, in the following statement the selectKey statement will be executed before the insert statement,
even though the element is placed after the insert statement.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct-ORACLE-type-specified"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                #id#,
                #description#
            )
        </span><span class="hljs-symbol">&lt;selectKey <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"pre"</span>&gt;</span><span class="sql">
            <span class="hljs-keyword">SELECT</span> STOCKIDSEQUENCE.NEXTVAL <span class="hljs-keyword">AS</span> ID <span class="hljs-keyword">FROM</span> DUAL
        </span><span class="hljs-symbol">&lt;/selectKey&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<table border="1">
  <thead>
    <tr><th><code>&lt;selectKey&gt;</code> Attribute</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td>resultClass</td><td>The Java class that should be generated as a result of running the <code>&lt;selectKey&gt;</code> statement (typically an Integer or Long).</td></tr>
    <tr><td>keyProperty</td><td>The property that will be set in the parameter object as a result of running the <code>&lt;selectKey&gt;</code> statement.</td></tr>
    <tr><td>type</td><td>"pre" or "post". If specified, then this denotes that the select key statement will be executed before (pre) or after (post) the related insert statement.</td></tr>
  </tbody>
  <caption><code>&lt;selectKey&gt;</code> attribute reference:</caption>
</table>
<h3 id="stored-procedures">Stored Procedures<a class="headerlink" href="#_toc_stored-procedures">←</a></h3>
<p>Stored procedures are supported via the <code>&lt;procedure&gt;</code> statement element.
The following example shows how a stored procedure would be used with output parameters.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;parameterMap <span class="hljs-attr">id</span>=<span class="hljs-string">"swapParameters"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"map"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"email1"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"INOUT"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"email2"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.lang.String"</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"INOUT"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/parameterMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;procedure <span class="hljs-attr">id</span>=<span class="hljs-string">"swapEmailAddresses"</span> <span class="hljs-attr">parameterMap</span>=<span class="hljs-string">"swapParameters"</span>&gt;</span><span class="undefined">
        {call swap_email_address (?, ?)}
    </span><span class="hljs-symbol">&lt;/procedure&gt;</span><span class="undefined">
</span></code></pre>
<p>Calling the above procedure would swap two email addresses between two columns (database table) and also in the parameter object (Map).
The parameter object is only modified if the parameter mappings mode attribute is set to "INOUT" or "OUT".
Otherwise they are left unchanged. Obviously immutable parameter objects (e.g. String) cannot be modified.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Always be sure to use the standard JDBC stored procedure syntax. See the JDBC CallableStatement documentation for more information.</p>
</blockquote>
<h3 id="statement-attributes">Statement Attributes<a class="headerlink" href="#_toc_statement-attributes">←</a></h3>
<h4 id="parameterclass">parameterClass<a class="headerlink" href="#_toc_parameterclass">←</a></h4>
<p>The value of the parameterClass attribute is the fully qualified name of a Java class (i.e. including package).
The parameterClass attribute is optional, but highly recommended.
It is used to limit parameters passed to the statement, as well as to optimize the performance of the framework.
If you're using a parameterMap, there is no need to use the parameterClass attribute.
For example, if you only wanted to allow objects of type (i.e. instanceof) "examples.domain.Product" to be passed in as a parameter, you could do something like this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"statementName"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"examples.domain.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> PRODUCT <span class="hljs-keyword">values</span> (#id#, #description#, #price#)
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Although optional for backward compatibility, it is highly recommended to always provide a parameter class (unless of course there are no required parameters).
  You will achieve better performance by providing the class, because the framework is capable of optimizing itself if it knows the type in advance.
  Without a parameterClass specified, any JavaBean with appropriate properties (get/set methods) will be accepted as a parameter, which can be very useful in some situations.</p>
</blockquote>
<h4 id="parametermap">parameterMap<a class="headerlink" href="#_toc_parametermap">←</a></h4>
<p>The value of the parameterMap attribute is the name of a defined parameterMap element (see below).
The parameterMap attribute is rarely used in favor of the parameterClass attribute (above) and inline parameters (described below).
However, this is a good approach if XML purity and consistency is your concern, or you need a more descriptive parameterMap (e.g. for stored procedures).</p>
<p>Dynamic mapped statements (described below) only support inline parameters and do not work with parameter maps.
The idea of a parameterMap is to define an ordered list of parameters that match up with the value tokens of a JDBC PreparedStatement. For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;parameterMap <span class="hljs-attr">id</span>=<span class="hljs-string">"insert-product-param"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/parameterMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameterMap</span>=<span class="hljs-string">"insert-product-param"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                ?,
                ?
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<p>In the example above, the parameter map describes two parameters that will match, in order, the value tokens ("?") in the SQL statement.
So the first "?" will be replaced by the value of the "id" property and the second with the "description" property.
Parameter maps and their options are described in more detail later in this document.</p>
<h5 id="a-quick-glance-at-inline-parameters">A Quick Glance at Inline Parameters<a class="headerlink" href="#_toc_a-quick-glance-at-inline-parameters">←</a></h5>
<p>Although further details are provided later in the document, here is a quick intro to inline parameters.
Inline parameters can be used inside of a mapped statement. For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                #id#,
                #description#
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<p>In the example above, the inline parameters are #id# and #description#.
Each represents a JavaBeans property that will be used to populate the statement parameter in-place.</p>
<p>In the example above, the Product class (that we've used from previous examples) has id and description properties
that will be read for a value to be placed in the statement where the associated property token is located.
So for a statement that is passed a Product with id=5 and description="dog", the statement might be executed as follows:</p>
<pre><code class="language-sql hljs">    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> PRODUCT (PRD_ID, PRD_DESCRIPTION) <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>, <span class="hljs-string">'dog'</span>)
</code></pre>
<h4 id="resultclass">resultClass<a class="headerlink" href="#_toc_resultclass">←</a></h4>
<p>The value of the resultClass attribute is the fully qualified name of a Java class (i.e. including package).
The resultClass attribute allows us to specify a class that will be auto-mapped to our JDBC ResultSet based on the ResultSetMetaData.</p>
<p>Wherever a property on the JavaBean and a column of the ResultSet match, the property will be populated with the column value.
This makes query mapped statements very short and sweet indeed!</p>
<p>For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getPerson"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"examples.domain.Person"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            PER_ID         <span class="hljs-keyword">AS</span> id,
            PER_FIRST_NAME <span class="hljs-keyword">AS</span> firstName,
            PER_LAST_NAME  <span class="hljs-keyword">AS</span> lastName,
            PER_BIRTH_DATE <span class="hljs-keyword">AS</span> birthDate,
            PER_WEIGHT_KG  <span class="hljs-keyword">AS</span> weightInKilograms,
            PER_HEIGHT_M   <span class="hljs-keyword">AS</span> heightInMeters
        <span class="hljs-keyword">FROM</span>
            PERSON
        <span class="hljs-keyword">WHERE</span>
            PER_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the example above, the Person class has properties including: id, firstName, lastName, birthDate, weightInKilograms and heightInMeters.
Each of these corresponds with the column aliases described by the SQL select statement (using the "as" keyword -a standard SQL feature).
Column aliases are only required if the database column names don't match, which in general they do not.
When executed, a Person object will be instantiated and the results from the result set will be mapped to the instance based on the property names and column names.</p>
<p>As stated earlier, there are some limitations of using auto-mapping with a resultClass.
There is no way to specify the types of the output columns (if necessary), there is no way to automatically load related data (complex properties)
and there is also a slight performance consequence in that this approach requires accessing the ResultSetMetaData.
All of these limitations can be overcome by using an explicit resultMap. Result maps are described in more detail later in this document.</p>
<h4 id="resultmap">resultMap<a class="headerlink" href="#_toc_resultmap">←</a></h4>
<p>The resultMap property is one of the more commonly used and most important attributes to understand.
The value of the resultMap attribute is the name of a defined resultMap element (see below).
Using the resultMap attribute allows you to control how data is extracted from a result set and which properties to map to which columns.
Unlike the auto-mapping approach using  the resultClass attribute (above), the resultMap allows you to describe the column type,
a null value replacement and complex property mappings (including other JavaBeans, Collections and primitive type wrappers).
The full details of the resultMap structure are discussed later in this document, but the following example will demonstrate how the resultMap looks related to a statement.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the example above, the ResultSet from the SQL query will be mapped to a Product instance using the resultMap definition.
The resultMap shows that the "id" property will be populated by the "PRD_ID" column and the "description" property will be populated by the "PRD_DESCRIPTION" column.</p>
<p>Notice that using "select *" is supported. There is no need to map all of the returned columns in the ResultSet.</p>
<h4 id="cachemodel">cacheModel<a class="headerlink" href="#_toc_cachemodel">←</a></h4>
<p>The cacheModel attribute value is the name of a defined cacheModel element (see below).
A cacheModel is used to describe a cache for use with a query mapped statement.
Each query mapped statement can use a different cacheModel, or the same one.
Full details of the cacheModel element and its attributes are discussed later.
The following example will demonstrate how it looks related to a statement.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"product-cache"</span> <span class="hljs-attr">imlementation</span>=<span class="hljs-string">"LRU"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"insertProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"updateProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"deleteProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"size"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProductList"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">cacheModel</span>=<span class="hljs-string">"product-cache"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_CAT_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above example, a cache is defined for products that uses a WEAK reference type and flushes every 24 hours or whenever associated update statements are executed.</p>
<h4 id="remapresults">remapResults<a class="headerlink" href="#_toc_remapresults">←</a></h4>
<p>The remapResults attribute is available on <code>&lt;statement&gt;</code>, <code>&lt;select&gt;</code>, and <code>&lt;procedure&gt;</code> mapped statements. It's an optional attribute and the default is false.
The remapResults attribute should be set to true when a query has a variable set of return columns. For example consider the following queries:</p>
<pre><code class="language-sql hljs">    <span class="hljs-keyword">SELECT</span>  $fieldList$ <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span>
</code></pre>
<p>In the former example the list of column is dynamic, even though the table is always the same.</p>
<pre><code class="language-sql hljs">    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> $sometable$
</code></pre>
<p>In the former example the table could be different. Because of the usage of * in the select clause, the resulting column names could be different as well.
Dynamic elements could also cause the column list to change from one query execution to the next one.</p>
<p>Since the overhead to introspect/determine the resultset metadata is not trivial, iBATIS will remember what was returned the last time the query was run.
This creates problems in situations similar to the examples above, hence the possibility to do metadata introspection with every query execution.
So if the return columns can change set remapResults to true, else set remapResults to false to avoid the overhead of metadata introspection.</p>
<h4 id="resultsettype">resultSetType<a class="headerlink" href="#_toc_resultsettype">←</a></h4>
<p>To specify the resultSetType of the SQL statement. It can either be:</p>
<ul>
  <li>FORWARD_ONLY: cursor may move only forward</li>
  <li>SCROLL_INSENSITIVE: cursor  is scrollable but generally not sensitive to changes made by others</li>
  <li>SCROLL_SENSITIVE: cursor  is scrollable and generally sensitive to changes made by others</li>
</ul>
<p>Note that resultSetType is generally not required and that different JDBC drivers may behave differently using the same resultSetType setting
(e.g. Oracle does not support SCROLL_SENSITIVE).</p>
<h4 id="fetchsize">fetchSize<a class="headerlink" href="#_toc_fetchsize">←</a></h4>
<p>Sets the fetchSize on the SQL statement that will be executed. It gives the JDBC driver a hint to do prefetching in order to minimize round-trips to the database server.</p>
<h4 id="timeout">timeout<a class="headerlink" href="#_toc_timeout">←</a></h4>
<p>Sets the JDBC query timeout for this statement.
Any value specified here will override the value specified in the "defaultStatementTimeout" setting in the SQLMapConfig.xml file.
If you specify a default timeout and decide that you don't want a timeout for a particular statement,
set the timeout value to 0. The specified value is the number of seconds the driver will wait for a statement to finish.</p>
<p>Note that not all drivers support this setting.</p>
<h4 id="nobatch">noBatch<a class="headerlink" href="#_toc_nobatch">←</a></h4>
<p>Sets the non-batch-able flag for <code>insert</code>, <code>update</code> and <code>delete</code> statements. By default, those statements can be executed in batch(but if <code>insert</code> statement has post <code>selectKey</code>, it's non-batch-able).</p>
<h4 id="canbatch">canBatch<a class="headerlink" href="#_toc_canbatch">←</a></h4>
<p>Sets the batch-able flag for <code>statement</code> and <code>procedure</code> statements. By default, those statements can not be executed in batch.</p>
<h3 id="duplicate-statements">Duplicate Statements<a class="headerlink" href="#_toc_duplicate-statements">←</a></h3>
<p>You should never declare duplicate statement id in SQL Map XML file, it would cause execption in iBATIS;
But in jBATIS, if there are two or more statement with same id exists, then they must:</p>
<ol>
  <li>come from different XML resource</li>
  <li>have same behavior. This means they are same at Sql, Parameter, Result and etc..</li>
</ol>
<p>Thus, if you have two same <code>&lt;sqlMap&gt;</code> as following:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-comment">&lt;!-- CLASSPATH RESOURCES --&gt;</span>
    <span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/ibatis/examples/sql/Customer.xml"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;sqlMap <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/ibatis/examples/sql/Customer.xml"</span> /&gt;</span><span class="undefined">
</span></code></pre>
<p>jBATIS would only log some <code>WARN</code> messages to remind you and continue do its things normally.</p>
<h2 id="parameter-maps-and-inline-parameters">Parameter Maps and Inline Parameters<a class="headerlink" href="#_toc_parameter-maps-and-inline-parameters">←</a></h2>
<p>As you've seen above, the parameterMap is responsible for mapping JavaBeans properties to the parameters of a statement.
Although parameterMaps are rare in their external form, understanding them will help you understand inline parameters.
Inline parameters are discussed immediately following this section.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;parameterMap <span class="hljs-attr">id</span>=<span class="hljs-string">"parameterMapName"</span> [<span class="hljs-attr">class</span>=<span class="hljs-string">"com.domain.Product"</span>]&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span> =<span class="hljs-string">"propertyName"</span> [<span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span>] [<span class="hljs-attr">javaType</span>=<span class="hljs-string">"string"</span>] 
            [<span class="hljs-attr">nullValue</span>=<span class="hljs-string">"-9999"</span>] 
            [<span class="hljs-attr">typeName</span>=<span class="hljs-string">"{REF or user-defined type}"</span>]
            [<span class="hljs-attr">resultMap</span>=<span class="hljs-string">"someResultMap"</span>]
            [<span class="hljs-attr">mode</span>=<span class="hljs-string">"IN|OUT|INOUT"</span>]
            [<span class="hljs-attr">typeHandler</span>=<span class="hljs-string">"someTypeHandler"</span>]
            [<span class="hljs-attr">numericScale</span>=<span class="hljs-string">"2"</span>]/&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">...</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">...</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/parameterMap&gt;</span><span class="undefined">
</span></code></pre>
<p>The parts in <strong>[brackets]</strong> are optional. The parameterMap itself only requires a id attribute that is an identifier that statements will use to refer to it.</p>
<p>The class attribute is optional but highly recommended. Similar to the parameterClass attribute of a statement,
the class attribute allows the framework to validate the incoming parameter as well as optimize the engine for performance.</p>
<h3 id="parameter-elements"><code>&lt;parameter&gt;</code> Elements<a class="headerlink" href="#_toc_parameter-elements">←</a></h3>
<p>The parameterMap can contain any number of parameter mappings that map directly to the parameters of a statement.
The next few sections describe the attributes of the <code>property</code> elements:</p>
<h4 id="property">property<a class="headerlink" href="#_toc_property">←</a></h4>
<p>The property attribute of the parameter map is the name of a JavaBeans property (get method) of the parameter object passed to a mapped statement.</p>
<p>The name can be used more than once depending on the number of times it is needed in the statement
(e.g. where the same property that is updated in the set clause of an SQL update statement, is also used as the key in the where clause).</p>
<h4 id="jdbctype">jdbcType<a class="headerlink" href="#_toc_jdbctype">←</a></h4>
<p>The jdbcType attribute is used to explicitly specify the database column type of the parameter to be set by this property.
Some JDBC drivers are not able to identify the type of a column for certain operations without explicitly telling the driver the column type.</p>
<p>A perfect example of this is the <code>PreparedStatement.setNull(int parameterIndex, int sqlType)</code> method.
This method requires the type to be specified. Some drivers will allow the type to be implicit by simply sending <code>Types.OTHER</code> or <code>Types.NULL</code>.
However, the behavior is inconsistent and some drivers need the exact type to be specified.
For such situations, the SQL Map API allows the type to be specified using the jdbcType attribute of the parameterMap property element.</p>
<p>This attribute is normally only required if the column is nullable.
Although, another reason to use the type attribute is to explicitly specify date types.
Whereas Java only has one Date value type (<code>java.util.Date</code>), most SQL databases have many - usually at least 3 different types.</p>
<p>Because of this you might want to specify explicitly that your column type is DATE versus DATETIME (etc.).</p>
<p>The jdbcType attribute can be set to any string value that matches a constant in the JDBC Types class.
Although it can be set to any of these, some types are not supported (e.g. blobs).
A section later in this document describes the types that are supported by the framework.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Most drivers only need the type specified for nullable columns.
  Therefore, for such drivers you only need to specify the type for the columns that are nullable.</p>
  <p>When using an Oracle driver, you will get an "Invalid column type" error if you attempt to set a null value to a column without specifying its type.</p>
</blockquote>
<h4 id="javatype">javaType<a class="headerlink" href="#_toc_javatype">←</a></h4>
<p>The javaType attribute is used to explicitly specify the Java property type of the parameter to be set.</p>
<p>Normally this can be derived from a JavaBeans property through reflection, but certain mappings such as Map and XML mappings cannot provide the type to the framework.
If the javaType is not set and the framework cannot otherwise determine the type, the type is assumed to be Object.</p>
<h4 id="typename">typeName<a class="headerlink" href="#_toc_typename">←</a></h4>
<p>The typeName attribute is used to explicitly specify a REF type or a user-defined type.</p>
<p>From the jdbc javadoc the following is stated:
The typeName attribute "...should be used for user-defined types and REF type parameters. Examples of user-defined types include: <code>STRUCT, DISTINCT, JAVA_OBJECT</code>, and named array types..."</p>
<h4 id="nullvalue">nullValue<a class="headerlink" href="#_toc_nullvalue">←</a></h4>
<p>The nullValue attribute can be set to any valid value (based on property type).
The null attribute is used to specify an outgoing null value replacement.
What this means is that when the value is detected in the JavaBeans property, a NULL will be written to the database
(the opposite behavior of an inbound null value replacement).
This allows you to use a "magic" null number in your application for types that do not support null values (e.g. int, double, float etc.).
When these types of properties contain a matching null value (e.g. -9999), a NULL will be written to the database instead of the value.</p>
<h4 id="resultmap-1">resultMap<a class="headerlink" href="#_toc_resultmap-1">←</a></h4>
<p>Specify the resultMap element when you expect an instance of <code>java.sql.ResultSet</code> as the value of a stored procedure output parameter.
This will enable iBATIS to do normal result set to object mapping.</p>
<h4 id="mode">mode<a class="headerlink" href="#_toc_mode">←</a></h4>
<p>The mode attribute specifies the mode of a stored procedure parameter. Valid values are IN, OUT, or INOUT.</p>
<h4 id="typehandler">typeHandler<a class="headerlink" href="#_toc_typehandler">←</a></h4>
<p>The typeHandler attribute is used to specify a custom type handler that will be used for this property instead of the default iBATIS type system.
If specified, this value should be the fully qualified name of a class that implements either the <code>com.ibatis.sqlmap.engine.type.TypeHandler</code> interface or the
<code>com.ibatis.sqlmap.client.extensions.TypeHandlerCallback</code> interface.
This value overrides any global type handler that might otherwise be applied to this property.
There is further detail on custom type handlers later in this document.</p>
<h4 id="numericscale">numericScale<a class="headerlink" href="#_toc_numericscale">←</a></h4>
<p>The numericScale attribute is used to specify the scale (digits to the right of the decimal point) for NUMERIC or DECIMAL stored procedure output parameters.
If you specify OUT or INOUT for the mode attribute, and the jdbcType is DECIMAL or NUMERIC, then you should also specify a value for numericScale.
The value specified for this attribute must be an integer greater than or equal to zero.</p>
<h3 id="a-parametermap-example">A <code>&lt;parameterMap&gt;</code> Example<a class="headerlink" href="#_toc_a-parametermap-example">←</a></h3>
<p>An example of a parameterMap that uses the full structure is as follows</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;parameterMap <span class="hljs-attr">id</span>=<span class="hljs-string">"insert-product-param"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"NUMERIC"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">nullValue</span>=<span class="hljs-string">"-9999999"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">nullValue</span>=<span class="hljs-string">"NO_ENTRY"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/parameterMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameterMap</span>=<span class="hljs-string">"insert-product-param"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                ?,
                ?
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above example, the JavaBeans properties id and description will be applied to the parameters of the Mapped Statement insertProduct in the order they are listed.
So, id will be applied to the first parameter (?) and description to the second. If the orders were reversed, the XML would look like the following:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;parameterMap <span class="hljs-attr">id</span>=<span class="hljs-string">"insert-product-param"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;parameter <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/parameterMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameterMap</span>=<span class="hljs-string">"insert-product-param"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_DESCRIPTION,
                PRD_ID
            )
        <span class="hljs-keyword">VALUES</span>
            (
                ?,
                ?
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Parameter Map names are always local to the SQL Map XML file that they are defined in.
  You can refer to a Parameter Map in another SQL Map XML file by prefixing the id of the Parameter Map with the id of the SQL Map (set in the <code>&lt;sqlMap&gt;</code> root tag).
  For example, to refer to the above parameter map from a different file, the full name to reference would be <code>"Product.insert-product-param"</code>.</p>
</blockquote>
<h3 id="inline-parameter-maps">Inline Parameter Maps<a class="headerlink" href="#_toc_inline-parameter-maps">←</a></h3>
<p>Although very descriptive, the above syntax for declaring parameterMaps is very verbose.
There is a more popular syntax for Parameter Maps that can simplify the definition and reduce code.
This alternate syntax places the JavaBeans property names inline with the Mapped Statement (i.e. coded directly into the SQL).
By default, any Mapped Statement that has no explicit parameterMap specified will be parsed for inline parameters.
The previous example (i.e. product), implemented with an inline parameter map, would look like this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                #id#,
                #description#
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<p>Declaring types can be accomplished with inline parameters by using the following syntax:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                #id:<span class="hljs-built_in">NUMERIC</span>#,
                #description:<span class="hljs-built_in">VARCHAR</span>#
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<p>Declaring types and null value replacements can be accomplished with inline parameters by using the following syntax:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;insert <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.domain.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">INSERT</span>
        <span class="hljs-keyword">INTO</span>
            PRODUCT
            (
                PRD_ID,
                PRD_DESCRIPTION
            )
        <span class="hljs-keyword">VALUES</span>
            (
                #id:<span class="hljs-built_in">NUMERIC</span>:<span class="hljs-number">-999999</span>#,
                #description:<span class="hljs-built_in">VARCHAR</span>:NO_ENTRY#
            )
    </span><span class="hljs-symbol">&lt;/insert&gt;</span><span class="undefined">
</span></code></pre>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>When using inline parameters, you cannot specify the null value replacement without also specifying the type. You must specify both due to the parsing order.</li>
    <li>If you want full transparency of null values, you must also specify null value replacements in your result maps, as discussed later in this document.</li>
    <li>If you require a lot of type descriptors and null value replacements, you might be able to achieve cleaner code by using an external parameterMap.</li>
    <li>A <code>#</code> is the escape char for another <code>#</code>, thus <code>##</code> is treated as <code>#</code>. Orphan <code>#</code> will cause exception.</li>
    <li>But <code>#</code> in sql literal such as <code>'a normal # char'</code> is treated as normal char in jBATIS.</li>
  </ul>
</blockquote>
<h4 id="inline-parameter-map-syntax">Inline Parameter Map Syntax<a class="headerlink" href="#_toc_inline-parameter-map-syntax">←</a></h4>
<p>iBATIS supports two different syntaxes for in line parameter maps - a simple syntax, and a more advanced and more complete syntax..
The simple syntax is as follows:</p>
<pre><code class="language-less hljs">    <span class="hljs-selector-id">#propertyName</span><span class="hljs-selector-attr">[:jdbcType[:nullValue]</span>]#
</code></pre>
<p>Examples of this syntax are as above.
The <code>propertyName</code> element is the name of a property in the parameter object
(or the value of the parameter object itself if the parameter object is a simple value like String, Integer, etc.).</p>
<p>The <code>jdbcType</code> element is used to specify the JDBC type of the parameter.
The value must be one of the types listed in <code>java.sql.Types</code> (<code>VARCHAR</code>, <code>INTEGER</code>, etc.)</p>
<p>Generally the <code>jdbcType</code> element is needed if there is a possibility that the value could be <code>NULL</code>, or to specify the use of <code>DATE</code> or <code>TIME</code> fields
(as opposed to <code>TIMESTAMP</code> fields).</p>
<p>The <code>nullValue</code> element is used to specify the <code>NULL</code> replacement value as described above.
Note that you cannot specify <code>nullValue</code> unless you also specify jdbcType.</p>
<p>This syntax is appropriate in almost all situations unless you need access to the some of the advanced options of a formal parameter map
(for example, when calling a stored procedure).</p>
<p>The more advanced syntax is as follows:</p>
<pre><code class="language-less hljs">    <span class="hljs-selector-id">#propertyName</span>,<span class="hljs-selector-tag">javaType</span>=?,<span class="hljs-selector-tag">jdbcType</span>=?,<span class="hljs-selector-tag">mode</span>=?,<span class="hljs-selector-tag">nullValue</span>=?,<span class="hljs-selector-tag">handler</span>=?,<span class="hljs-selector-tag">numericScale</span>=?#
</code></pre>
<p>Where "?" is a value you specify for the attribute.</p>
<p>The advanced syntax gives you access to most values of a formal parameter map.
The <code>propertyName</code> element is required, all other values are optional.
The values can be specified in any order, except that the propertyName element must be first.
Values allowed for the different attributes are exactly what is allowed when using a formal parameter map.
Also note that with this syntax, the handler attribute will use an aliased name for the type handler is such an alias is registered.
An example of this syntax used to call a stored procedure is as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;procedure <span class="hljs-attr">id</span>=<span class="hljs-string">"callProcedure"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"com.mydomain.MyParameter"</span>&gt;</span><span class="sql">
        {CALL MyProcedure (
            #parm1, jdbcType=<span class="hljs-built_in">INTEGER</span>, mode=<span class="hljs-keyword">IN</span>#,
            #parm2, jdbcType=<span class="hljs-built_in">INTEGER</span>, mode=<span class="hljs-keyword">IN</span>#,
            #parm3, jdbcType=<span class="hljs-built_in">DECIMAL</span>, mode=OUT, numericScale=<span class="hljs-number">2</span>#
        )}
    </span><span class="hljs-symbol">&lt;/procedure&gt;</span><span class="undefined">
</span></code></pre>
<h4 id="param"><code>#%param%#</code><a class="headerlink" href="#_toc_param">←</a></h4>
<p>If a inline paramter starts or ends with <code>%</code>, such as <code>#%param#</code> or <code>#param%#</code> or <code>#%param%#</code>, for example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            id, name
        <span class="hljs-keyword">FROM</span>
            my_table
        <span class="hljs-keyword">WHERE</span> acol <span class="hljs-keyword">LIKE</span> #myparam%#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>The real parameter passed into JDBC layer is <code>myparam + "%"</code>.</p>
<p>This is convenient for users. You'd better ensure the <code>myparam</code> value is type of <code>java.lang.String</code>, otherwise, the result is not determinate.</p>
<h3 id="primitive-type-parameters">Primitive Type Parameters<a class="headerlink" href="#_toc_primitive-type-parameters">←</a></h3>
<p>It is not always necessary or convenient to write a JavaBean just to use as a parameter.
In these cases you are perfectly welcome to use a primitive type wrapper object (String, Integer, Date etc.) as the parameter directly. For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"insertProduct"</span> <span class="hljs-attr">parameter</span>=<span class="hljs-string">"java.lang.Integer"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>Assuming <code>PRD_ID</code> is a numeric type, when a call is made to this mapped statement an <code>java.lang.Integer</code> object can be passed in.
The <code>#value#</code> parameter will be replaced with the value of the Integer instance. The name <code>"value"</code> is simply a placeholder and can be any moniker.
Result Maps (discussed below) support primitive types as results as well.
See the Result Map section and Programming SQL Map (API) section below for more information about using primitive types as parameters.</p>
<p>Primitive types are aliased for more concise code. For example, <code>"int"</code> can be used in place of <code>"java.lang.Integer"</code>.
The aliases are described in the table below titled: "Supported Types for Parameter Maps and Result Maps".</p>
<h3 id="map-type-parameters">Map Type Parameters<a class="headerlink" href="#_toc_map-type-parameters">←</a></h3>
<p>If you are in a situation where it is not necessary or convenient to write a JavaBean class, and a single primitive type parameter won't do
(e.g. there are multiple parameters), you can use a Map (e.g. HashMap, TreeMap) as a parameter object.</p>
<p>For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"listProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"java.util.Map"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_CAT_ID   = #catId#
            <span class="hljs-keyword">AND</span> PRD_CODE = #code#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>Notice that there is no difference in the mapped statement implementation!
In the above example, if a Map instance was passed into the call to the statement, the Map must contain keys named "catId" and "code"
The values referenced by those keys would be of the appropriate type, such as Integer and String (for the example above).</p>
<p>Result Maps (discussed below) support Map types as results as well.</p>
<p>See the Result Map section and Programming SQL Map (API) section below for more information about using Map types as parameters.
Map types are also aliased for more concise code. For example, "map" can be used in place of "java.util.Map".
The aliases are described in the table below titled: "Supported Types for Parameter Maps and Result Maps".</p>
<h2 id="result-maps">Result Maps<a class="headerlink" href="#_toc_result-maps">←</a></h2>
<p>Result maps are an extremely important component of SQL Map.
The resultMap is responsible for mapping JavaBeans properties to the columns of a ResultSet produced by executing a query mapped statement.
The structure of a resultMap looks like this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap  <span class="hljs-attr">id</span>=<span class="hljs-string">"resultMapName"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"some.domain.Class"</span>
           [<span class="hljs-attr">extends</span>=<span class="hljs-string">"parent-resultMap"</span>]
           [<span class="hljs-attr">groupBy</span>=<span class="hljs-string">"some property list"</span>]&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"propertyName"</span>  <span class="hljs-attr">column</span>=<span class="hljs-string">"COLUMN_NAME"</span> 
                             [<span class="hljs-attr">columnIndex</span>=<span class="hljs-string">"1"</span>]  [<span class="hljs-attr">javaType</span>=<span class="hljs-string">"int"</span>]  [<span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"NUMERIC"</span>]  
                             [<span class="hljs-attr">nullValue</span>=<span class="hljs-string">"-999999"</span>] [<span class="hljs-attr">select</span>=<span class="hljs-string">"someOtherStatement"</span>]
                             [<span class="hljs-attr">resultMap</span>=<span class="hljs-string">"someOtherResultMap"</span>]
                             [<span class="hljs-attr">typeHandler</span>=<span class="hljs-string">"com.mydomain.MyTypehandler"</span>]
                             /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">...</span>/&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">...</span>/&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
</span></code></pre>
<p>The parts in <strong>[brackets]</strong> are optional.
The resultMap itself has a id attribute that statements will use to refer to it.
The resultMap also has a class attribute that is the fully qualified  (i.e. full package) name of a class or a type alias.
This class will be instantiated and populated based on the result mappings it contains.
The extends attribute can be optionally set to the name of another resultMap upon which to base a resultMap.
This is similar to extending a class in Java, all properties of the super resultMap will be included as part of the sub resultMap.</p>
<p>The properties of the super resultMap are always inserted before the sub resultMap properties and the parent resultMap must be defined before the child.
The classes for the super/sub resultMaps need not be the same, nor do they need to be related at all (they can each use any class).</p>
<p>The resultMap element also supports the attribute <code>groupBy</code>.
The <code>groupBy</code> attribute is used to specify a list of properties in this resultMap that are used to identify unique rows in the returned result set.
Rows with equal values for the specified properties will only generate one result object.
Use <code>groupBy</code> in combination with nested resultMaps to solve the N+1 query problem (see following discussion for examples).</p>
<p>The resultMap can contain any number of result mappings that map JavaBean properties to the columns of a ResultSet.
These property mappings will be applied in the order that they are defined in the document.
The associated class must be a JavaBeans compliant class with appropriate get/set methods for each of the properties or a Map.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>The columns will be read explicitly in the order specified in the Result Map (this comes in handy for some poorly written JDBC drivers).</li>
    <li><code>groupBy</code> attribute can specify multiple properties by comma separated property names, such as <code>groupBy="id, name"</code>.</li>
  </ul>
</blockquote>
<h3 id="attributes-in-result-element">Attributes in <code>&lt;result&gt;</code> element<a class="headerlink" href="#_toc_attributes-in-result-element">←</a></h3>
<p>The next few sections describe the attributes of the result elements:</p>
<h4 id="property-1">property<a class="headerlink" href="#_toc_property-1">←</a></h4>
<p>The property attribute of the result map property is the name of a JavaBeans property (get method) of the result object that will be returned by the mapped statement.
The name can be used more than once depending on the number of times it is needed to populate the results.</p>
<h4 id="column">column<a class="headerlink" href="#_toc_column">←</a></h4>
<p>The column attribute value is the name of the column in the ResultSet from which the value will be used to populate the property.</p>
<h4 id="columnindex">columnIndex<a class="headerlink" href="#_toc_columnindex">←</a></h4>
<p>As an optional (minimal) performance enhancement, the columnIndex attribute value is the index of the column in the ResultSet from which the value will be used to populate the JavaBeans property.
This is not likely needed in 99% of applications and sacrifices maintainability and readability for speed.
Some JDBC drivers may not realize any performance benefit, while others will speed up dramatically.</p>
<h4 id="jdbctype-1">jdbcType<a class="headerlink" href="#_toc_jdbctype-1">←</a></h4>
<p>The jdbcType attribute is used to explicitly specify the database column type of the ResultSet column that will be used to populate the JavaBean property.
Although result maps do not have the same difficulties with null values, specifying the type can be useful for certain mapping types such as Date properties.
Because Java only has one Date value type and SQL databases may have many (usually at least 3), specifying the date may become necessary in some cases to ensure that dates (or other types) are set correctly.
Similarly, String types may be populated by a VARCHAR, CHAR or CLOB, so specifying the type might be needed in those cases too (driver dependent).</p>
<h4 id="javatype-1">javaType<a class="headerlink" href="#_toc_javatype-1">←</a></h4>
<p>The javaType attribute is used to explicitly specify the Java property type of the property to be set.
Normally this can be derived from a JavaBeans property through reflection, but certain mappings such as Map and XML mappings cannot provide the type to the framework.
If the javaType is not set and the framework cannot otherwise determine the type, the type is assumed to be Object.</p>
<h4 id="nullvalue-1">nullValue<a class="headerlink" href="#_toc_nullvalue-1">←</a></h4>
<p>The nullValue attribute specifies the value to be used in place of a NULL value in the database.
So if a <code>NULL</code> is read from the ResultSet, the JavaBean property will be set to the value specified by the <code>nullValue</code> attribute instead of <code>NULL</code>.
The null attribute value can be any value, but must be appropriate for the property type.</p>
<p>If your database has a NULLABLE column, but you want your application to represent NULL with a constant value you can specify it in the result map as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"subCode"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_SUB_CODE"</span> <span class="hljs-attr">nullValue</span>=<span class="hljs-string">"-999"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above example, if <code>PRD_SUB_CODE</code> is read as NULL, then the <code>subCode</code> property will be set to the value of <code>-999</code>.
This allows you to use a primitive type in your Java class to represent a NULLABLE column in the database.</p>
<p>Remember that if you want this to work for queries as well as updates/inserts, you must also specify the nullValue in the parameter map.</p>
<h4 id="select">select<a class="headerlink" href="#_toc_select">←</a></h4>
<p>The select attribute is used to describe a relationship between objects and automatically load complex (i.e. user defined) property types.
The value of the statement property must be the name of another mapped statement.
The value of the database column (the column attribute) that is defined in the same property element as this statement attribute will be passed to the related mapped statement as the parameter.
Therefore the column must be a supported, primitive type.</p>
<p>More information  about supported primitive types and complex property mappings/relationships is discussed later in this document.</p>
<h4 id="resultmap-2">resultMap<a class="headerlink" href="#_toc_resultmap-2">←</a></h4>
<p>The resultMap attribute is used to describe a nested resultMap that can be reused in the result mapping.</p>
<p>This can be used in 1:1 relationships or 1:N relationships. If you expect a 1:N relationship, then the related property should be a Collection (List, Set, Collection, etc.),
and you should also specify the <code>groupBy</code> attribute on the resultMap element to denote how iBATIS will group the rows.
In 1:1 relationships, the related property can be of any type and the <code>groupBy</code> attribute may, or may not, be specified.
It is also possible to use the <code>groupBy</code> attribute when some joins are 1:N and some are 1:1.</p>
<h4 id="typehandler-1">typeHandler<a class="headerlink" href="#_toc_typehandler-1">←</a></h4>
<p>The typeHandler attribute is used to specify a custom type handler that will be used for this property instead of the default iBATIS type system.
If specified, this value should be the fully qualified name of a class that implements either the <code>com.ibatis.sqlmap.engine.type.TypeHandler</code> interface or the
<code>com.ibatis.sqlmap.client.extensions.TypeHandlerCallback</code> interface.
This value overrides any global type handler that might otherwise be applied to this property.</p>
<p>There is further detail on custom type handlers later in this document.</p>
<h3 id="implicit-result-maps">Implicit Result Maps<a class="headerlink" href="#_toc_implicit-result-maps">←</a></h3>
<p>If you have a very simple requirement that does not require the reuse of an explicitly defined resultMap,
there is a quick way to implicitly specify a result map by setting a resultClass attribute of a mapped statement.</p>
<p>The trick is that you must ensure that the result set returned has column names (or labels/aliases) that match up with the write-able property names of your JavaBean.</p>
<p>For example, if we consider the Product class described above, we could create a mapped statement with an implicit result map as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            PRD_ID          <span class="hljs-keyword">AS</span> id,
            PRD_DESCRIPTION <span class="hljs-keyword">AS</span> description
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>The above mapped statement specifies a resultClass and declares aliases for each column that match the JavaBean properties of the Product class.
This is all that is required, no result map is needed.</p>
<p>The tradeoff here is that you don't have an opportunity to specify a column type (normally not required) or a null value (or any other property attributes).
Since many databases are not case sensitive, implicit result maps are not case sensitive either.</p>
<p>So if your JavaBean had two properties, one named firstName and another named firstname,
these would be considered identical and you could not use an implicit result map (it would also identify a potential problem with the design of the JavaBean class).
Furthermore, there is some performance overhead associated with auto-mapping via a resultClass.
Accessing ResultSetMetaData can be slow with some poorly written JDBC drivers.</p>
<h3 id="primitive-results">Primitive Results<a class="headerlink" href="#_toc_primitive-results">←</a></h3>
<p>In addition to supporting JavaBeans compliant classes, Result Maps can conveniently populate a simple Java type wrapper such as String, Integer, Boolean etc.
Collections of primitive objects can also be retrieved using the APIs described below (see queryForList()).
Primitive types are mapped exactly the same way as a JavaBean, with only one thing to keep in mind.
A primitive type can only have one property that can be named anything you like (usually "value" or "val").
For example, if we wanted to load just a list of all product descriptions (Strings) instead of the entire Product class, the map would look like this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"value"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
</span></code></pre>
<p>A simpler approach is to simply use a result class in a mapped statement (make note of the column alias "value" using the "as" keyword):</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProductCount"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"java.lang.Integer"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> value
        <span class="hljs-keyword">FROM</span>
            PRODUCT
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="map-results">Map Results<a class="headerlink" href="#_toc_map-results">←</a></h3>
<p>Result Maps can also conveniently populate a Map instance such as HashMap or TreeMap.
Collections of such objects (e.g. Lists of Maps) can also be retrieved using the APIs described below (see queryForList()).
Map types are mapped exactly the same way as a JavaBean, but instead of setting JavaBeans properties, the keys of the Map are set to reference the values for the corresponding mapped columns.</p>
<p>For example, if we wanted to load the values of a product quickly into a Map, we could do the following:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.util.HashMap"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"code"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_CODE"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"suggestedPrice"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_SUGGESTED_PRICE"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
</span></code></pre>
<p>In the example above, an instance of HashMap would be created and populated with the Product data.
The property name attributes (e.g. "id") would be the keys of the HashMap, and the values of the mapped columns would be the values in the HashMap.
Of course, you can also use an implicit result map with a Map type. For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProductCount"</span> <span class="hljs-attr">resultClass</span>=<span class="hljs-string">"java.util.HashMap"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>The above would basically give you a Map representation of the returned ResultSet.</p>
<h3 id="complex-properties">Complex Properties<a class="headerlink" href="#_toc_complex-properties">←</a></h3>
<p>It is possible to automatically populate properties of complex types (classes created by the user) by associating a resultMap property with a mapped statement that knows how to load the appropriate data and class.
In the database the data is usually represented via a 1:1 relationship,
or a 1:M relationship where the class that holds the complex property is from the "many side" of the relationship and the property itself is from the "one side" of the relationship.</p>
<p>Consider the following example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"category"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_CAT_ID"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"getCategory"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-category-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Category"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getCategory"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-category-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            CATEGORY
        <span class="hljs-keyword">WHERE</span>
            CAT_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above example, an instance of Product has an property called category of type Category.
Since category is a complex user type (i.e. a user defined class), JDBC does not have the means to populate it.
By associating another mapped statement with the property mapping, we are providing enough information for the SQL Map engine to populate it appropriately.</p>
<p>Upon executing getProduct, the get-product-result Result Map will call getCategory using the value returned in the PRD_CAT_ID column.
The get-categoryresult Result Map will instantiate a Category and populate it. The whole Category instance then gets set into the Product's category property.</p>
<h3 id="avoiding-n1-selects-11">Avoiding N+1 Selects (1:1)<a class="headerlink" href="#_toc_avoiding-n1-selects-11">←</a></h3>
<p>The problem with the solution above is that whenever you load a Product, two SQL statements are actually being run (one for the Product and one for the Category).
This problem seems trivial when loading a single Product, but if you were to run a query that loaded ten (10) Products, a separate query would be run for each Product to load its associated category.
This results in eleven (11) queries total: one for the list of Products and one for each Product returned to load each related Category (N+1 or in this case 10+1=11).</p>
<p>The solution is to use a join and nested property mappings instead of a separate select statement.
Here's an example using the same situation as above (Products and Categories):</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"category.id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"category.description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT,
            CATEGORY
        <span class="hljs-keyword">WHERE</span>
            PRD_CAT_ID = CAT_ID
            <span class="hljs-keyword">AND</span> PRD_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>You can also reuse a result map in a 1:1 query instead of repeating the columns. An example of this usage is as follows</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"category"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-category-result"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-category-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Category"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT,
            CATEGORY
        <span class="hljs-keyword">WHERE</span>
            PRD_CAT_ID = CAT_ID
            <span class="hljs-keyword">AND</span> PRD_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="lazy-loading-vs-joins-11">Lazy Loading vs. Joins (1:1)<a class="headerlink" href="#_toc_lazy-loading-vs-joins-11">←</a></h3>
<p>It's important to note that using a join is not always better.
If you are in a situation where it is rare to access the related object (e.g. the category property of the Product class)
then it might actually be faster to avoid the join and the unnecessary loading of all category properties.
This is especially true for database designs that involve outer joins or nullable and/or non-indexed columns.</p>
<p>In these situations it might be better to use the sub-select solution with the lazy loading and bytecode enhancement options enabled (see SQL Map Config settings).
The general rule of thumb is: use the join if you're more likely going to access the associated properties than not.
Otherwise, only use it if lazy loading is not an option.
If you're having trouble deciding which way to go, don't worry. No matter which way you go, you can always change it without impacting your Java code.
The two examples above would result in exactly the same object graph and are loaded using the exact same method call.</p>
<p>The only consideration is that if you were to enable caching, then the using the separate select (not the join) solution could result in a cached instance being returned.
But more often than not, that won't cause a problem (your app shouldn't be dependent on instance level equality i.e. "==").</p>
<h3 id="complex-collection-properties">Complex Collection Properties<a class="headerlink" href="#_toc_complex-collection-properties">←</a></h3>
<p>It is also possible to load properties that represent lists of complex objects. In the database the data would be represented by a M:M relationship,
or a 1:M relationship where the class containing the list is on the "one  side" of the relationship and the objects in the list are on the "many side".
To load a List of objects, there is no change to the statement (see example above).</p>
<p>The only difference required to cause the SQL Map framework to load the property as a List is that the property on the business object must be of type <code>java.util.List</code>
or <code>java.util.Collection</code>. For example, if a Category has a List of Product instances,
the mapping would look like this (assume Category has a property called "productList" of type <code>java.util.List</code>):</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-category-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Category"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_DESCRIPTION"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"productList"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_ID"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"getProductsByCatId"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-product-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getCategory"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-category-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            CATEGORY
        <span class="hljs-keyword">WHERE</span>
            CAT_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProductsByCatId"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_CAT_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="avoiding-n1-selects-1m-and-mn">Avoiding N+1 Selects (1:M and M:N)<a class="headerlink" href="#_toc_avoiding-n1-selects-1m-and-mn">←</a></h3>
<p>This is similar to the 1:1 situation above, but is of even greater concern due to the potentially large amount of data involved.
The problem with the solution above is that whenever you load a Category, two SQL statements are actually being run
(one for the Category and one for the list of associated Products).</p>
<p>This problem seems trivial when loading a single Category, but if you were to run a query that loaded ten (10) Categories,
a separate query would be run for each Category to load its associated list of Products.
This results in eleven (11) queries total: one for the list of Categories and one for each Category returned to load each related list of Products
(N+1 or in this case 10+1=11).</p>
<p>To make this situation worse, we're dealing with potentially large lists of data.</p>
<h4 id="1n--mn-solution">1:N &amp; M:N Solution<a class="headerlink" href="#_toc_1n--mn-solution">←</a></h4>
<p>iBATIS fully solves the N+1 selects solution. Here is an example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"categoryResult"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Category"</span> <span class="hljs-attr">groupBy</span>=<span class="hljs-string">"id"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"CAT_DESCRIPTION"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"productList"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"ProductCategory.productResult"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"productResult"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Product"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"PRD_DESCRIPTION"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getCategory"</span> <span class="hljs-attr">parameterClass</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"categoryResult"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            C.CAT_ID,
            C.CAT_DESCRIPTION,
            P.PRD_ID,
            P.PRD_DESCRIPTION
        <span class="hljs-keyword">FROM</span>
            CATEGORY C
        <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span>
            PRODUCT P
                <span class="hljs-keyword">ON</span> C.CAT_ID = P.PRD_CAT_ID
        <span class="hljs-keyword">WHERE</span>
            CAT_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>When you call</p>
<pre><code class="language-java hljs">    List&lt;Category&gt; myList = queryForList(<span class="hljs-string">"ProductCategory.getCategory"</span>, <span class="hljs-number">1002</span>);
</code></pre>
<p>the main query is executed, and the results are stored in the myList variable as beans of type "com.ibatis.example.Category".
Each object in that List will have a "productList" property that is also a List populated from the same query,
but using the "productResult" result map to populate the beans in the child list.
So, you end up with a list containing sub-lists, and only one database query is executed.</p>
<p>The important items here are the</p>
<pre><code class="language-prop hljs properties">    groupBy=<span class="hljs-string">"id"
</span></code></pre>
<p>attribute and the</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"productList"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"ProductCategory.productResult"</span>/&gt;</span><span class="undefined">
</span></code></pre>
<p>property mapping in the "categoryResult" result map.</p>
<p>One other important detail is that the result mapping for the productList property is namespace aware - had it been simply "productResult" it would not work.
Using this approach, you can solve any N+1 problem of any depth or breadth.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Combining the <code>groupBy</code> behavior with the queryForPag*() API is undefined behavior and is likely to return different results than you expect.
  Please do not attempt to combine these two ideas. If you are using <code>groupBy</code>, you should always use the <code>queryForList</code> or <code>queryForObject</code> methods.</p>
</blockquote>
<p>The nested property can be any implementation of <code>java.util.Collection</code>, but the getter and setter for the property should be a simple and just provide access to the internal attribute.
iBATIS will repeatedly call the get method to access the property, and then call the property's add() method as it is processing the result set.
Do not try to do anything out of the ordinary with the getters and setters (like trying to wrap an internal array in a List) - this will likely cause iBATIS to fail.
There is a common misconception that iBATIS somehow batches up the objects and calls the set method just one time.
This is not the case - iBATIS only calls the set method if the get method returns null - in which case iBATIS will create a default implementation of the property and sets the new object into the result object.
The newly created object will always be empty - because iBATIS will then call the get method to obtain the property property and call the add method.</p>
<h4 id="lazy-loading-vs-joins-1m-and-mn">Lazy Loading vs. Joins (1:M and M:N)<a class="headerlink" href="#_toc_lazy-loading-vs-joins-1m-and-mn">←</a></h4>
<p>As with the 1:1 situation described previously, it's important to note that using a join is not always better.
This is even more true for collection properties than it was for individual value properties due to the greater amount of data.
If you are in a situation where it is rare to access the related object (e.g. the productList property of the Category class)
then it might actually be faster to avoid the join and the unnecessary loading of the list of products.
This is especially true for database designs that involve outer joins or nullable and/or non-indexed columns.
In these situations it might be better to use the sub-select solution with the lazy loading and bytecode enhancement options enabled (see SQL Map Config settings).
The general rule of thumb is: use the join if you're more likely going to access the associated properties than not.
Otherwise, only use it if lazy loading is not an option.</p>
<p>As mentioned earlier, if you're having trouble deciding which way to go, don't worry. No matter which way you go,
you can always change it without impacting your Java code.
The two examples above would result in exactly the same object graph and are loaded using the exact same method call.
The only consideration is that if you were to enable caching, then the using the separate select (not the join)
solution could result in a cached instance being returned. But more often than not, that won't cause a problem
(your app shouldn't be dependent on instance level equality i.e. "==").</p>
<h3 id="composite-keys-or-multiple-complex-parameters-properties">Composite Keys or Multiple Complex Parameters Properties<a class="headerlink" href="#_toc_composite-keys-or-multiple-complex-parameters-properties">←</a></h3>
<p>You might have noticed that in the above examples there is only a single key being used as specified in the resultMap by the column attribute.
This would suggest that only a single column can be associated to a related mapped statement.
However, there is an alternate syntax that allows multiple columns to be passed to the related mapped statement.
This comes in handy for situations where a composite key relationship exists, or even if you simply want to use a parameter of some name other than #value#.</p>
<p>The <strong>alternate syntax for the <code>column</code> attribute</strong> is simply as:</p>
<pre><code class="language-less hljs">    { <span class="hljs-selector-tag">param1</span>=<span class="hljs-selector-tag">column1</span>, <span class="hljs-selector-tag">param2</span>=<span class="hljs-selector-tag">column2</span>, ..., <span class="hljs-selector-tag">paramN</span>=<span class="hljs-selector-tag">columnN</span> }
</code></pre>
<p>Consider the example below where the PAYMENT table is keyed by both Customer ID and Order ID:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;resultMap <span class="hljs-attr">id</span>=<span class="hljs-string">"get-order-result"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.example.Order"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ORD_ID"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"customerId"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ORD_CST_ID"</span> /&gt;</span><span class="undefined">
        ...
        </span><span class="hljs-symbol">&lt;result <span class="hljs-attr">property</span>=<span class="hljs-string">"payments"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"{itemId=ORD_ID, custId=ORD_CST_ID}"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"getOrderPayments"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/resultMap&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getOrderPayments"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-payment-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PAYMENT
        <span class="hljs-keyword">WHERE</span>
            PAY_ORD_ID     = #itemId#
            <span class="hljs-keyword">AND</span> PAY_CST_ID = #custId#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>Currently the SQL Map framework does not automatically resolve circular relationships.
    Be aware of this when implementing parent/child relationships (trees).
    An easy workaround is to simply define a second result map for one of the cases that does not load the parent object (or vice versa),
    or use a join as described in the "N+1 avoidance" solutions.</li>
    <li>Some JDBC drivers (e.g. PointBase Embedded) do not support multiple ResultSets (per connection) open at the same time.
    Such drivers will not work with complex object mappings because the SQL Map engine requires multiple ResultSet connections.
    Again, using a join instead can resolve this.</li>
    <li>Result Map names are always local to the SQL Map XML file that they are defined in.
    You can refer to a Result Map in another SQL Map XML file by prefixing the name of the Result Map with the name of the SQL Map (set in the <code>&lt;sqlMap&gt;</code> root tag).</li>
  </ul>
</blockquote>
<h2 id="supported-types-for-parameter-maps-and-resultmaps">Supported Types for Parameter Maps and ResultMaps<a class="headerlink" href="#_toc_supported-types-for-parameter-maps-and-resultmaps">←</a></h2>
<p>The Java types supported by the iBATIS framework for parameters and results are as follows:</p>
<table border="1">
  <thead>
    <tr><th>Java Type</th><th>JavaBean/Map / Property Mapping</th><th>Result Class/Parameter Class***</th><th>Type Alias**</th></tr>
  </thead>
  <tbody>
    <tr><td>boolean</td><td>YES</td><td>NO</td><td>boolean</td></tr>
    <tr><td>java.lang.Boolean</td><td>YES</td><td>YES</td><td>boolean</td></tr>
    <tr><td>byte</td><td>YES</td><td>NO</td><td>byte</td></tr>
    <tr><td>java.lang.Byte</td><td>YES</td><td>YES</td><td>byte</td></tr>
    <tr><td>short</td><td>YES</td><td>NO</td><td>short</td></tr>
    <tr><td>java.lang.Short</td><td>YES</td><td>YES</td><td>short</td></tr>
    <tr><td>int</td><td>YES</td><td>NO</td><td>int/integer</td></tr>
    <tr><td>java.lang.Integer</td><td>YES</td><td>YES</td><td>int/integer</td></tr>
    <tr><td>long</td><td>YES</td><td>NO</td><td>long</td></tr>
    <tr><td>java.lang.Long</td><td>YES</td><td>YES</td><td>long</td></tr>
    <tr><td>float</td><td>YES</td><td>NO</td><td>float</td></tr>
    <tr><td>java.lang.Float</td><td>YES</td><td>YES</td><td>float</td></tr>
    <tr><td>double</td><td>YES</td><td>NO</td><td>double</td></tr>
    <tr><td>java.lang.Double</td><td>YES</td><td>YES</td><td>double</td></tr>
    <tr><td>java.lang.String</td><td>YES</td><td>YES</td><td>string</td></tr>
    <tr><td>java.util.Date</td><td>YES</td><td>YES</td><td>date</td></tr>
    <tr><td>java.math.BigDecimal</td><td>YES</td><td>YES</td><td>decimal</td></tr>
    <tr><td>java.sql.Date*</td><td>YES</td><td>YES</td><td>N/A</td></tr>
    <tr><td>ava.sql.Time*</td><td>YES</td><td>YES</td><td>N/A</td></tr>
    <tr><td>java.sql.Timestamp*</td><td>YES</td><td>YES</td><td>N/A</td></tr>
  </tbody>
  <caption>Supported Types for Parameter Maps and Result Maps</caption>
</table>
<p>Note that type aliases are case sensitive. So type aliases "string", "String", "StrinG" all map to the java type <code>"java.lang.String"</code>.</p>
<blockquote>
  <p><code>*</code> The use of <code>java.sql.*</code> data types is discouraged. It is a best practice to use <code>java.util.Date</code> instead.</p>
  <p><code>**</code> Type Aliases can be used in place of the full class name when specifying parameter or result classes.</p>
  <p><code>***</code>  Primitive types such as int, boolean and float cannot be directly supported as primitive types, as the iBATIS Database Layer is a fully Object Oriented approach.
  Therefore all parameters and results must be an Object at their highest level.</p>
</blockquote>
<h3 id="creating-custom-type-handlers">Creating custom Type Handlers<a class="headerlink" href="#_toc_creating-custom-type-handlers">←</a></h3>
<p>Type support can be extended in iBATIS through the use of  the TypeHandler or the TypeHandlerCallback interface.
The TypeHandlerCallback interface is simpler to implement, so we recommed using it over the more complex TypeHandler interface.
To create your own type handler you need to create a class that implements the TypeHandlerCallback.
Using a custom type handler you can extend the framework to handle types that are not supported, or handle supported types in a different way.
For example, you might use a custom type handler to implement proprietary BLOB support (e.g. Oracle), or you might use it to handle booleans using "Y" and "N" instead of the more typical 0/1.
Here's a simple example of a boolean handler that uses "Yes" and "No":</p>
<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YesNoBoolTypeHandlerCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeHandlerCallback</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String YES = <span class="hljs-string">"Y"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NO = <span class="hljs-string">"N"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResult</span><span class="hljs-params">(ResultGetter getter)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
        String s = getter.getString();
        <span class="hljs-keyword">if</span> (YES.equalsIgnoreCase(s)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">true</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (NO.equalsIgnoreCase(s)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">false</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"Unexpected value "</span> + s + <span class="hljs-string">" found where "</span> + YES + <span class="hljs-string">" or "</span> + NO + <span class="hljs-string">" was expected."</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParameter</span><span class="hljs-params">(ParameterSetter setter, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
        <span class="hljs-keyword">boolean</span> b = ((Boolean) parameter).booleanValue();
        <span class="hljs-keyword">if</span> (b) {
            setter.setString(YES);
        } <span class="hljs-keyword">else</span> {
            setter.setString(NO);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">valueOf</span><span class="hljs-params">(String s)</span> </span>{
        <span class="hljs-keyword">if</span> (YES.equalsIgnoreCase(s)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">true</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (NO.equalsIgnoreCase(s)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">false</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"Unexpected value "</span> + s + <span class="hljs-string">" found where "</span> + YES + <span class="hljs-string">" or "</span> + NO + <span class="hljs-string">" was expected."</span>);
        }
    }
}
</code></pre>
<p>In order to declare these types for use in iBATIS you use the following syntax in your sqlMapConfig.xml:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;typeHandler <span class="hljs-attr">javaType</span>=<span class="hljs-string">"boolean"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span>
        <span class="hljs-attr">callback</span>=<span class="hljs-string">"org.apache.ibatis.sqlmap.extensions.YesNoBoolTypeHandlerCallback"</span> /&gt;</span><span class="undefined">
</span></code></pre>
<p>After this iBATIS will know to handle translations between the the stated java type and jdbc type with the particular type handler callback that was written.
Optionally, you can also specify a type handler for individual properties by specifying the type handler on the <code>&lt;result&gt;</code> mapping, or with an explicit or inline parameter map.</p>
<h2 id="jbatis-caching">jBATIS Caching<a class="headerlink" href="#_toc_jbatis-caching">←</a></h2>
<h3 id="jbatis-caching-architecture">jBATIS Caching Architecture<a class="headerlink" href="#_toc_jbatis-caching-architecture">←</a></h3>
<p>For interoperability, <code>CacheRoot</code> is leaded into jBATIS as roots of cache models. The diagram below illustrates the cache architecture.</p>
<p><img alt="Image" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4wLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLVNWRy0yMDAxMDkwNC9EVEQvc3ZnMTAuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNzMwIiBoZWlnaHQ9IjY0NiIgdGV4dC1yZW5kZXJpbmc9ImF1dG8iIHNoYXBlLXJlbmRlcmluZz0iYXV0byI+CjxkZWZzPjxjbGlwUGF0aCBpZD0iXzltM2kyMV8wIj48cGF0aCBkPSJNMCwwIEwxNTYsMCBMMTU2LDQ4IEwwLDQ4IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMV8xIj48cGF0aCBkPSJNMCwwIEwxODAsMCBMMTgwLDQ4IEwwLDQ4IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMV8yIj48cGF0aCBkPSJNMCwwIEwxNDQsMCBMMTQ0LDQ4IEwwLDQ4IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMV8zIj48cGF0aCBkPSJNMCwwIEw3MiwwIEw3Miw3MiBMMCw3MiBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjFfNCI+PHBhdGggZD0iTTAsMCBMMTMyLDAgTDEzMiwzNiBMMCwzNiBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjFfNSI+PHBhdGggZD0iTTAsMCBMMTA4LDAgTDEwOCwzNiBMMCwzNiBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjFfNiI+PHBhdGggZD0iTTAsMCBMMTMzLDAgTDEzMywxMzMgTDAsMTMzIEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMV83Ij48cGF0aCBkPSJNMCwwIEwxMzMsMCBMMTMzLDE0NSBMMCwxNDUgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIxXzgiPjxwYXRoIGQ9Ik0wLDAgTDEzMywwIEwxMzMsMTIxIEwwLDEyMSBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjFfOSI+PHBhdGggZD0iTTAsMCBMMjI5LDAgTDIyOSwxMzMgTDAsMTMzIEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMV8xMCI+PHBhdGggZD0iTTAsMCBMMTIxLDAgTDEyMSwxNDUgTDAsMTQ1IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMV8xMSI+PHBhdGggZD0iTTAsMCBMOTcsMCBMOTcsMTQ1IEwwLDE0NSBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjFfMTIiPjxwYXRoIGQ9Ik0wLDAgTDEyMSwwIEwxMjEsMjc3IEwwLDI3NyBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjFfMTMiPjxwYXRoIGQ9Ik0wLDAgTDE2OSwwIEwxNjksNDkgTDAsNDkgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPC9kZWZzPgo8ZyBzdHlsZT0iZm9udC1mYW1pbHk6TWljcm9zb2Z0IFlhSGVpO2ZvbnQtc2l6ZToxNHB4O3N0cm9rZS1saW5lY2FwOnNxdWFyZTtzdHJva2Utb3BhY2l0eToxO2ZpbGwtb3BhY2l0eToxOyI+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNTUiIGhlaWdodD0iNDciIHN0eWxlPSJmaWxsOiM4MGZmODA7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTAxLDI5MykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjE1NCIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTAxLDI5MykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIxNTUiIHkxPSIwIiB4Mj0iMTU1IiB5Mj0iNDYiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTAxLDI5MykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIxNTUiIHkxPSI0NyIgeDI9IjEiIHkyPSI0NyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMDEsMjkzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiLz4KPGxpbmUgeDE9IjAiIHkxPSI0NyIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEwMSwyOTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEwMSwyOTMpIj48dGV4dCB4PSIzNiIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiPsKrPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMDEsMjkzKSI+PHRleHQgeD0iNDMiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiPmNhY2hlIHJvb3Q8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEwMSwyOTMpIj48dGV4dCB4PSIxMTQiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj7CuzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTAxLDI5MykiPjx0ZXh0IHg9IjQ4IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj4mcXVvdDthX3RhYmxlJnF1b3Q7PC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE1NSIgaGVpZ2h0PSI0NyIgc3R5bGU9ImZpbGw6IzgwZmY4MDtmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksMjkzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTU0IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksMjkzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiLz4KPGxpbmUgeDE9IjE1NSIgeTE9IjAiIHgyPSIxNTUiIHkyPSI0NiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksMjkzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiLz4KPGxpbmUgeDE9IjE1NSIgeTE9IjQ3IiB4Mj0iMSIgeTI9IjQ3IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMyOSwyOTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8bGluZSB4MT0iMCIgeTE9IjQ3IiB4Mj0iMCIgeTI9IjEiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDI5MykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDI5MykiPjx0ZXh0IHg9IjM2IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSI+wqs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMyOSwyOTMpIj48dGV4dCB4PSI0MyIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSI+Y2FjaGUgcm9vdDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDI5MykiPjx0ZXh0IHg9IjExNCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiPsK7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksMjkzKSI+PHRleHQgeD0iNDgiIHk9IjM0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiPiZxdW90O2JfdGFibGUmcXVvdDs8L3RleHQ+PC9nPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTU1IiBoZWlnaHQ9IjQ3IiBzdHlsZT0iZmlsbDojODBmZjgwO2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU2OSwyOTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSIxNTQiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU2OSwyOTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8bGluZSB4MT0iMTU1IiB5MT0iMCIgeDI9IjE1NSIgeTI9IjQ2IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU2OSwyOTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8bGluZSB4MT0iMTU1IiB5MT0iNDciIHgyPSIxIiB5Mj0iNDciIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTY5LDI5MykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIwIiB5MT0iNDciIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1NjksMjkzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1NjksMjkzKSI+PHRleHQgeD0iMzYiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj7CqzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTY5LDI5MykiPjx0ZXh0IHg9IjQzIiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj5jYWNoZSByb290PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1NjksMjkzKSI+PHRleHQgeD0iMTE0IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSI+wrs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU2OSwyOTMpIj48dGV4dCB4PSI0OCIgeT0iMzQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSI+JnF1b3Q7Y190YWJsZSZxdW90OzwvdGV4dD48L2c+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNTUiIGhlaWdodD0iNDciIHN0eWxlPSJmaWxsOiM4MGMwZmY7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDYxLDQ0OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjE1NCIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDYxLDQ0OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIxNTUiIHkxPSIwIiB4Mj0iMTU1IiB5Mj0iNDYiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDYxLDQ0OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIxNTUiIHkxPSI0NyIgeDI9IjEiIHkyPSI0NyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0NjEsNDQ5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiLz4KPGxpbmUgeDE9IjAiIHkxPSI0NyIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQ2MSw0NDkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQ2MSw0NDkpIj48dGV4dCB4PSI1MiIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiPsKrPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0NjEsNDQ5KSI+PHRleHQgeD0iNTkiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiPmNhaGNlPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0NjEsNDQ5KSI+PHRleHQgeD0iOTciIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj7CuzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDYxLDQ0OSkiPjx0ZXh0IHg9IjMxIiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj5jYWNoZU1vZGVsIDE8L3RleHQ+PC9nPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTU1IiBoZWlnaHQ9IjQ3IiBzdHlsZT0iZmlsbDojODBjMGZmO2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE5Nyw0NDkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSIxNTQiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE5Nyw0NDkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8bGluZSB4MT0iMTU1IiB5MT0iMCIgeDI9IjE1NSIgeTI9IjQ2IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE5Nyw0NDkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSIvPgo8bGluZSB4MT0iMTU1IiB5MT0iNDciIHgyPSIxIiB5Mj0iNDciIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTk3LDQ0OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIi8+CjxsaW5lIHgxPSIwIiB5MT0iNDciIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxOTcsNDQ5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMCkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxOTcsNDQ5KSI+PHRleHQgeD0iNTIiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj7CqzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTk3LDQ0OSkiPjx0ZXh0IHg9IjU5IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzApIj5jYWhjZTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTk3LDQ0OSkiPjx0ZXh0IHg9Ijk3IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSI+wrs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE5Nyw0NDkpIj48dGV4dCB4PSIzMSIgeT0iMzQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8wKSI+Y2FjaGVNb2RlbCAxPC90ZXh0PjwvZz4KPGVsbGlwc2UgY3g9Ijg5IiBjeT0iMjMiIHJ4PSI4OSIgcnk9IjIzIiBzdHlsZT0iZmlsbDojZmZkNzAwO2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMxNyw1OTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xKSIvPgo8ZWxsaXBzZSBjeD0iODkiIGN5PSIyMyIgcng9Ijg5IiByeT0iMjMiIHN0eWxlPSJzdHJva2U6Izk5MDAzMztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMxNyw1OTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMxNyw1OTMpIj48dGV4dCB4PSIyNSIgeT0iMjkiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xKSI+TWFwcGVkIFN0YXRlbWVudDwvdGV4dD48L2c+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNDMiIGhlaWdodD0iNDciIHN0eWxlPSJmaWxsOiNjMGMwYzA7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDUpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8yKSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSIxNDIiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMyOSw1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMikiLz4KPGxpbmUgeDE9IjE0MyIgeTE9IjAiIHgyPSIxNDMiIHkyPSI0NiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzIpIi8+CjxsaW5lIHgxPSIxNDMiIHkxPSI0NyIgeDI9IjEiIHkyPSI0NyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzIpIi8+CjxsaW5lIHgxPSIwIiB5MT0iNDciIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzIpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDUpIj48dGV4dCB4PSIyOCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1zdHlsZTppdGFsaWM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8yKSI+Rmx1c2hMaXN0ZW5lcjwvdGV4dD48L2c+CjxsaW5lIHgxPSIwIiB5MT0iMjAiIHgyPSIxNDMiIHkyPSIyMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzIpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDUpIj48dGV4dCB4PSI3IiB5PSIzNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzIpIj4rb25GbHVzaChpZDogU3RyaW5nLCB0aW1lc3RhbXA6IGxvbmcpOiB2b2lkPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDQ2MSkiPjx0ZXh0IHg9IjE4IiB5PSI2NSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzMpIj5BY3RvcjwvdGV4dD48L2c+CjxlbGxpcHNlIGN4PSIzNi41IiBjeT0iOS41IiByeD0iOS41IiByeT0iOS41IiBzdHlsZT0iZmlsbDojMDBmZmZmO2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDYxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMykiLz4KPGVsbGlwc2UgY3g9IjM2LjUiIGN5PSI5LjUiIHJ4PSI5LjUiIHJ5PSI5LjUiIHN0eWxlPSJzdHJva2U6Izk5MDAzMztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDYxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMykiLz4KPGxpbmUgeDE9IjM2IiB5MT0iMTkiIHgyPSIzNiIgeTI9IjMwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDYxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMykiLz4KPGxpbmUgeDE9IjIyIiB5MT0iMjQiIHgyPSI1MCIgeTI9IjI0IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDYxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMykiLz4KPGxpbmUgeDE9IjM2IiB5MT0iMzAiIHgyPSIyNCIgeTI9IjQ4IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDYxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMykiLz4KPGxpbmUgeDE9IjM2IiB5MT0iMzAiIHgyPSI0OCIgeTI9IjQ4IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDYxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMykiLz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEzMSIgaGVpZ2h0PSIzNSIgc3R5bGU9ImZpbGw6I2QyYjQ4YztmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MzcsMTczKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTMwIiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MzcsMTczKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNCkiLz4KPGxpbmUgeDE9IjEzMSIgeTE9IjAiIHgyPSIxMzEiIHkyPSIzNCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MzcsMTczKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNCkiLz4KPGxpbmUgeDE9IjEzMSIgeTE9IjM1IiB4Mj0iMSIgeTI9IjM1IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQzNywxNzMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV80KSIvPgo8bGluZSB4MT0iMCIgeTE9IjM1IiB4Mj0iMCIgeTI9IjEiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDM3LDE3MykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzQpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDM3LDE3MykiPjx0ZXh0IHg9IjI0IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzQpIj5DYWNoZU1vZGVsPC90ZXh0PjwvZz4KPGxpbmUgeDE9IjAiIHkxPSIyMCIgeDI9IjEzMSIgeTI9IjIwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQzNywxNzMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV80KSIvPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTA3IiBoZWlnaHQ9IjM1IiBzdHlsZT0iZmlsbDojZmZlNGM0O2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDIyMSwxNzMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV81KSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSIxMDYiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDIyMSwxNzMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV81KSIvPgo8bGluZSB4MT0iMTA3IiB5MT0iMCIgeDI9IjEwNyIgeTI9IjM0IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDIyMSwxNzMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV81KSIvPgo8bGluZSB4MT0iMTA3IiB5MT0iMzUiIHgyPSIxIiB5Mj0iMzUiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjIxLDE3MykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzUpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMzUiIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyMjEsMTczKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNSkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyMjEsMTczKSI+PHRleHQgeD0iMTgiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNSkiPkNhY2hlUm9vdDwvdGV4dD48L2c+CjxsaW5lIHgxPSIwIiB5MT0iMjAiIHgyPSIxMDciIHkyPSIyMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyMjEsMTczKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNSkiLz4KPGxpbmUgeDE9IjEyIiB5MT0iMTIiIHgyPSI2NiIgeTI9IjY2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNjEsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNikiLz4KPGxpbmUgeDE9IjY2IiB5MT0iNjYiIHgyPSIxMjAiIHkyPSIxMjAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV82KSIvPgo8bGluZSB4MT0iMTMiIHkxPSIxMyIgeDI9IjI2IiB5Mj0iMTciIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV82KSIvPgo8bGluZSB4MT0iMTMiIHkxPSIxMyIgeDI9IjE3IiB5Mj0iMjYiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV82KSIvPgo8ZyBzdHlsZT0iZmlsbDp3aGl0ZTs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNjEsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNikiPjxwYXRoIGQ9Ik0xMywxMyBMMjYsMTcgTDE3LDI2IFoiLz48L2c+CjxnIHN0eWxlPSJzdHJva2U6YmxhY2s7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNjEsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNikiPjxwYXRoIGQ9Ik0xMywxMyBMMjYsMTcgTDE3LDI2IFoiLz48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iNjYiIHkyPSI2NiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDEzLDMyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzYpIi8+CjxsaW5lIHgxPSI2NiIgeTE9IjY2IiB4Mj0iMTIwIiB5Mj0iMTIwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MTMsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNikiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIyNiIgeTI9IjE3IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MTMsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNikiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIxNyIgeTI9IjI2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MTMsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNikiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDEzLDMyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzYpIj48cGF0aCBkPSJNMTMsMTMgTDI2LDE3IEwxNywyNiBaIi8+PC9nPgo8ZyBzdHlsZT0ic3Ryb2tlOmJsYWNrO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDEzLDMyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzYpIj48cGF0aCBkPSJNMTMsMTMgTDI2LDE3IEwxNywyNiBaIi8+PC9nPgo8bGluZSB4MT0iMTIwIiB5MT0iMTIiIHgyPSI2NiIgeTI9IjcyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWRhc2hhcnJheTo4LDU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5LDMyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzcpIi8+CjxsaW5lIHgxPSI2NiIgeTE9IjcyIiB4Mj0iMTIiIHkyPSIxMzIiIHN0eWxlPSJzdHJva2U6YmxhY2s7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtZGFzaGFycmF5OjgsNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjksMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNykiLz4KPGxpbmUgeDE9IjExOSIgeTE9IjEzIiB4Mj0iMTE2IiB5Mj0iMjYiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5LDMyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzcpIi8+CjxsaW5lIHgxPSIxMTkiIHkxPSIxMyIgeDI9IjEwNiIgeTI9IjE4IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV83KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI5LDMyOSkiPjx0ZXh0IHg9IjQzIiB5PSI3NCIgc3R5bGU9ImZpbGw6YmxhY2s7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNykiPsKrPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOSwzMjkpIj48dGV4dCB4PSI1MCIgeT0iNzQiIHN0eWxlPSJmaWxsOmJsYWNrOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNykiPmZsdXNoPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyOSwzMjkpIj48dGV4dCB4PSI4MiIgeT0iNzQiIHN0eWxlPSJmaWxsOmJsYWNrO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzcpIj7CuzwvdGV4dD48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iNjYiIHkyPSI2MCIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNjksNDg1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfOCkiLz4KPGxpbmUgeDE9IjY2IiB5MT0iNjAiIHgyPSIxMjAiIHkyPSIxMDgiIHN0eWxlPSJzdHJva2U6YmxhY2s7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtZGFzaGFycmF5OjgsNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjY5LDQ4NSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzgpIi8+CjxsaW5lIHgxPSIxMyIgeTE9IjEzIiB4Mj0iMjYiIHkyPSIxNiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjY5LDQ4NSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzgpIi8+CjxsaW5lIHgxPSIxMyIgeTE9IjEzIiB4Mj0iMTgiIHkyPSIyNSIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjY5LDQ4NSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzgpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjY5LDQ4NSkiPjx0ZXh0IHg9IjQzIiB5PSI2MSIgc3R5bGU9ImZpbGw6YmxhY2s7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfOCkiPsKrPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNjksNDg1KSI+PHRleHQgeD0iNTAiIHk9IjYxIiBzdHlsZT0iZmlsbDpibGFjazsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzgpIj5mbHVzaDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjY5LDQ4NSkiPjx0ZXh0IHg9IjgyIiB5PSI2MSIgc3R5bGU9ImZpbGw6YmxhY2s7Zm9udC1mYW1pbHk6bW9ub3NwYWNlOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfOCkiPsK7PC90ZXh0PjwvZz4KPGxpbmUgeDE9IjEyIiB5MT0iMTIiIHgyPSIxMTQiIHkyPSI2NiIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNDUsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfOSkiLz4KPGxpbmUgeDE9IjExNCIgeTE9IjY2IiB4Mj0iMjE2IiB5Mj0iMTIwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWRhc2hhcnJheTo4LDU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI0NSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV85KSIvPgo8bGluZSB4MT0iMTQiIHkxPSIxMyIgeDI9IjI3IiB5Mj0iMTMiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI0NSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV85KSIvPgo8bGluZSB4MT0iMTQiIHkxPSIxMyIgeDI9IjIyIiB5Mj0iMjQiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI0NSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV85KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI0NSwzMjkpIj48dGV4dCB4PSI4MSIgeT0iNjYiIHN0eWxlPSJmaWxsOmJsYWNrO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzkpIj7CqzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjQ1LDMyOSkiPjx0ZXh0IHg9Ijg4IiB5PSI2NiIgc3R5bGU9ImZpbGw6YmxhY2s7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV85KSI+b25GbHVzaDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjQ1LDMyOSkiPjx0ZXh0IHg9IjE0MCIgeT0iNjYiIHN0eWxlPSJmaWxsOmJsYWNrO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzkpIj7CuzwvdGV4dD48L2c+CjxsaW5lIHgxPSIxMjAiIHkxPSIxMiIgeDI9IjY2IiB5Mj0iNjYiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV82KSIvPgo8bGluZSB4MT0iNjYiIHkxPSI2NiIgeDI9IjEyIiB5Mj0iMTIwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfNikiLz4KPGxpbmUgeDE9IjExOSIgeTE9IjEzIiB4Mj0iMTE1IiB5Mj0iMjYiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV82KSIvPgo8bGluZSB4MT0iMTE5IiB5MT0iMTMiIHgyPSIxMDYiIHkyPSIxNyIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDMyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzYpIi8+CjxnIHN0eWxlPSJmaWxsOndoaXRlOzsgc3Ryb2tlOiBub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV82KSI+PHBhdGggZD0iTTExOSwxMyBMMTE1LDI2IEwxMDYsMTcgWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV82KSI+PHBhdGggZD0iTTExOSwxMyBMMTE1LDI2IEwxMDYsMTcgWiIvPjwvZz4KPGxpbmUgeDE9IjEwOCIgeTE9IjEyIiB4Mj0iNjAiIHkyPSI3MiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjU3LDQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMTApIi8+CjxsaW5lIHgxPSI2MCIgeTE9IjcyIiB4Mj0iMTIiIHkyPSIxMzIiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1Nyw0MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEwKSIvPgo8bGluZSB4MT0iMTA3IiB5MT0iMTMiIHgyPSIxMDUiIHkyPSIyNiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjU3LDQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMTApIi8+CjxsaW5lIHgxPSIxMDciIHkxPSIxMyIgeDI9Ijk1IiB5Mj0iMTgiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1Nyw0MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEwKSIvPgo8ZyBzdHlsZT0iZmlsbDp3aGl0ZTs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNTcsNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMCkiPjxwYXRoIGQ9Ik0xMDcsMTMgTDEwNSwyNiBMOTUsMTggWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI1Nyw0MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEwKSI+PHBhdGggZD0iTTEwNywxMyBMMTA1LDI2IEw5NSwxOCBaIi8+PC9nPgo8bGluZSB4MT0iMTIiIHkxPSIxMiIgeDI9IjQ4IiB5Mj0iNzIiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQxMyw0MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzExKSIvPgo8bGluZSB4MT0iNDgiIHkxPSI3MiIgeDI9Ijg0IiB5Mj0iMTMyIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MTMsNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMSkiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIyNCIgeTI9IjIwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MTMsNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMSkiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIxNCIgeTI9IjI2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MTMsNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMSkiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDEzLDQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMTEpIj48cGF0aCBkPSJNMTMsMTMgTDI0LDIwIEwxNCwyNiBaIi8+PC9nPgo8ZyBzdHlsZT0ic3Ryb2tlOmJsYWNrO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDEzLDQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMTEpIj48cGF0aCBkPSJNMTMsMTMgTDI0LDIwIEwxNCwyNiBaIi8+PC9nPgo8bGluZSB4MT0iNjAiIHkxPSIxMiIgeDI9IjYwIiB5Mj0iMTM4IiBzdHlsZT0ic3Ryb2tlOmJsYWNrO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWRhc2hhcnJheTo4LDU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMikiLz4KPGxpbmUgeDE9IjYwIiB5MT0iMTM4IiB4Mj0iNjAiIHkyPSIyNjQiIHN0eWxlPSJzdHJva2U6YmxhY2s7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtZGFzaGFycmF5OjgsNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzQxLDMyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEyKSIvPgo8bGluZSB4MT0iNjAiIHkxPSIxNCIgeDI9IjY2IiB5Mj0iMjYiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwzMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMikiLz4KPGxpbmUgeDE9IjYwIiB5MT0iMTQiIHgyPSI1NCIgeTI9IjI2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzNDEsMzI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMTIpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzQxLDMyOSkiPjx0ZXh0IHg9IjM3IiB5PSIxNDIiIHN0eWxlPSJmaWxsOmJsYWNrO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEyKSI+wqs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwzMjkpIj48dGV4dCB4PSI0NCIgeT0iMTQyIiBzdHlsZT0iZmlsbDpibGFjazsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEyKSI+Zmx1c2g8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwzMjkpIj48dGV4dCB4PSI3NiIgeT0iMTQyIiBzdHlsZT0iZmlsbDpibGFjaztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMikiPsK7PC90ZXh0PjwvZz4KPGxpbmUgeDE9IjE1NiIgeTE9IjM2IiB4Mj0iODQiIHkyPSIzNiIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MSw0MzcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMykiLz4KPGxpbmUgeDE9Ijg0IiB5MT0iMzYiIHgyPSIxMiIgeTI9IjM2IiBzdHlsZT0ic3Ryb2tlOmJsYWNrO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWRhc2hhcnJheTo4LDU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQxLDQzNykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEzKSIvPgo8bGluZSB4MT0iMTU1IiB5MT0iMzYiIHgyPSIxNDMiIHkyPSI0MiIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNDEsNDM3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjFfMTMpIi8+CjxsaW5lIHgxPSIxNTUiIHkxPSIzNiIgeDI9IjE0MyIgeTI9IjMwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MSw0MzcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMykiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MSw0MzcpIj48dGV4dCB4PSI2MSIgeT0iMzMiIHN0eWxlPSJmaWxsOmJsYWNrO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIxXzEzKSI+wqs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQxLDQzNykiPjx0ZXh0IHg9IjY4IiB5PSIzMyIgc3R5bGU9ImZpbGw6YmxhY2s7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMykiPmZsdXNoPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0MSw0MzcpIj48dGV4dCB4PSIxMDAiIHk9IjMzIiBzdHlsZT0iZmlsbDpibGFjaztmb250LWZhbWlseTptb25vc3BhY2U7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMV8xMykiPsK7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLDApIj48dGV4dCB4PSIyIiB5PSI2NDQiIHN0eWxlPSJmaWxsOiNjMGMwYzA7Zm9udC1mYW1pbHk6SW1wYWN0O2ZvbnQtc2l6ZToxMXB4OyIgPihjKWpiYXRpcy5vcmc8L3RleHQ+PC9nPjwvZz48L3N2Zz4K"></p>
<p>Your data is stored in <code>CacheModel</code>; <code>CacheRoot</code> tags <code>CacheModel</code>; <code>CacheRoot</code> is identified by simple string id.
One can operate the cache objects via lots of ways:</p>
<ul>
  <li>User can execute mapped statements to store data into <code>CacheModel</code>, and also can flush <code>CacheModel</code> and <code>CacheRoot</code> one bye one, even all <code>CacheModel</code>s.</li>
  <li>Mapped statement can flush <code>CacheModel</code> and/or <code>CacheRoot</code> by declaration in XML.</li>
  <li>a <code>CacheRoot</code> can even add another <code>CacheRoot</code> as its <code>FlushListener</code>, Recursivly fush would never occurred because of timestamp judgement.</li>
</ul>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>You need use <code>sql-map-2.4.dtd</code> for SQL Map XML to use <code>CacheRoot</code> functionality.</p>
</blockquote>
<p>The results from a Query Mapped Statement can be cached simply by specifying the <code>cacheModel</code> parameter in the statement tag (seen above).
A cache model is a configured cache that is defined within your SQL map.
Cache models are configured using the <code>cacheModel</code> element as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"product-cache"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"LRU"</span> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">serialize</span>=<span class="hljs-string">"false"</span> &gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;cacheRoot <span class="hljs-attr">name</span>=<span class="hljs-string">"my_table"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"insertProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"updateProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"deleteProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"cache-size"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;update <span class="hljs-attr">id</span>=<span class="hljs-string">"updateTest"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">UPDATE</span>
            test_tbl
        <span class="hljs-keyword">SET</span>
            state = <span class="hljs-number">1</span>
        <span class="hljs-keyword">WHERE</span>
            id = <span class="hljs-number">9</span>
        </span><span class="hljs-symbol">&lt;flushCacheRoot <span class="hljs-attr">name</span>=<span class="hljs-string">"my_table"</span>/&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushCache <span class="hljs-attr">cacheModel</span>=<span class="hljs-string">"someCache"</span>/&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/update&gt;</span><span class="undefined">
</span></code></pre>
<p>The cache model above will create an instance of a cache named "product-cache" that uses a Least Recently Used (LRU) implementation.
The value of the type attribute is either a fully qualified class name, or an alias for one of the included implementations (see below).
Based on the flush elements specified within the cache model, this cache will be flushed every 24 hours.
There can be only one flush interval element and it can be set using hours, minutes, seconds or milliseconds.
In addition the cache will be completely flushed whenever the insertProduct, updateProduct, or deleteProduct mapped statements are executed.</p>
<p>There can be any number of "flush on execute" elements specified for a cache.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>The id of <code>cacheModel</code> is always namesapce aware. One must use its namespace such as <code>myNamespace.myCacheModel</code> to refer a cacheModel in different namespace.
  Only if in same namespace, the namespace prefix can be omitted.</p>
</blockquote>
<p>Some cache implementations may need additional properties, such as the 'cache-size' property demonstrated above.
In the case of the LRU cache, the size determines the number of entries to store in the cache.
Once a cache model is configured, you can specify the cache model to be used by a mapped statement, for example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProductList"</span> <span class="hljs-attr">cacheModel</span>=<span class="hljs-string">"product-cache"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">WHERE</span>
            PRD_CAT_ID = #value#
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="read-only-vs-readwrite"><del>Read-Only vs. Read/Write</del><a class="headerlink" href="#_toc_read-only-vs-readwrite">←</a></h3>
<p>The framework supports both read-only and read/write caches. Read-only caches are shared among all users and therefore offer greater performance benefit.
However, objects read from a read-only cache should not be modified. Instead, a new object should be read from the database (or a read/write cache) for updating.
On the other hand, if there is an intention to use objects for retrieval and modification, a read/write cache is recommended (i.e. required).
To use a read-only cache, set readOnly="true" on the cache model element. To use a read/write cache, set readOnly="false".</p>
<p>The default is read-only (true).</p>
<h3 id="serializable-readwrite-caches"><del>Serializable Read/Write Caches</del><a class="headerlink" href="#_toc_serializable-readwrite-caches">←</a></h3>
<p>As you may agree, caching per-session as described above may offer little benefit to global application performance.
Another type of read/write cache that can offer a performance benefit to the entire application
(i.e. not just per session) is a serializable read/write cache.
This cache will return different instances (copies) of the cached object to each session.
Therefore each session can safely modify the instance returned.
Realize the difference in semantics here, usually you would expect the same instance to be returned from a cache, but in this case you'll get a different one.
Also note that every object stored by a serializable cache must be serializable.</p>
<p>This means that you will have difficulty using both lazy loading features combined with a serializable cache, because lazy proxies are not serializable.
The best way to figure out what combination of caching, lazy loading and table joining is simply to try it out. To use a serializable cache,
set readOnly="false" and serialize="true". By default cache models are read-only and non-serializable. Read-only caches will not be serialized (there's no benefit).</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>In jBATIS, No <code>readOnly</code> or <code>serialize</code> attribute for <code>&lt;cacheModel&gt;</code> element. And to achieve greater performance benefit, All <code>cacheModel</code> are shared among all users.
  If one modify the result from cache, the data in cache is also changed.
  If want to make your cache data serializable, you only need make your data bean implements <code>java.io.Serializable</code>. The <code>CacheKey</code> in jBATIS has implemented <code>java.io.Serializable</code>.</p>
</blockquote>
<h3 id="cache-types">Cache Types<a class="headerlink" href="#_toc_cache-types">←</a></h3>
<p>The cache model uses a pluggable framework for supporting different types of caches. The implementation is specified in the type attribute of the cacheModel element
(as discussed above). The class name specified must be an implementation of the CacheController interface, or one of the four aliases discussed below.
Further configuration parameters can be passed to the implementation via the property elements contained within the body of the cacheModel.
Currently there are 4 implementations included with the distribution.</p>
<p>These are as follows:</p>
<h4 id="memory"><code>MEMORY</code><a class="headerlink" href="#_toc_memory">←</a></h4>
<p>The MEMORY cache implementation uses reference types to manage the cache behavior.
That is, the garbage collector effectively determines what stays in the cache or otherwise.
The MEMORY cache is a good choice for applications that don't have an identifiable pattern of object reuse,
or applications where memory is scarce (it will do what it can).
The MEMORY implementation is configured as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"product-cache"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"MEMORY"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"insertProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"updateProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"deleteProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"reference-type"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"WEAK"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
</span></code></pre>
<p>Only a single property is recognized by the MEMORY cache implementation. This property, named <code>reference-type</code> must be set to a value
of STRONG, SOFT or WEAK. These values correspond to various memory reference types available in the JVM.</p>
<p>The following table describes the different reference types that can be used for a MEMORY cache.</p>
<table border="1">
  <thead></thead>
  <tbody>
    <tr><td>WEAK</td><td>This reference type is probably the best choice in most cases and is the default if the reference-type is not specified.</td></tr>
    <tr><td>SOFT</td><td>This reference type will reduce the likelihood of running out of memory in case the results are not currently in use and the memory is needed for other objects.</td></tr>
    <tr><td>STRONG(default)</td><td>This reference type will guarantee that the results stay in memory until the cache is explicitly flushed (e.g. by time interval or flush on execute).</td></tr>
  </tbody>
</table>
<p>To better understand the topic of reference types, please see the JDK documentation for <code>java.lang.ref</code> for more information about "reachability".</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>In jBATIS, <code>MEMORY</code> cache has improved dramatically as following:</p>
  <ul>
    <li>It use <code>LRU</code> algorithm by default,</li>
    <li>To avoid OutOfMemoryError, its max entries has size limit default as 512, and property <code>memory.cache.size</code> is used to specify the size.</li>
    <li>It can notify flush event each other with JGroups library by set <code>memory.mcast.enable=true</code> in jBATIS global properties.
    User can optionally specify the ether <code>memory.mcast.properties</code> or <code>memory.mcast.addr</code> and <code>memory.mcast.port</code> property for isolation of notification.</li>
  </ul>
</blockquote>
<h4 id="lru"><code>LRU</code><a class="headerlink" href="#_toc_lru">←</a></h4>
<p>The LRU cache implementation uses an Least Recently Used algorithm to determines how objects are automatically removed from the cache. When the cache becomes over full,
the object that was accessed least recently will be removed from the cache.
This way, if there is a particular object that is often referred to, it will stay in the cache with the least chance of being removed.
The LRU cache makes a good choice for applications that have patterns of usage where certain objects may be popular to one or more users over a longer period of time
(e.g. navigating back and forth between paginated lists, popular search keys etc.).</p>
<p>The LRU implementation is configured as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"product-cache"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"LRU"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"insertProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"updateProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"deleteProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"size"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
</span></code></pre>
<p>Only a single property is recognized by the LRU cache implementation.
This property, named 'size' must be set to an integer value representing the maximum number of objects to hold in the cache at once.</p>
<p>An important thing to remember here is that an object can be anything from a single String instance to an ArrayList of JavaBeans.
So take care not to store too much in your cache and risk running out of memory!</p>
<h4 id="fifo"><code>FIFO</code><a class="headerlink" href="#_toc_fifo">←</a></h4>
<p>The FIFO cache implementation uses an First In First Out algorithm to determines how objects are automatically removed from the cache. When the cache becomes over full,
the oldest object will be removed from the cache. The FIFO cache is good for usage patterns where a particular query will be referenced a few times in quick succession,
but then possibly not for some time later.</p>
<p>The FIFO implementation is configured as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"product-cache"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"FIFO"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"insertProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"updateProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"deleteProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"size"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
</span></code></pre>
<p>Only a single property is recognized by the FIFO cache implementation. This property, named 'size' must be set to an integer value representing the maximum number of
objects to hold in the cache at once. An important thing to remember here is that an object can be anything from a single String instance to an
ArrayList of JavaBeans. So take care not to store too much in your cache and risk running out of memory!</p>
<h4 id="oscache"><code>OSCACHE</code><a class="headerlink" href="#_toc_oscache">←</a></h4>
<p>The OSCACHE cache implementation is a plugin for the OSCache 2.4 caching engine. It is highly configurable, distributable and flexible.
The OSCACHE implementation is configured as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"product-cache"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"OSCACHE"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"insertProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"updateProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"deleteProduct"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
</span></code></pre>
<p>The OSCACHE implementation does not use any property elements for configuration.
Instead, the OSCache instance is configured using the standard oscache.properties file which should be located in the root of your classpath.</p>
<pre><code class="language-prop hljs properties">cache.event.listeners=<span class="hljs-string">org.ibatis.jgroups.oscache.JavaGroupsBroadcastingListener
</span>cache.algorithm=<span class="hljs-string">com.opensymphony.oscache.base.algorithm.LRUCache
</span>cache.capacity=<span class="hljs-string">1000
</span>cache.cluster.properties=<span class="hljs-string">UDP(mcast_addr=231.22.22.132;mcast_port=45654;):\
PING:\
MERGE2:\
FD_SOCK:\
VERIFY_SUSPECT:\
pbcast.NAKACK:\
UNICAST:\
pbcast.STABLE:\
FRAG:\
pbcast.GMS
</span>cache.cluster.multicast.ip=<span class="hljs-string">231.22.22.132
</span></code></pre>
<p>Within that file you can configure algorithms (much like those discussed above), cache size, persistence approach (memory, file, ...), and clustering.</p>
<p>Please refer to the OSCache documentation for more information.
OSCache and its documentation can be found at the following Open Symphony website: <a href="http://www.opensymphony.com/oscache/">http://www.opensymphony.com/oscache/</a></p>
<h4 id="ehcache"><code>EHCACHE</code><a class="headerlink" href="#_toc_ehcache">←</a></h4>
<p>The EHCACHE cache implementation is a plugin for the Ehcache 2.6 caching engine. It is highly configurable, distributable and flexible.
The EHCACHE implementation is configured as follows:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;cacheModel <span class="hljs-attr">id</span>=<span class="hljs-string">"product-cache"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"EHCACHE"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushInterval <span class="hljs-attr">hours</span>=<span class="hljs-string">"24"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"insertProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"updateProduct"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;flushOnExecute <span class="hljs-attr">statement</span>=<span class="hljs-string">"deleteProduct"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/cacheModel&gt;</span><span class="undefined">
</span></code></pre>
<p>The EHCACHE implementation does not use any property elements for configuration.
Instead, the Ehcache instance is configured using the standard ehcache.xml file which should be located in the root of your classpath.</p>
<pre><code class="language-xsql hljs"><span class="hljs-symbol">&lt;ehcache <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">"ehcache.xsd"</span>&gt;</span><span class="undefined">

    </span><span class="hljs-symbol">&lt;cacheManagerPeerProviderFactory <span class="hljs-attr">class</span>=<span class="hljs-string">"org.ibatis.jgroups.ehcache.JGroupsCacheManagerPeerProviderFactory"</span>
        <span class="hljs-attr">properties</span>=<span class="hljs-string">"connect=UDP(mcast_addr=231.12.21.132;mcast_port=45654;):
            PING:
            MERGE2:
            FD_SOCK:
            VERIFY_SUSPECT:
            pbcast.NAKACK:
            UNICAST:
            pbcast.STABLE:
            FRAG:
            pbcast.GMS"</span>
        <span class="hljs-attr">propertySeparator</span>=<span class="hljs-string">"::"</span> /&gt;</span><span class="undefined">

    </span><span class="hljs-symbol">&lt;defaultCache <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span>
        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"720"</span> <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"120"</span> <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"false"</span>
        <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">"LRU"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;cacheEventListenerFactory <span class="hljs-attr">class</span>=<span class="hljs-string">"org.ibatis.jgroups.ehcache.JGroupsCacheReplicatorFactory"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/defaultCache&gt;</span><span class="undefined">
</span><span class="hljs-symbol">&lt;/ehcache&gt;</span><span class="undefined">
</span></code></pre>
<p>Please refer to the Ehcache documentation for more information.
Ehcache and its documentation can be found at its website: <a href="http://www.ehcache.org/">http://www.ehcache.org/</a></p>
<h3 id="cache-flush">Cache Flush<a class="headerlink" href="#_toc_cache-flush">←</a></h3>
<p>In iBATIS SQL Map XML, if you want flush a cache model after execute mapped statement, you can and only can specify a <code>&lt;flushOnExecute ...&gt;</code> element in a <code>&lt;cacheModel&gt;</code> element.
But in jBATIS and use <code>sql-map-2.4.dtd</code>, you can also specify a <code>&lt;flushCache&gt;</code> or <code>&lt;flushRoot&gt;</code> element in your mapped statements to flush cache models and roots.
You evan can monitor cache model flush at runtime via <code>ibatis.ini</code> and <code>run_stats_file</code>.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>When using batch, <strong>iBATIS would flush your cache model many times before the batch execution.</strong> This could cause performance loss. jBATIS would flush the cache models only once after your batch execution.</li>
    <li>Both iBATIS and jBATIS wolud flush cache models even the batch executed with exeception.</li>
  </ul>
</blockquote>
<p><a id="monitor_cache_flush_link"></a></p><a id="monitor_cache_flush_link">
</a><h4 id="monitor-cache-flush"><a id="monitor_cache_flush_link">Monitor Cache Flush<a class="headerlink" href="#_toc_monitor-cache-flush">←</a></h4>
<p>To find out what program code flush a cache model, you should write you <code>ibatis.ini</code> in classpath before program startup as following:</p>
<pre><code class="language-prop hljs properties">...
run_stats_file=<span class="hljs-string">/path/file
</span></code></pre>
<p>Thus <code>/path/file</code> would be loaded as <code>Properties</code> when it is touched while program running. To setup flush monitor for <code>myCacheModle</code>,
you should write <code>/path/file</code> as following:</p>
<pre><code class="language-prop hljs properties">cache_flush_monitor =<span class="hljs-string"> true
</span>myNamespace.myCacheModle.onFlush =<span class="hljs-string"> error
</span></code></pre>
<p>Then if <code>myCacheModle</code> is flushed (Note <code>myNamespace.myCacheModle</code> is its full id), a log with stack trace will be output. if <code>myNamespace.myCacheModle.onFlush = info</code>, a log without stack trace will be output.</p>
<p>If want to remove the monitor, write <code>/path/file</code> as following:</p>
<pre><code class="language-prop hljs properties">cache_flush_monitor =<span class="hljs-string"> true
</span>myNamespace.myCacheModle.onFlush =<span class="hljs-string">
</span></code></pre>
<h2 id="dynamic-mapped-statements">Dynamic Mapped Statements<a class="headerlink" href="#_toc_dynamic-mapped-statements">←</a></h2>
<p>A very common problem with working directly with JDBC is dynamic SQL. It is normally very difficult to work with SQL statements that change not only the values of
parameters, but which parameters and columns are included at all. The typical solution is usually a mess of conditional if-else statements and horrid string concatenations.
The desired result is often a query by example, where a query can be built to find objects that are similar to the example object.
The SQL Map API provides a relatively elegant solution that can be applied to any mapped statement element. Here is a simple example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"dynamicGetAccountList"</span> <span class="hljs-attr">cacheModel</span>=<span class="hljs-string">"account-cache"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"account-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            ACCOUNT
        </span><span class="hljs-symbol">&lt;isGreaterThan <span class="hljs-attr">prepend</span>=<span class="hljs-string">"and"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">compareValue</span>=<span class="hljs-string">"0"</span>&gt;</span><span class="sql">
            <span class="hljs-keyword">WHERE</span>
            ACC_ID = #id#
        </span><span class="hljs-symbol">&lt;/isGreaterThan&gt;</span><span class="sql">
        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
            ACC_LAST_NAME
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above example, there are two possible statements that could be created depending on the state of the "id" property of the parameter bean.
If the id parameter is greater than 0, then the statement will be created as follows:</p>
<pre><code class="language-sql hljs">    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> ACCOUNT <span class="hljs-keyword">where</span> ACC_ID = ?
</code></pre>
<p>Or if the id parameter is 0 or less, the statement will look as follows.</p>
<pre><code class="language-sql hljs">    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> ACCOUNT
</code></pre>
<p>The immediate usefulness of this might not become apparent until a more complex situation is encountered. For example, the following is a somewhat more complex example.</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"dynamicGetAccountList"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"account-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            ACCOUNT
        </span><span class="hljs-symbol">&lt;dynamic <span class="hljs-attr">prepend</span>=<span class="hljs-string">"WHERE"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;isNotNull <span class="hljs-attr">prepend</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"firstName"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span>&gt;</span><span class="undefined">
                ACC_FIRST_NAME = #firstName#
                </span><span class="hljs-symbol">&lt;isNotNull <span class="hljs-attr">prepend</span>=<span class="hljs-string">"OR"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"lastName"</span>&gt;</span><span class="undefined">
                    ACC_LAST_NAME  = #lastName#
                </span><span class="hljs-symbol">&lt;/isNotNull&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;/isNotNull&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;isNotNull <span class="hljs-attr">prepend</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"emailAddress"</span>&gt;</span><span class="sql">
                ACC_EMAIL      <span class="hljs-keyword">LIKE</span> #emailAddress#
            </span><span class="hljs-symbol">&lt;/isNotNull&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;isGreaterThan <span class="hljs-attr">prepend</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">compareValue</span>=<span class="hljs-string">"0"</span>&gt;</span><span class="undefined">
                ACC_ID         =    #id#
            </span><span class="hljs-symbol">&lt;/isGreaterThan&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/dynamic&gt;</span><span class="sql">
        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
            ACC_LAST_NAME
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>Depending on the situation, there could be as many as 16 different SQL queries generated from the above dynamic statement.
To code the if-else structures and string concatenations could get quite messy and require hundreds of lines of code.</p>
<p>Using dynamic statements is as simple as inserting some conditional tags around the dynamic parts of your SQL. For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"someName"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"account-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            ACCOUNT
        </span><span class="hljs-symbol">&lt;dynamic <span class="hljs-attr">prepend</span>=<span class="hljs-string">"where"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;isGreaterThan <span class="hljs-attr">prepend</span>=<span class="hljs-string">"and"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">compareValue</span>=<span class="hljs-string">"0"</span>&gt;</span><span class="undefined">
                ACC_ID = #id#
            </span><span class="hljs-symbol">&lt;/isGreaterThan&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;isNotNull <span class="hljs-attr">prepend</span>=<span class="hljs-string">"and"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"lastName"</span>&gt;</span><span class="undefined">
                ACC_LAST_NAME = #lastName#
            </span><span class="hljs-symbol">&lt;/isNotNull&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/dynamic&gt;</span><span class="sql">
        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
            ACC_LAST_NAME
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above statement, the <code>&lt;dynamic&gt;</code> (also <code>&lt;dyn&gt;</code> when use <code>sql-map-2.4.dtd</code>) element demarcates a section of the SQL that is dynamic.
The dynamic element is optional and provides a way to manage a prepend in cases where the prepend (e.g. "WHERE")
should not be included unless the contained conditions append to the statement.
The statement section can contain any number of conditional elements (see below) that will determine whether a the contained SQL code will be included in the statement.
All of the conditional elements work based on the state of the parameter object passed into the query.</p>
<p>Both the dynamic element and the conditional elements have a "prepend" attribute.
The prepend attribute is a part of the code that is free to be overridden by the a parent element's prepend if necessary.</p>
<p>In the above example the "where" prepend will override  the first true conditional prepend.
This is necessary to ensure that the SQL statement is built properly.
For example, in the case of the first true condition, there is no need for the AND, and in fact it would break the statement.
The following sections describe the various kinds of elements, including Binary Conditionals, Unary Conditionals and Iterate.</p>
<h3 id="dynamic-element">Dynamic Element<a class="headerlink" href="#_toc_dynamic-element">←</a></h3>
<p>The <code>dynamic</code> tag is a simple tag that is meant only to wrap other dynamic sql elements and provide for a way to attach an overall prepend,
open or close to the resulting body content. When using this tag the <code>removeFirstPrepend</code> attribute functionality is enforced.
So, the first content producing nested tag will have it's prepend removed.</p>
<p>Binary Conditional Attributes:</p>
<ul>
  <li><code>prepend</code> alias <code>pre</code> - the overridable SQL part that will be prepended to the statement (optional, its <code>removeFirstPrepend</code> is prepend isn't empty)</li>
  <li><code>open</code> alias <code>o</code> - the string with which to open the entire resulting body content (optional)</li>
  <li><code>close</code> alias <code>c</code> - the string with which to close the entire resulting body content (optional)</li>
</ul>
<table border="1">
  <thead>
    <tr><th>Tag</th><th>Description</th><th>Tag alias when use <code>sql-map-2.4.dtd</code></th></tr>
  </thead>
  <tbody>
    <tr><td><code>&lt;dynamic&gt;</code></td><td>Wrapper tag that allows for an overall prepend, open and close.</td><td><code>&lt;dyn&gt;</code></td></tr>
  </tbody>
</table>
<h3 id="binary-conditional-elements">Binary Conditional Elements<a class="headerlink" href="#_toc_binary-conditional-elements">←</a></h3>
<p>Binary conditional elements compare a property value to a static vale or another property value. If the result is true, the body content is included in the SQL query.</p>
<p>Binary Conditional Attributes:</p>
<ul>
  <li><code>prepend</code> alias <code>pre</code> - the overridable SQL part that will be prepended to the statement (optional)</li>
  <li><code>property</code> alias <code>p</code> - the property to be compared (required, default is the parameter self)</li>
  <li><code>compareProperty</code> alias <code>cp</code> - the other property to be compared (required or compareValue)</li>
  <li><code>compareValue</code> alias <code>cv</code> - the value to be compared  (required or compareProperty)</li>
  <li><code>removeFirstPrepend</code> alias <code>rm</code> - removes the prepend of the first nested content producing tag (true|false, optional)</li>
  <li><code>open</code> alias <code>o</code> - the string with which to open the entire resulting body content (optional)</li>
  <li><code>close</code> alias <code>c</code> - the string with which to close the entire resulting body content (optional)</li>
</ul>
<table border="1">
  <thead>
    <tr><th>Tag</th><th>Description</th><th>Tag alias when use <code>sql-map-2.4.dtd</code></th></tr>
  </thead>
  <tbody>
    <tr><td><code>&lt;isEqual&gt;</code></td><td>Checks the equality of a property and a value, or another property.</td><td><code>&lt;eq&gt;</code></td></tr>
    <tr><td><code>&lt;isNotEqual&gt;</code></td><td>Checks the inequality of a property and a value, or another property.</td><td><code>&lt;ne&gt;</code></td></tr>
    <tr><td><code>&lt;isGreaterThan&gt;</code></td><td>Checks if a property is greater than a value or another property.</td><td><code>&lt;gt&gt;</code></td></tr>
    <tr><td><code>&lt;isGreaterEqual&gt;</code></td><td>Checks if a property is greater than or equal to a value or another property.</td><td><code>&lt;ge&gt;</code></td></tr>
    <tr><td><code>&lt;isLessThan&gt;</code></td><td>Checks if a property is less than a value or another property.</td><td><code>&lt;lt&gt;</code></td></tr>
    <tr><td><code>&lt;isLessEqual&gt;</code></td><td>Checks if a property is less than or equal to a value or another property.</td><td><code>&lt;le&gt;</code></td></tr>
  </tbody>
</table>
<p>Example Usage:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;le <span class="hljs-attr">pre</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">p</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">cv</span>=<span class="hljs-string">"18"</span>&gt;</span><span class="sql">
        ADOLESCENT = '<span class="hljs-literal">TRUE</span><span class="hljs-string">'
    </span></span><span class="hljs-symbol">&lt;/le&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="unary-conditional-elements">Unary Conditional Elements<a class="headerlink" href="#_toc_unary-conditional-elements">←</a></h3>
<p>Unary conditional elements check the state of a property for a specific condition.</p>
<p>Unary Conditional Attributes:</p>
<ul>
  <li><code>prepend</code> alias <code>pre</code> - the overridable SQL part that will be prepended to the statement (optional)</li>
  <li><code>property</code> alias <code>p</code> - the property to be checked (required, default is the parameter self)</li>
  <li><code>removeFirstPrepend</code> alias <code>rm</code> - removes the prepend of the first nested content producing tag (true|false, optional)</li>
  <li><code>open</code> alias <code>o</code> - the string with which to open the entire resulting body content (optional)</li>
  <li><code>close</code> alias <code>c</code> - the string with which to close the entire resulting body content (optional)</li>
</ul>
<table border="1">
  <thead>
    <tr><th>Tag</th><th>Description</th><th>Tag alias when use <code>sql-map-2.4.dtd</code></th></tr>
  </thead>
  <tbody>
    <tr><td><code>&lt;isPropertyAvailable&gt;</code></td><td>Checks if a property is available (i.e is a property of the parameter bean)</td><td><code>&lt;pa&gt;</code></td></tr>
    <tr><td><code>&lt;isNotPropertyAvailable&gt;</code></td><td>Checks if a property is unavailable (i.e not a property of the parameter bean)</td><td><code>&lt;npa&gt;</code></td></tr>
    <tr><td><code>&lt;isNull&gt;</code></td><td>Checks if a property is null.</td><td><code>&lt;nul&gt;</code></td></tr>
    <tr><td><code>&lt;isNotNull&gt;</code></td><td>Checks if a property is not null.</td><td><code>&lt;nn&gt;</code></td></tr>
    <tr><td><code>&lt;isEmpty&gt;</code></td><td>Checks to see if the value of a Collection, String or String.valueOf() property is null or empty  ("" or size() &lt; 1).</td><td><code>&lt;em&gt;</code></td></tr>
    <tr><td><code>&lt;isNotEmpty&gt;</code></td><td>Checks to see if the value of a Collection, String or String.valueOf() property is not null and not empty ("" or size() &lt; 1).</td><td><code>&lt;nem&gt;</code></td></tr>
  </tbody>
</table>
<p>Example Usage:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;isNotEmpty <span class="hljs-attr">prepend</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"firstName"</span> &gt;</span><span class="undefined">
        FIRST_NAME = #firstName#
    </span><span class="hljs-symbol">&lt;/isNotEmpty&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="other-elements">Other Elements<a class="headerlink" href="#_toc_other-elements">←</a></h3>
<h4 id="parameter-present">Parameter Present<a class="headerlink" href="#_toc_parameter-present">←</a></h4>
<p>These elements check for parameter object existence.</p>
<p>Parameter Present Attributes:</p>
<ul>
  <li><code>prepend</code> alias <code>pre</code> - the overridable SQL part that will be prepended to the statement (optional)</li>
  <li><code>removeFirstPrepend</code> alias <code>rm</code> - removes the prepend of the first nested content producing tag (true|false, optional)</li>
  <li><code>open</code> alias <code>o</code> - the string with which to open the entire resulting body content (optional)</li>
  <li><code>close</code> alias <code>c</code> - the string with which to close the entire resulting body content (optional)</li>
</ul>
<table border="1">
  <thead>
    <tr><th>Tag</th><th>Description</th><th>Tag alias when use <code>sql-map-2.4.dtd</code></th></tr>
  </thead>
  <tbody>
    <tr><td><code>&lt;isParameterPresent&gt;</code></td><td>Checks to see if the parameter object is present (not null).</td><td><code>&lt;pp&gt;</code></td></tr>
    <tr><td><code>&lt;isNotParameterPresent&gt;</code></td><td>Checks to see if the parameter object is not present (null).</td><td><code>&lt;npp&gt;</code></td></tr>
  </tbody>
</table>
<p>Example Usage:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;npp <span class="hljs-attr">pre</span>=<span class="hljs-string">"AND"</span>&gt;</span><span class="sql">
        EMPLOYEE_TYPE = '<span class="hljs-keyword">DEFAULT</span><span class="hljs-string">'
    </span></span><span class="hljs-symbol">&lt;/npp&gt;</span><span class="undefined">
</span></code></pre>
<h4 id="iterate">Iterate<a class="headerlink" href="#_toc_iterate">←</a></h4>
<p>This tag will iterate over a collection and repeat the body content for each item in a List</p>
<p>Iterate Attributes:</p>
<ul>
  <li><code>prepend</code> alias <code>pre</code> - the overridable SQL part that will be prepended to the statement (optional)</li>
  <li><code>property</code> alias <code>p</code> - a property of type <code>java.util.Collection</code>, or <code>java.util.Iterator</code>, or an array that is to be iterated over
  (optional - the parameter object is assumed to be a collection if the property is not specified. See below for more information.)</li>
  <li><code>open</code> alias <code>o</code> - the string with which to open the entire block of iterations, useful for brackets (optional)</li>
  <li><code>close</code> alias <code>c</code> - the string with which to close the entire block of iterations, useful for brackets (optional)</li>
  <li><code>conjunction</code> alias <code>conj</code> - the string to be applied in between each iteration, useful for AND and OR (optional)</li>
  <li><code>removeFirstPrepend</code> alias <code>rm</code> - removes the prepend of the first nested content producing tag (<code>true|false|iterate</code>, optional - see below for more information)</li>
</ul>
<table border="1">
  <thead>
    <tr><th>Tag</th><th>Description</th><th>Tag alias when use <code>sql-map-2.4.dtd</code></th></tr>
  </thead>
  <tbody>
    <tr><td><code>&lt;iterate&gt;</code></td><td>Iterates over a property that is an implementation <code>java.util.Collection</code>, or <code>java.util.Iterator</code>, or is an array.</td><td><code>&lt;it&gt;</code></td></tr>
  </tbody>
</table>
<p>Example Usage:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;iterate <span class="hljs-attr">prepend</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userNameList"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">conjunction</span>=<span class="hljs-string">"OR"</span>&gt;</span><span class="undefined">
        username = #userNameList[]#
    </span><span class="hljs-symbol">&lt;/iterate&gt;</span><span class="undefined">
</span></code></pre>
<p>It is also possible to use the iterate when the collection is passed in as a parameter to your mapped statement.
Example Usage:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;it <span class="hljs-attr">pre</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">o</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">conj</span>=<span class="hljs-string">"OR"</span>&gt;</span><span class="undefined">
        username = #[]#
    </span><span class="hljs-symbol">&lt;/it&gt;</span><span class="undefined">
</span></code></pre>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>In the first example, <code>userNameList[]</code> becomes an operator that refers to the current item in the list.</p>
  <p>It is very important to include the <code>square brackets - []</code> at the end of the property name when using the <code>&lt;iterate</code>&gt; element.
  These brackets distinguish this object as a collection to keep the parser from simply outputting the collection as a string.</p>
</blockquote>
<p>You can use this operator to select properties from list items like this:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;iterate <span class="hljs-attr">prepend</span>=<span class="hljs-string">"AND"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userList"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">conjunction</span>=<span class="hljs-string">"OR"</span>&gt;</span><span class="sql">
        firstname    = #userList[].firstName#
        <span class="hljs-keyword">AND</span> lastname = #userList[].lastName#
    </span><span class="hljs-symbol">&lt;/iterate&gt;</span><span class="undefined">
</span></code></pre>
<p><code>&lt;iterate&gt;</code> tags can also be nested to create complex conditions. Here is an example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;dyn <span class="hljs-attr">pre</span>=<span class="hljs-string">"where"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;it <span class="hljs-attr">p</span>=<span class="hljs-string">"orConditions"</span> <span class="hljs-attr">conj</span>=<span class="hljs-string">"or"</span>&gt;</span><span class="undefined">
            (
            </span><span class="hljs-symbol">&lt;it <span class="hljs-attr">p</span>=<span class="hljs-string">"orConditions[].conditions"</span> <span class="hljs-attr">conj</span>=<span class="hljs-string">"and"</span>&gt;</span><span class="undefined">
                $orConditions[].conditions[].condition$ #orConditions[].conditions[].value#
            </span><span class="hljs-symbol">&lt;/it&gt;</span><span class="undefined">
            )
        </span><span class="hljs-symbol">&lt;/it&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/dyn&gt;</span><span class="undefined">
</span></code></pre>
<p>This assumes that the parameter object has a property <code>orConditions</code> that is a List of objects.
And each of the object in that List contains a List property called <code>conditions</code>. So we have Lists within Lists in the parameter object.
Notice that the phrase <code>orConditions[].conditions[].condition</code> means get the condition property from the current element in the inner list,
which is the conditions property of the current object in the outer loop. There is no restriction to level of nesting iterate tags.
Also, the <code>current item</code> operators can be used as input to any of the other dynamic tags.</p>
<p>The <code>removeFirstPrepend</code> function with the <code>&lt;iterate&gt;</code> tag is somewhat different than the other tags. If you specify <code>true</code> for <code>removeFirstPrepend</code>,
then the first nested attribute that produces content will have its prepend removed. This will happen once for the entire loop.
This is the correct behavior in most circumstances.</p>
<p>In some circumstances, it may be desirable to have the <code>removeFirstPrepend</code> function work for each iteration of the loop, rather than just one time.
In this case, specify <code>iterate</code> as the value for removeFirstPrepend.</p>
<h3 id="simple-dynamic-sql-elements">Simple Dynamic SQL Elements<a class="headerlink" href="#_toc_simple-dynamic-sql-elements">←</a></h3>
<p>Despite the power of the full Dynamic Mapped Statement API discussed above, sometimes you just need a simple, small piece of your SQL to be dynamic.
For this, SQL statements and statements can contain simple dynamic SQL elements to help implement dynamic order by clauses,
dynamic select columns or pretty much any part of the SQL statement.
The concept works much like inline parameter maps, but uses a slightly different syntax. Consider the following example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
            $preferredOrder$
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above example the <code>preferredOrder</code> dynamic element will be replaced by the value of the <code>preferredOrder</code> property of the parameter object (just like a parameter map).
The difference is that this is a fundamental change to the SQL statement itself, which is much more serious than simply setting a parameter value.
A mistake made in a Dynamic SQL Element can introduce security, performance and stability risks.
Take care to do a lot of redundant checks to ensure that the simple dynamic SQL elements are being used appropriately.
Also, be mindful of your design, as there is potential for database specifics to encroach on your business object model.
For example, you may not want a column name intended for an order by clause to end up as a property in your business object, or as a field value on your JSP page.</p>
<p>Simple dynamic elements can be included within statements and come in handy when there is a need to modify the SQL statement itself. For example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            *
        <span class="hljs-keyword">FROM</span>
            PRODUCT
        </span><span class="hljs-symbol">&lt;dynamic <span class="hljs-attr">prepend</span>=<span class="hljs-string">"WHERE"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;isNotEmpty <span class="hljs-attr">property</span>=<span class="hljs-string">"description"</span>&gt;</span><span class="undefined">
                PRD_DESCRIPTION $operator$ #description#
            </span><span class="hljs-symbol">&lt;/isNotEmpty&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/dynamic&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>In the above example the operator property of the parameter object will be used to replace the $operator$ token.
So if the operator property was equal to 'like' and the description property was equal to '%dog%', then the SQL statement generated would be:</p>
<pre><code class="language-sql hljs">    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> PRODUCT <span class="hljs-keyword">WHERE</span> PRD_DESCRIPTION <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%dog%'</span>
</code></pre>
<h4 id="param-1"><code>$@param$</code><a class="headerlink" href="#_toc_param-1">←</a></h4>
<p>If a dynamic paramter starts with <code>@</code>, such as <code>$@param$</code>, then it would be replace as the value of jBATIS global property <code>param</code>.
So it is almost same with <code>${param}</code> but it is not fixed and never debug out sensitive information.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li><code>${param}</code> is processed at xml parsing time as a fixed value.</li>
    <li><code>$@param$</code> is processed at each time the statement executed, so its value is not fixed.</li>
  </ul>
</blockquote>
<p>Specially, sql text in SQL Map statements would be preprocessed to erase redundant white spaces. Thus, <code>'spaces in sql literal'</code> would never be changed.
So you <strong>MUST</strong> never put parameters or xml tags in to sql literal. For example, the following sql would be a static sql clause:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            id, name
        <span class="hljs-keyword">FROM</span>
            my_table
        <span class="hljs-keyword">WHERE</span> acol = <span class="hljs-string">'$myparam$'</span>
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<p>But the following sql would be replace <code>${myparam}</code> as the value of jBATIS global property <code>myparam</code>:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;select <span class="hljs-attr">id</span>=<span class="hljs-string">"getProduct"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"get-product-result"</span>&gt;</span><span class="sql">
        <span class="hljs-keyword">SELECT</span>
            id, name
        <span class="hljs-keyword">FROM</span>
            my_table
        <span class="hljs-keyword">WHERE</span> acol = <span class="hljs-string">'${myparam}'</span>
    </span><span class="hljs-symbol">&lt;/select&gt;</span><span class="undefined">
</span></code></pre>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>If the value of a <code>$param$</code> is <code>null</code>, the replacement string is <strong>empty</strong> (<code>""</code>). <strong>Note this can cause problems such as data leak</strong>(e.g. the <code>WHERE</code> sub-clause is missed).</li>
    <li>A <code>$</code> is the escape char for another <code>$</code>, thus <code>$$</code> is treated as <code>$</code>. Orphan <code>$</code> will cause exception.</li>
    <li>But <code>$</code> in sql literal such as <code>'a normal $ char'</code> is treated as normal char in jBATIS.</li>
    <li><code>$param$</code> is deprecated to use because it can cause <strong>sql-injection</strong> probleam. <code>#param#</code> should be used as much as possible instead of <code>$param$</code>.</li>
  </ul>
</blockquote>
<h3 id="structure-of-all-statements">Structure of All Statements<a class="headerlink" href="#_toc_structure-of-all-statements">←</a></h3>
<p>The diagram below illustrates the process what and how a mapped statement become to.</p>
<p><img alt="Image" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4wLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLVNWRy0yMDAxMDkwNC9EVEQvc3ZnMTAuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTAxOCIgaGVpZ2h0PSI0MTYiIHRleHQtcmVuZGVyaW5nPSJhdXRvIiBzaGFwZS1yZW5kZXJpbmc9ImF1dG8iPgo8ZGVmcz48Y2xpcFBhdGggaWQ9Il85bTNpMjJfMCI+PHBhdGggZD0iTTAsMCBMMTY4LDAgTDE2OCwxNjggTDAsMTY4IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMl8xIj48cGF0aCBkPSJNMCwwIEwwLDI0IEwxNjEsMjQgTDE2MSwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjJfMiI+PHBhdGggZD0iTTAsMCBMMCwxMDQgTDE2MSwxMDQgTDE2MSwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjJfMyI+PHBhdGggZD0iTTAsMCBMMCwyNCBMMTQ3LDI0IEwxNDcsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIyXzQiPjxwYXRoIGQ9Ik0wLDAgTDIyNCwwIEwyMjQsOTggTDAsOTggTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIyXzUiPjxwYXRoIGQ9Ik0wLDAgTDI5NCwwIEwyOTQsMTQwIEwwLDE0MCBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjJfNiI+PHBhdGggZD0iTTAsMCBMMzUwLDAgTDM1MCwxOTYgTDAsMTk2IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMl83Ij48cGF0aCBkPSJNMCwwIEw4NSwwIEw4NSw3MSBMMCw3MSBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjJfOCI+PHBhdGggZD0iTTAsMCBMMTEyLDAgTDExMiwyOCBMMCwyOCBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjJfOSI+PHBhdGggZD0iTTAsMCBMMTQwLDAgTDE0MCw1NiBMMCw1NiBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjJfMTAiPjxwYXRoIGQ9Ik0wLDAgTDEyNiwwIEwxMjYsMjggTDAsMjggTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIyXzExIj48cGF0aCBkPSJNMCwwIEw1NywwIEw1NywxNjkgTDAsMTY5IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMl8xMiI+PHBhdGggZD0iTTAsMCBMMTQxLDAgTDE0MSwxMTMgTDAsMTEzIEwwLDAgWiIvPjwvY2xpcFBhdGg+CjwvZGVmcz4KPGcgc3R5bGU9ImZvbnQtZmFtaWx5Ok1pY3Jvc29mdCBZYUhlaTtmb250LXNpemU6MTZweDtzdHJva2UtbGluZWNhcDpzcXVhcmU7c3Ryb2tlLW9wYWNpdHk6MTtmaWxsLW9wYWNpdHk6MTsiPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTY3IiBoZWlnaHQ9IjE2NyIgc3R5bGU9ImZpbGw6I2MwYzBjMDtmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDg5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTY2IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDg5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMCkiLz4KPGxpbmUgeDE9IjE2NyIgeTE9IjAiIHgyPSIxNjciIHkyPSIxNjYiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw4OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzApIi8+CjxsaW5lIHgxPSIxNjciIHkxPSIxNjciIHgyPSIxIiB5Mj0iMTY3IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsODkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8wKSIvPgo8bGluZSB4MT0iMCIgeTE9IjE2NyIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsODkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8wKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsODkpIj48dGV4dCB4PSIxMSIgeT0iMjAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8wKSI+bWFwcGVkIHN0YXRlbWVudDwvdGV4dD48L2c+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNTMiIGhlaWdodD0iMjMiIHN0eWxlPSJmaWxsOiNmZWZkZmM7ZmlsbC1vcGFjaXR5OjA7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEyLDExMykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzEpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjE1MiIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTIsMTEzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMSkiLz4KPGxpbmUgeDE9IjE1MyIgeTE9IjAiIHgyPSIxNTMiIHkyPSIyMiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMiwxMTMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8xKSIvPgo8bGluZSB4MT0iMTUzIiB5MT0iMjMiIHgyPSIxIiB5Mj0iMjMiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTIsMTEzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMSkiLz4KPGxpbmUgeDE9IjAiIHkxPSIyMyIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEyLDExMykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzEpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTIsMTEzKSI+PHRleHQgeD0iNDkiIHk9IjIwIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMSkiPlNxbFRleHQ8L3RleHQ+PC9nPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTUzIiBoZWlnaHQ9IjEwMyIgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTIsMTQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMikiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTUyIiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMiwxNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8yKSIvPgo8bGluZSB4MT0iMTUzIiB5MT0iMCIgeDI9IjE1MyIgeTI9IjEwMiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMiwxNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8yKSIvPgo8bGluZSB4MT0iMTUzIiB5MT0iMTAzIiB4Mj0iMSIgeTI9IjEwMyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMiwxNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8yKSIvPgo8bGluZSB4MT0iMCIgeTE9IjEwMyIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEyLDE0MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzIpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTIsMTQxKSI+PHRleHQgeD0iNTEiIHk9IjIwIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMikiPlNxbFRhZzwvdGV4dD48L2c+CjxsaW5lIHgxPSIwIiB5MT0iMjQiIHgyPSIxNTMiIHkyPSIyNCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMiwxNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8yKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEyLDE0MSkiPjx0ZXh0IHg9IjgiIHk9IjQ0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMikiPnByZXBlbmQ9Li4uPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEzOSIgaGVpZ2h0PSIyMyIgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTksMTg5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMykiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTM4IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxOSwxODkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8zKSIvPgo8bGluZSB4MT0iMTM5IiB5MT0iMCIgeDI9IjEzOSIgeTI9IjIyIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE5LDE4OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzMpIi8+CjxsaW5lIHgxPSIxMzkiIHkxPSIyMyIgeDI9IjEiIHkyPSIyMyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxOSwxODkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8zKSIvPgo8bGluZSB4MT0iMCIgeTE9IjIzIiB4Mj0iMCIgeTI9IjEiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTksMTg5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMykiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxOSwxODkpIj48dGV4dCB4PSI0MiIgeT0iMjAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8zKSI+U3FsVGV4dDwvdGV4dD48L2c+CjxlbGxpcHNlIGN4PSIxMTEiIGN5PSI0OCIgcng9IjExMSIgcnk9IjQ4IiBzdHlsZT0iZmlsbDojODBjMGZmO2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDcxOSw1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNCkiLz4KPGVsbGlwc2UgY3g9IjExMSIgY3k9IjQ4IiByeD0iMTExIiByeT0iNDgiIHN0eWxlPSJzdHJva2U6Izk5MDAzMztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDcxOSw1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNCkiLz4KPGxpbmUgeDE9IjE1IiB5MT0iMjQiIHgyPSIyMDciIHkyPSIyNCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3MTksNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzQpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzE5LDUpIj48dGV4dCB4PSI3OCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl80KSI+U3RhdGljU3FsPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3MTksNSkiPjx0ZXh0IHg9IjU0IiB5PSI1MyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzQpIj5zZWxlY3QgYSBmcm9tIGI8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDcxOSw1KSI+PHRleHQgeD0iNjciIHk9Ijc0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNCkiPndoZXJlIGMgPSA/PC90ZXh0PjwvZz4KPGVsbGlwc2UgY3g9IjE0NiIgY3k9IjY5IiByeD0iMTQ2IiByeT0iNjkiIHN0eWxlPSJmaWxsOiM4MGMwZmY7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNzE5LDE0NSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzUpIi8+CjxlbGxpcHNlIGN4PSIxNDYiIGN5PSI2OSIgcng9IjE0NiIgcnk9IjY5IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3MTksMTQ1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNSkiLz4KPGxpbmUgeDE9IjE4IiB5MT0iMzYiIHgyPSIyNzQiIHkyPSIzNiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3MTksMTQ1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNSkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw3MTksMTQ1KSI+PHRleHQgeD0iNzUiIHk9IjIzIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNSkiPlNpbXBsZUR5bmFtaWNTcWw8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDcxOSwxNDUpIj48dGV4dCB4PSI4MCIgeT0iNzQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl81KSI+c2VsZWN0IGEgZnJvbSAkYiQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDcxOSwxNDUpIj48dGV4dCB4PSIxMDIiIHk9Ijk1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNSkiPndoZXJlIGMgPSA/PC90ZXh0PjwvZz4KPGVsbGlwc2UgY3g9IjE3NCIgY3k9Ijk3IiByeD0iMTc0IiByeT0iOTciIHN0eWxlPSJmaWxsOiM4MGMwZmY7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzEzLDIxNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzYpIi8+CjxlbGxpcHNlIGN4PSIxNzQiIGN5PSI5NyIgcng9IjE3NCIgcnk9Ijk3IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMTMsMjE1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNikiLz4KPGxpbmUgeDE9IjIyIiB5MT0iNTAiIHgyPSIzMjYiIHkyPSI1MCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMTMsMjE1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNikiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMTMsMjE1KSI+PHRleHQgeD0iMTI5IiB5PSIzMCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzYpIj5EeW5hbWljU3FsPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMTMsMjE1KSI+PHRleHQgeD0iMTE3IiB5PSIxMDIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl82KSI+c2VsZWN0IGEgZnJvbSBiPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMTMsMjE1KSI+PHRleHQgeD0iOTciIHk9IjEyMyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzYpIj4mbHQ7ZHluIHByZT0mcXVvdDt3aGVyZSZxdW90OyZndDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMxMywyMTUpIj48dGV4dCB4PSI5NyIgeT0iMTQ0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNikiPiBjID0gPyBhbmQgZCBsaWtlICRlJDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzEzLDIxNSkiPjx0ZXh0IHg9IjE0NCIgeT0iMTY1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNikiPiZsdDsvZHluJmd0OzwvdGV4dD48L2c+CjxsaW5lIHgxPSI3MCIgeTE9IjE0IiB4Mj0iNDIiIHkyPSIzNSIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI3MSwxMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl83KSIvPgo8bGluZSB4MT0iNDIiIHkxPSIzNSIgeDI9IjE0IiB5Mj0iNTYiIHN0eWxlPSJzdHJva2U6cmVkOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNzEsMTE3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfNykiLz4KPGxpbmUgeDE9IjcwIiB5MT0iMTQiIHgyPSI2MyIgeTI9IjI5IiBzdHlsZT0ic3Ryb2tlOnJlZDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjcxLDExNykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzcpIi8+CjxsaW5lIHgxPSI3MCIgeTE9IjE0IiB4Mj0iNTQiIHkyPSIxNyIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI3MSwxMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl83KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI3MSwxMTcpIj48dGV4dCB4PSIzNSIgeT0iMzYiIHN0eWxlPSJmaWxsOnJlZDsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzcpIj5OPC90ZXh0PjwvZz4KPGcgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNzMsMTU5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfOCkiPjxwYXRoIGQ9Ik01NiwwIEwxMTIsMTQgTDU2LDI3IEwwLDE0IFoiLz48L2c+CjxnIHN0eWxlPSJzdHJva2U6Izk5MDAzMztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE3MywxNTkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl84KSI+PHBhdGggZD0iTTU2LDAgTDExMiwxNCBMNTYsMjcgTDAsMTQgWiIvPjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNzMsMTU5KSI+PHRleHQgeD0iMTEiIHk9IjIwIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfOCkiPmhhcyBTcWxUYWc/PC90ZXh0PjwvZz4KPGVsbGlwc2UgY3g9IjY5IiBjeT0iMjciIHJ4PSI2OSIgcnk9IjI3IiBzdHlsZT0iZmlsbDojZmZhZmFmO2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwxMDMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl85KSIvPgo8ZWxsaXBzZSBjeD0iNjkiIGN5PSIyNyIgcng9IjY5IiByeT0iMjciIHN0eWxlPSJzdHJva2U6Izk5MDAzMztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwxMDMpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl85KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDM0MSwxMDMpIj48dGV4dCB4PSI0MiIgeT0iMzQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl85KSI+UmF3U3FsPC90ZXh0PjwvZz4KPGcgc3R5bGU9ImZpbGw6I2ZlZmRmYztmaWxsLW9wYWNpdHk6MDs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0ODEsMTE3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMTApIj48cGF0aCBkPSJNNjMsMCBMMTI2LDE0IEw2MywyNyBMMCwxNCBaIi8+PC9nPgo8ZyBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw0ODEsMTE3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMTApIj48cGF0aCBkPSJNNjMsMCBMMTI2LDE0IEw2MywyNyBMMCwxNCBaIi8+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDQ4MSwxMTcpIj48dGV4dCB4PSIyMSIgeT0iMjAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8xMCkiPmhhcyAka2V5JD88L3RleHQ+PC9nPgo8bGluZSB4MT0iNDIiIHkxPSIxNTQiIHgyPSIyOCIgeTI9Ijg0IiBzdHlsZT0ic3Ryb2tlOnJlZDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjcxLDE1OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzExKSIvPgo8bGluZSB4MT0iMjgiIHkxPSI4NCIgeDI9IjE0IiB5Mj0iMTQiIHN0eWxlPSJzdHJva2U6cmVkOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNzEsMTU5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMTEpIi8+CjxsaW5lIHgxPSI0MiIgeTE9IjE1MyIgeDI9IjMyIiB5Mj0iMTQwIiBzdHlsZT0ic3Ryb2tlOnJlZDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjcxLDE1OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzExKSIvPgo8bGluZSB4MT0iNDIiIHkxPSIxNTMiIHgyPSI0NiIgeTI9IjEzNyIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI3MSwxNTkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8xMSkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyNzEsMTU5KSI+PHRleHQgeD0iMjMiIHk9Ijg4IiBzdHlsZT0iZmlsbDpyZWQ7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8xMSkiPlk8L3RleHQ+PC9nPgo8bGluZSB4MT0iMTI2IiB5MT0iMTQiIHgyPSI3MCIgeTI9IjU2IiBzdHlsZT0ic3Ryb2tlOnJlZDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTkzLDMzKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMTIpIi8+CjxsaW5lIHgxPSI3MCIgeTE9IjU2IiB4Mj0iMTQiIHkyPSI5OCIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU5MywzMykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzEyKSIvPgo8bGluZSB4MT0iMTI1IiB5MT0iMTUiIHgyPSIxMTgiIHkyPSIzMCIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU5MywzMykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzEyKSIvPgo8bGluZSB4MT0iMTI1IiB5MT0iMTUiIHgyPSIxMDkiIHkyPSIxOCIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU5MywzMykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzEyKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU5MywzMykiPjx0ZXh0IHg9IjYzIiB5PSI1NyIgc3R5bGU9ImZpbGw6cmVkOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMTIpIj5OPC90ZXh0PjwvZz4KPGxpbmUgeDE9IjEyNiIgeTE9Ijk4IiB4Mj0iNzAiIHkyPSI1NiIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU5MywxMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8xMikiLz4KPGxpbmUgeDE9IjcwIiB5MT0iNTYiIHgyPSIxNCIgeTI9IjE0IiBzdHlsZT0ic3Ryb2tlOnJlZDsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTkzLDExNykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIyXzEyKSIvPgo8bGluZSB4MT0iMTI1IiB5MT0iOTciIHgyPSIxMDkiIHkyPSI5NCIgc3R5bGU9InN0cm9rZTpyZWQ7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDU5MywxMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMl8xMikiLz4KPGxpbmUgeDE9IjEyNSIgeTE9Ijk3IiB4Mj0iMTE4IiB5Mj0iODIiIHN0eWxlPSJzdHJva2U6cmVkOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1OTMsMTE3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMTIpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTkzLDExNykiPjx0ZXh0IHg9IjY1IiB5PSI1NyIgc3R5bGU9ImZpbGw6cmVkOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjJfMTIpIj5ZPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLDApIj48dGV4dCB4PSIyIiB5PSI0MTQiIHN0eWxlPSJmaWxsOiNjMGMwYzA7Zm9udC1mYW1pbHk6SW1wYWN0O2ZvbnQtc2l6ZToxMXB4OyIgPihjKWpiYXRpcy5vcmc8L3RleHQ+PC9nPjwvZz48L3N2Zz4K"></p>
<p>Thus, <code>#param#</code> parameters always are preprocessed fistly, then the <code>$param$</code> parameters are processed.</p>
<h2 id="jbatis-with-springframework">jBATIS with SpringFramework<a class="headerlink" href="#_toc_jbatis-with-springframework">←</a></h2>
<p>The following xml fragment show jBATIS integration with SpringFramework:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.ibatis.common.jdbc.SimpleDataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"forceCloseAll"</span>
        <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">"false"</span>&gt;</span><span class="undefined">
        </span>&lt;constructor-arg&gt;
            &lt;util:map map-class="java.util.LinkedHashMap"&gt;
                <span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"JDBC.Driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.driver}"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"JDBC.ConnectionURL"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.url}"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"JDBC.Username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.user}"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"JDBC.Password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.password}"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"JDBC.DefaultAutoCommit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-comment">&lt;!--entry key="JDBC.DefaultTransactionIsolation" value="READ_COMMITTED" /--&gt;</span>
                <span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"Pool.MaximumActiveConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.pool.max}"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"Pool.MaximumIdleConnections"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.pool.idle}"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"Pool.PingIdleConnectionsAfter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"900000"</span> /&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;entry <span class="hljs-attr">key</span>=<span class="hljs-string">"Pool.EraseIdleConnectionsAfter"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1800000"</span> /&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;/util:map&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/constructor-arg&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span><span class="hljs-comment">&lt;!-- ======================================================================== --&gt;</span>
    <span class="hljs-comment">&lt;!-- iBatis SQL map defination --&gt;</span>
    <span class="hljs-comment">&lt;!-- ======================================================================== --&gt;</span>
    <span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlMapClient"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.ibatis.spring.SqlMapClientFactoryBeanX"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"dialect"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mysql"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"configLocations"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;list&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;value&gt;</span><span class="undefined">classpath:/sqlmap-config-foo.xml</span><span class="hljs-symbol">&lt;/value&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;value&gt;</span><span class="undefined">classpath:/sqlmap-config-bar.xml</span><span class="hljs-symbol">&lt;/value&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;/list&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/property&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span><span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span>&lt;tx:advice id="txAdvice1" transaction-manager="transactionManager"&gt;
        &lt;tx:attributes&gt;
               &lt;tx:method name="find*" read-only="true" /&gt;
            &lt;tx:method name="query*" read-only="true" /&gt;
            &lt;tx:method name="get*" read-only="true" /&gt;
            &lt;tx:method name="load*" read-only="true" /&gt;
            &lt;tx:method name="list*" read-only="true" /&gt;
            &lt;tx:method name="is*" read-only="true" /&gt;
            &lt;tx:method name="*" isolation="READ_COMMITTED" propagation="REQUIRED" /&gt;
        <span class="hljs-symbol">&lt;/tx:attributes&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/tx:advice&gt;</span><span class="undefined">
</span></code></pre>
<h3 id="orgibatisspringsqlmapclientfactorybean">org.ibatis.spring.SqlMapClientFactoryBean<a class="headerlink" href="#_toc_orgibatisspringsqlmapclientfactorybean">←</a></h3>
<p>This factory can accept the dialect property and is more flexible than the legacy factory in spring framework.</p>
<h3 id="orgibatisspringsqlmapclientfactorybeanx">org.ibatis.spring.SqlMapClientFactoryBeanX<a class="headerlink" href="#_toc_orgibatisspringsqlmapclientfactorybeanx">←</a></h3>
<p>This factory inherit from SqlMapClientFactoryBean and can put all the attributes of webapp context into jbaits SqlMapClient.
This provides the isolation ability between a web app and another.</p>
<h3 id="integration-with-atomikos">Integration with Atomikos<a class="headerlink" href="#_toc_integration-with-atomikos">←</a></h3>
<p>For distributed transaction, jBATIS can integrate with Atomikos. Here is an example:</p>
<pre><code class="language-xsql hljs">    <span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.atomikos.jdbc.AtomikosDataSourceBean"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"uniqueResourceName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mysql/bp5"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultIsolationLevel"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"xaDataSourceClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.jdbc2.optional.MysqlXADataSource"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"xaProperties"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;props&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;prop <span class="hljs-attr">key</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="undefined">${jdbc.user}</span><span class="hljs-symbol">&lt;/prop&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;prop <span class="hljs-attr">key</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="undefined">${jdbc.password}</span><span class="hljs-symbol">&lt;/prop&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;prop <span class="hljs-attr">key</span>=<span class="hljs-string">"url"</span>&gt;</span><span class="undefined">${jdbc.url}</span><span class="hljs-symbol">&lt;/prop&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;/props&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/property&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"maxPoolSize"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"minPoolSize"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"testQuery"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SELECT 1"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span><span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlMapClient"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.ibatis.spring.SqlMapClientFactoryBeanX"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"dialect"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mysql"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"configLocations"</span>&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;list&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;value&gt;</span><span class="undefined">classpath:/sqlmap-config-foo.xml</span><span class="hljs-symbol">&lt;/value&gt;</span><span class="undefined">
                </span><span class="hljs-symbol">&lt;value&gt;</span><span class="undefined">classpath:/sqlmap-config-bar.xml</span><span class="hljs-symbol">&lt;/value&gt;</span><span class="undefined">
            </span><span class="hljs-symbol">&lt;/list&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;/property&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span><span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"userTransactionManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.atomikos.icatch.jta.UserTransactionManager"</span>
        <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"forceShutdown"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span><span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"userTransaction"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.atomikos.icatch.jta.UserTransactionImp"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"transactionTimeout"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"300"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span><span class="hljs-symbol">&lt;bean <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userTransactionManager"</span> /&gt;</span><span class="undefined">
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"userTransaction"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userTransaction"</span> /&gt;</span><span class="undefined"> 
        </span><span class="hljs-symbol">&lt;property <span class="hljs-attr">name</span>=<span class="hljs-string">"allowCustomIsolationLevels"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/bean&gt;</span><span class="undefined">

    </span>&lt;tx:advice id="txAdvice1" transaction-manager="transactionManager"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="find*" read-only="true" /&gt;
            &lt;tx:method name="query*" read-only="true" /&gt;
            &lt;tx:method name="get*" read-only="true" /&gt;
            &lt;tx:method name="load*" read-only="true" /&gt;
            &lt;tx:method name="list*" read-only="true" /&gt;
            &lt;tx:method name="is*" read-only="true" /&gt;
            &lt;tx:method name="*" isolation="READ_COMMITTED" propagation="REQUIRED" /&gt;
        <span class="hljs-symbol">&lt;/tx:attributes&gt;</span><span class="undefined">
    </span><span class="hljs-symbol">&lt;/tx:advice&gt;</span><span class="undefined">
</span></code></pre>
<p>More information about Atomikos here:</p>
<ul>
  <li><a href="http://repo1.maven.org/maven2/com/atomikos/transactions-osgi">Maven Resource</a></li>
  <li><a href="https://www.atomikos.com/bin/view/Documentation/SpringIntegration">Help Document</a></li>
</ul>
<h2 id="programming-with-jbatis">Programming with jBATIS<a class="headerlink" href="#_toc_programming-with-jbatis">←</a></h2>
<p>The SqlMapClient API is meant to be simple and minimal. It provides the programmer with the ability to do four primary functions:
configure an SQL Map, execute an SQL update (including insert and delete), execute a query for a single object,
and execute a query for a list of objects.</p>
<h3 id="configuration">Configuration<a class="headerlink" href="#_toc_configuration">←</a></h3>
<p>Configuring an SQL Map is trivial once you have created your SQL Map XML definition files and SQL
Map configuration file (discussed above).  SqlMapClient instances are built using SqlMapClientBuilder.
This class has one primary static method named buildSqlMap().
The buildSqlMap() method simply takes a Reader instance that can read in the contents of an sqlMap-config.xml (not necessarily named that).</p>
<p>In jBATIS, You can use <code>org.ibatis.client.SqlMapClientBuilder</code> to build a SqlMapClient for using.
For example, the following java code show the using <code>mysql</code> dialect to build a SqlMapClient:</p>
<pre><code class="language-java hljs">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SqlMapClient <span class="hljs-title">getSqlMapper</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (sqlMapper == <span class="hljs-keyword">null</span>) {
            Reader reader = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">try</span> {
                reader = Resources.getResourceAsReader(<span class="hljs-string">"test/test-map.xml"</span>);
                sqlMapper = SqlMapClientBuilder.buildSqlMapClient(reader, <span class="hljs-string">"mysql"</span>); <span class="hljs-comment">// use mysql dialect here</span>
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Failed init Derby database connnetions:"</span> + e, e);
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">try</span> {
                        reader.close();
                    } <span class="hljs-keyword">catch</span> (IOException e) {
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> sqlMapper;
    }
</code></pre>
<h3 id="orgibatisclientdialect">org.ibatis.client.Dialect<a class="headerlink" href="#_toc_orgibatisclientdialect">←</a></h3>
<p>Dialect is used to optimize the sql for specifed database. there is some supported dialects as:</p>
<table border="1">
  <thead>
    <tr><th>dialect</th><th>Database</th></tr>
  </thead>
  <tbody>
    <tr><td><code>mysql</code></td><td>MySQL or MariaDB</td></tr>
    <tr><td><code>oracle</code></td><td>Oracel Database</td></tr>
    <tr><td><code>sqlserver</code></td><td>Microsoft SQL Server</td></tr>
    <tr><td><code>postgresql</code></td><td>PostgreSQL</td></tr>
    <tr><td><code>db2</code></td><td>IBM DB2</td></tr>
  </tbody>
</table>
<h4 id="query-optimization">Query optimization<a class="headerlink" href="#_toc_query-optimization">←</a></h4>
<p>Currently, MySQL and some other database are supported to use database's page query functionality.
Thus, if you execute <code>queryForObject()</code>, the sql will be append with something like <code>LIMIT 2</code> automatically.
if you execute <code>queryForPage()</code>, the sql will be append with something like <code>OFFSET n LIMIT m</code> automatically.</p>
<h4 id="replacement-of-statement">Replacement of statement<a class="headerlink" href="#_toc_replacement-of-statement">←</a></h4>
<p>With dialect <code>oracle</code>, if you execute a mapped statement <code>myquery1</code>, if there is another mapped statement with id <code>myquery1.oracle</code> exists,
then the <code>myquery1.oracle</code> will be executed automatically. This functionality can help you with portability.</p>
<h3 id="orgibatisclientsqlmapclient-and-orgibatisspringsqlmapclienttemplate">org.ibatis.client.SqlMapClient and org.ibatis.spring.SqlMapClientTemplate<a class="headerlink" href="#_toc_orgibatisclientsqlmapclient-and-orgibatisspringsqlmapclienttemplate">←</a></h3>
<p>There is rich api provided in jBATIS framework, The diagram below illustrates the class diagram.</p>
<p><img alt="Image" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4wLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLVNWRy0yMDAxMDkwNC9EVEQvc3ZnMTAuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTQ1MCIgaGVpZ2h0PSIxMDQyIiB0ZXh0LXJlbmRlcmluZz0iYXV0byIgc2hhcGUtcmVuZGVyaW5nPSJhdXRvIj4KPGRlZnM+PGNsaXBQYXRoIGlkPSJfOW0zaTIwXzAiPjxwYXRoIGQ9Ik0wLDAgTDI1LDAgTDI1LDczIEwwLDczIEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMF8xIj48cGF0aCBkPSJNMCwwIEwxMzMsMCBMMTMzLDEwOSBMMCwxMDkgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIwXzIiPjxwYXRoIGQ9Ik0wLDAgTDIyOSwwIEwyMjksMTgxIEwwLDE4MSBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjBfMyI+PHBhdGggZD0iTTAsMCBMMjA1LDAgTDIwNSwxNTcgTDAsMTU3IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMF80Ij48cGF0aCBkPSJNMCwwIEwyNSwwIEwyNSw4NSBMMCw4NSBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjBfNSI+PHBhdGggZD0iTTAsMCBMNDY4LDAgTDQ2OCwxMDMyIEwwLDEwMzIgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIwXzYiPjxwYXRoIGQ9Ik0wLDAgTDMzNiwwIEwzMzYsNDgwIEwwLDQ4MCBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjBfNyI+PHBhdGggZD0iTTAsMCBMMzM2LDAgTDMzNiwxNjggTDAsMTY4IEwwLDAgWiIvPjwvY2xpcFBhdGg+CjxjbGlwUGF0aCBpZD0iXzltM2kyMF84Ij48cGF0aCBkPSJNMCwwIEwzMzYsMCBMMzM2LDI2NCBMMCwyNjQgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIwXzkiPjxwYXRoIGQ9Ik0wLDAgTDMzNiwwIEwzMzYsMTMyIEwwLDEzMiBMMCwwIFoiLz48L2NsaXBQYXRoPgo8Y2xpcFBhdGggaWQ9Il85bTNpMjBfMTAiPjxwYXRoIGQ9Ik0wLDAgTDI2NCwwIEwyNjQsOTYgTDAsOTYgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJfOW0zaTIwXzExIj48cGF0aCBkPSJNMCwwIEwzMzYsMCBMMzM2LDMzNiBMMCwzMzYgTDAsMCBaIi8+PC9jbGlwUGF0aD4KPC9kZWZzPgo8ZyBzdHlsZT0iZm9udC1mYW1pbHk6TWljcm9zb2Z0IFlhSGVpO2ZvbnQtc2l6ZToxNHB4O3N0cm9rZS1saW5lY2FwOnNxdWFyZTtzdHJva2Utb3BhY2l0eToxO2ZpbGwtb3BhY2l0eToxOyI+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iMTIiIHkyPSIzNiIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwyODEsNzk3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMCkiLz4KPGxpbmUgeDE9IjEyIiB5MT0iMzYiIHgyPSIxMiIgeTI9IjYwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWRhc2hhcnJheTo4LDU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI4MSw3OTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8wKSIvPgo8bGluZSB4MT0iMTIiIHkxPSIxMiIgeDI9IjE4IiB5Mj0iMjQiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI4MSw3OTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8wKSIvPgo8bGluZSB4MT0iMTIiIHkxPSIxMiIgeDI9IjYiIHkyPSIyNCIgc3R5bGU9InN0cm9rZTpibGFjazsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjgxLDc5NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzApIi8+CjxnIHN0eWxlPSJmaWxsOndoaXRlOzsgc3Ryb2tlOiBub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDI4MSw3OTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8wKSI+PHBhdGggZD0iTTEyLDEyIEwxOCwyNCBMNiwyNCBaIi8+PC9nPgo8ZyBzdHlsZT0ic3Ryb2tlOmJsYWNrO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMjgxLDc5NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzApIj48cGF0aCBkPSJNMTIsMTIgTDE4LDI0IEw2LDI0IFoiLz48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iNjYiIHkyPSI1NCIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNDksNTgxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMSkiLz4KPGxpbmUgeDE9IjY2IiB5MT0iNTQiIHgyPSIxMjAiIHkyPSI5NiIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNDksNTgxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMSkiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIyNiIgeTI9IjE1IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNDksNTgxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMSkiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIxOSIgeTI9IjI1IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNDksNTgxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMSkiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTQ5LDU4MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzEpIj48cGF0aCBkPSJNMTMsMTMgTDI2LDE1IEwxOSwyNSBaIi8+PC9nPgo8ZyBzdHlsZT0ic3Ryb2tlOmJsYWNrO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTQ5LDU4MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzEpIj48cGF0aCBkPSJNMTMsMTMgTDI2LDE1IEwxOSwyNSBaIi8+PC9nPgo8bGluZSB4MT0iMjE2IiB5MT0iMTIiIHgyPSIxMTQiIHkyPSI5MCIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMDUsNTA5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMikiLz4KPGxpbmUgeDE9IjExNCIgeTE9IjkwIiB4Mj0iMTIiIHkyPSIxNjgiIHN0eWxlPSJzdHJva2U6YmxhY2s7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtZGFzaGFycmF5OjgsNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzA1LDUwOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzIpIi8+CjxsaW5lIHgxPSIyMTQiIHkxPSIxMyIgeDI9IjIwOCIgeTI9IjI1IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMDUsNTA5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMikiLz4KPGxpbmUgeDE9IjIxNCIgeTE9IjEzIiB4Mj0iMjAxIiB5Mj0iMTUiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDMwNSw1MDkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8yKSIvPgo8ZyBzdHlsZT0iZmlsbDp3aGl0ZTs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMDUsNTA5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMikiPjxwYXRoIGQ9Ik0yMTQsMTMgTDIwOCwyNSBMMjAxLDE1IFoiLz48L2c+CjxnIHN0eWxlPSJzdHJva2U6YmxhY2s7ZmlsbDpub25lOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMDUsNTA5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMikiPjxwYXRoIGQ9Ik0yMTQsMTMgTDIwOCwyNSBMMjAxLDE1IFoiLz48L2c+CjxsaW5lIHgxPSIxMiIgeTE9IjEyIiB4Mj0iMTAyIiB5Mj0iNzgiIHN0eWxlPSJzdHJva2U6YmxhY2s7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtZGFzaGFycmF5OjgsNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDE5NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzMpIi8+CjxsaW5lIHgxPSIxMDIiIHkxPSI3OCIgeDI9IjE5MiIgeTI9IjE0NCIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksMTk3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMykiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIyNiIgeTI9IjE1IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksMTk3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMykiLz4KPGxpbmUgeDE9IjEzIiB5MT0iMTMiIHgyPSIxOSIgeTI9IjI1IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwzMjksMTk3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMykiLz4KPGcgc3R5bGU9ImZpbGw6d2hpdGU7OyBzdHJva2U6IG5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDE5NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzMpIj48cGF0aCBkPSJNMTMsMTMgTDI2LDE1IEwxOSwyNSBaIi8+PC9nPgo8ZyBzdHlsZT0ic3Ryb2tlOmJsYWNrO2ZpbGw6bm9uZTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMzI5LDE5NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzMpIj48cGF0aCBkPSJNMTMsMTMgTDI2LDE1IEwxOSwyNSBaIi8+PC9nPgo8bGluZSB4MT0iMTIiIHkxPSIxMiIgeDI9IjEyIiB5Mj0iNDIiIHN0eWxlPSJzdHJva2U6YmxhY2s7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtZGFzaGFycmF5OjgsNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNjY1LDI2OSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzQpIi8+CjxsaW5lIHgxPSIxMiIgeTE9IjQyIiB4Mj0iMTIiIHkyPSI3MiIgc3R5bGU9InN0cm9rZTpibGFjaztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1kYXNoYXJyYXk6OCw1OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NjUsMjY5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNCkiLz4KPGxpbmUgeDE9IjEyIiB5MT0iMTIiIHgyPSIxOCIgeTI9IjI0IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NjUsMjY5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNCkiLz4KPGxpbmUgeDE9IjEyIiB5MT0iMTIiIHgyPSI2IiB5Mj0iMjQiIHN0eWxlPSJzdHJva2U6YmxhY2s7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDY2NSwyNjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF80KSIvPgo8ZyBzdHlsZT0iZmlsbDp3aGl0ZTs7IHN0cm9rZTogbm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw2NjUsMjY5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNCkiPjxwYXRoIGQ9Ik0xMiwxMiBMMTgsMjQgTDYsMjQgWiIvPjwvZz4KPGcgc3R5bGU9InN0cm9rZTpibGFjaztmaWxsOm5vbmU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDY2NSwyNjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF80KSI+PHBhdGggZD0iTTEyLDEyIEwxOCwyNCBMNiwyNCBaIi8+PC9nPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iNDY3IiBoZWlnaHQ9IjEwMzEiIHN0eWxlPSJmaWxsOiM4MGZmODA7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSI0NjYiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiLz4KPGxpbmUgeDE9IjQ2NyIgeTE9IjAiIHgyPSI0NjciIHkyPSIxMDMwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiLz4KPGxpbmUgeDE9IjQ2NyIgeTE9IjEwMzEiIHgyPSIxIiB5Mj0iMTAzMSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMTAzMSIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjE4MCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+b3JnLmliYXRpcy5zcHJpbmc8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iMTU4IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj5TcWxNYXBDbGllbnRUZW1wbGF0ZTwvdGV4dD48L2c+CjxsaW5lIHgxPSIwIiB5MT0iMzciIHgyPSI0NjciIHkyPSIzNyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI1NCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4tc3FsTWFwQ2xpZW50OiBTcWxNYXBDbGllbnQ8L3RleHQ+PC9nPgo8bGluZSB4MT0iMCIgeTE9IjU3IiB4Mj0iNDY3IiB5Mj0iNTciIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iNzQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K1NxbE1hcENsaWVudFRlbXBsYXRlKCk8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iOTEiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K1NxbE1hcENsaWVudFRlbXBsYXRlKHNxbE1hcENsaWVudDogU3FsTWFwQ2xpZW50KTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSIxMDgiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K1NxbE1hcENsaWVudFRlbXBsYXRlKGRhdGFTb3VyY2U6IERhdGFTb3VyY2UsIHNxbE1hcENsaWVudDogU3FsTWFwQ2xpZW50KTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSIxMjUiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3NldFNxbE1hcENsaWVudChzcWxNYXBDbGllbnQ6IFNxbE1hcENsaWVudCk6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iMTQyIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitnZXRTcWxNYXBDbGllbnQoKTogU3FsTWFwQ2xpZW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjE1OSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rZ2V0RGF0YVNvdXJjZSgpOiBEYXRhU291cmNlPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjE3NiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rYWZ0ZXJQcm9wZXJ0aWVzU2V0KCk6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iMTkzIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitleGVjdXRlKGFjdGlvbjogU3FsTWFwQ2xpZW50Q2FsbGJhY2smbHQ7VCZndDspOiBUPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjIxMCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JPYmplY3QoaWQ6IFN0cmluZyk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iMjI3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitxdWVyeUZvck9iamVjdChpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iMjQ0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitxdWVyeUZvck9iamVjdChpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCwgcmVzdWx0T2JqZWN0OiBPYmplY3QpOiBUPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjI2MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JMaXN0KGlkOiBTdHJpbmcpOiBMaXN0Jmx0O1QmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjI3OCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JMaXN0KGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0KTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSIyOTUiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3F1ZXJ5Rm9yTGlzdChpZDogU3RyaW5nLCBza2lwUmVzdWx0czogaW50LCBtYXhSZXN1bHRzOiBpbnQpOiBMaXN0Jmx0O1QmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjMxMiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JMaXN0KGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0LCBza2lwUmVzdWx0czogaW50LCBtYXhSZXN1bHRzOiBpbnQpOiBMaXN0Jmx0O1QmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjMyOSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlXaXRoUm93SGFuZGxlcihpZDogU3RyaW5nLCByb3dIYW5kbGVyOiBSb3dIYW5kbGVyKTogdm9pZDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSIzNDYiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3F1ZXJ5V2l0aFJvd0hhbmRsZXIoaWQ6IFN0cmluZywgcGFyYW1ldGVyT2JqZWN0OiBPYmplY3QsIHJvd0hhbmRsZXI6IFJvd0hhbmRsZXIpOiB2b2lkPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjM2MyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlXaXRoUm93SGFuZGxlcihpZDogU3RyaW5nLCByb3dIYW5kbGVyOiBSb3dIYW5kbGVyLCBhcmdzOiBPYmplY3RbXSk6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iMzgwIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitxdWVyeUZvck1hcChpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCwga2V5UHJvcGVydHk6IFN0cmluZyk6IE1hcCZsdDtLLFYmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjM5NyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JNYXAoaWQ6IFN0cmluZywgcGFyYW1ldGVyT2JqZWN0OiBPYmplY3QsIGtleVByb3BlcnR5OiBTdHJpbmcsIHZhbHVlUHJvcGVydHk6IFN0cmluZyk6IE1hcCZsdDtLLFYmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjQxNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JNYXAoaWQ6IFN0cmluZywgcGFyYW1ldGVyT2JqZWN0OiBPYmplY3QsIGtleVByb3BlcnR5OiBTdHJpbmcsIGtleVR5cGU6IENsYXNzJmx0O0smZ3Q7LCB2YWx1ZVByb3BlcnR5OiBTdHJpbmcsIHZhbHVlVHlwZTogQ2xhc3MmbHQ7ViZndDspOiBNYXAmbHQ7SyxWJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI0MzEiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2luc2VydChpZDogU3RyaW5nKTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI0NDgiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2luc2VydChpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iNDY1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPit1cGRhdGUoaWQ6IFN0cmluZyk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI0ODIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3VwZGF0ZShpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI0OTkiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3VwZGF0ZShpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCwgcmVxdWlyZWRSb3dzQWZmZWN0ZWQ6IGludCk6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iNTE2IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitkZWxldGUoaWQ6IFN0cmluZyk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI1MzMiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2RlbGV0ZShpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI1NTAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2RlbGV0ZShpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCwgcmVxdWlyZWRSb3dzQWZmZWN0ZWQ6IGludCk6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iNTY3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitpbnNlcnRBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI1ODQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3VwZGF0ZUFyZ3MoaWQ6IFN0cmluZywgYXJnczogT2JqZWN0W10pOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iNjAxIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitkZWxldGVBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjYxOCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JMaXN0QXJncyhpZDogU3RyaW5nLCBhcmdzOiBPYmplY3RbXSk6IExpc3QmbHQ7VCZndDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iNjM1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitxdWVyeUZvckxpc3RBcmdzKHNraXA6IGludCwgbWF4OiBpbnQsIGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI2NTIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3F1ZXJ5Rm9yUGFnZShwYWdlOiBMaXN0Jmx0O1QmZ3Q7LCBpZDogU3RyaW5nLCBza2lwOiBpbnQsIG1heDogaW50KTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjY2OSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JQYWdlKHBhZ2U6IExpc3QmbHQ7VCZndDssIGlkOiBTdHJpbmcsIHBhcmFtT2JqZWN0OiBPYmplY3QsIHNraXA6IGludCwgbWF4OiBpbnQpOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iNjg2IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitxdWVyeUZvclBhZ2VBcmdzKHBhZ2U6IExpc3QmbHQ7VCZndDssIGlkOiBTdHJpbmcsIHNraXA6IGludCwgbWF4OiBpbnQsIGFyZ3M6IE9iamVjdFtdKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjcwMyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JNYXBBcmdzKGlkOiBTdHJpbmcsIGtleVByb3A6IFN0cmluZywgYXJnczogT2JqZWN0W10pOiBNYXAmbHQ7SyxWJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI3MjAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3F1ZXJ5Rm9yTWFwQXJncyhpZDogU3RyaW5nLCBrZXlQcm9wOiBTdHJpbmcsIHZhbHVlUHJvcDogU3RyaW5nLCBhcmdzOiBPYmplY3RbXSk6IE1hcCZsdDtLLFYmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjczNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JNYXBBcmdzKGlkOiBTdHJpbmcsIGtleVByb3A6IFN0cmluZywga2V5VHlwZTogQ2xhc3MmbHQ7SyZndDssIHZhbHVlUHJvcDogU3RyaW5nLCB2YWx1ZVR5cGU6IENsYXNzJmx0O1YmZ3Q7LCBhcmdzOiBPYmplY3RbXSk6IE1hcCZsdDtLLFYmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9Ijc1NCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JPYmplY3RBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI3NzEiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3F1ZXJ5Rm9yRmlyc3RBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI3ODgiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3F1ZXJ5Rm9yRmlyc3QoaWQ6IFN0cmluZyk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iODA1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPitxdWVyeUZvckZpcnN0KGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0KTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI4MjIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2dldERpYWxlY3QoKTogRGlhbGVjdDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI4MzkiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+fnRvUGFyYW1ldGVyKGFyZ3M6IE9iamVjdFtdKTogTWFwJmx0O1N0cmluZyxPYmplY3QmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9Ijg1NiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4raW5zZXJ0RW50aXR5KGNsczogQ2xhc3MmbHQ7RSZndDssIGVudGl0eTogRSk6IEU8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iODczIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNSkiPit1cGRhdGVFbnRpdHkoY2xzOiBDbGFzcyZsdDtFJmd0OywgZW50aXR5OiBFKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9Ijg5MCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rZGVsZXRlRW50aXR5KGNsczogQ2xhc3MmbHQ7RSZndDssIGtleTogSyk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI5MDciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2ZpbmRFbnRpdHkoY2xzOiBDbGFzcyZsdDtFJmd0Oywga2V5OiBLKTogRTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI5MjQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2V4ZWN1dGVRdWVyeU9iamVjdChjcml0ZXJpYVF1ZXJ5OiBDcml0ZXJpYVF1ZXJ5Jmx0O1QmZ3Q7KTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI5NDEiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2V4ZWN1dGVRdWVyeShjcml0ZXJpYVF1ZXJ5OiBDcml0ZXJpYVF1ZXJ5Jmx0O1QmZ3Q7KTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI5NTgiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2V4ZWN1dGVRdWVyeShjcml0ZXJpYVF1ZXJ5OiBDcml0ZXJpYVF1ZXJ5Jmx0O1QmZ3Q7LCBzdGFydFBvc2l0aW9uOiBpbnQsIG1heFJlc3VsdDogaW50KTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI5NzUiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2V4ZWN1dGVRdWVyeVBhZ2UoY3JpdGVyaWFRdWVyeTogQ3JpdGVyaWFRdWVyeSZsdDtUJmd0OywgcGFnZTogTGlzdCZsdDtUJmd0Oywgc3RhcnRQb3NpdGlvbjogaW50LCBtYXhSZXN1bHQ6IGludCk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsOTc3LDUpIj48dGV4dCB4PSI3IiB5PSI5OTIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2V4ZWN1dGVVcGRhdGUodXBkYXRlUXVlcnk6IENyaXRlcmlhVXBkYXRlJmx0O1QmZ3Q7KTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjEwMDkiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2V4ZWN1dGVEZWxldGUoZGVsZXRlUXVlcnk6IENyaXRlcmlhRGVsZXRlJmx0O1QmZ3Q7KTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjEwMjYiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K2dldENyaXRlcmlhQnVpbGRlcigpOiBDcml0ZXJpYUJ1aWxkZXI8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iMTA0MyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JSZXN1bHRTZXRBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogUmVzdWx0U2V0PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw5NzcsNSkiPjx0ZXh0IHg9IjciIHk9IjEwNjAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF81KSI+K3F1ZXJ5Rm9yUmVzdWx0U2V0KGlkOiBTdHJpbmcpOiBSZXN1bHRTZXQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDk3Nyw1KSI+PHRleHQgeD0iNyIgeT0iMTA3NyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzUpIj4rcXVlcnlGb3JSZXN1bHRTZXQoaWQ6IFN0cmluZywgcGFyYW1ldGVyT2JqZWN0OiBPYmplY3QpOiBSZXN1bHRTZXQ8L3RleHQ+PC9nPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMzM1IiBoZWlnaHQ9IjQ3OSIgc3R5bGU9ImZpbGw6IzgwYzBmZjtmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMzM0IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiLz4KPGxpbmUgeDE9IjMzNSIgeTE9IjAiIHgyPSIzMzUiIHkyPSI0NzgiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIi8+CjxsaW5lIHgxPSIzMzUiIHkxPSI0NzkiIHgyPSIxIiB5Mj0iNDc5IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSIvPgo8bGluZSB4MT0iMCIgeTE9IjQ3OSIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI4OCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+Y29tLmliYXRpcy5zcWxtYXAuY2xpZW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iMTE0IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LXN0eWxlOml0YWxpYzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj5TcWxNYXBFeGVjdXRvcjwvdGV4dD48L2c+CjxsaW5lIHgxPSIwIiB5MT0iMzciIHgyPSIzMzUiIHkyPSIzNyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iNTQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K2luc2VydChpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSI3MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4raW5zZXJ0KGlkOiBTdHJpbmcpOiBUPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iODgiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3VwZGF0ZShpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiPjx0ZXh0IHg9IjciIHk9IjEwNSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4rdXBkYXRlKGlkOiBTdHJpbmcpOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIxMjIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K2RlbGV0ZShpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiPjx0ZXh0IHg9IjciIHk9IjEzOSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4rZGVsZXRlKGlkOiBTdHJpbmcpOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIxNTYiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3F1ZXJ5Rm9yT2JqZWN0KGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0KTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiPjx0ZXh0IHg9IjciIHk9IjE3MyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4rcXVlcnlGb3JPYmplY3QoaWQ6IFN0cmluZyk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIxOTAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3F1ZXJ5Rm9yT2JqZWN0KGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0LCByZXN1bHRPYmplY3Q6IE9iamVjdCk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIyMDciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3F1ZXJ5Rm9yTGlzdChpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCk6IExpc3QmbHQ7VCZndDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIyMjQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3F1ZXJ5Rm9yTGlzdChpZDogU3RyaW5nKTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiPjx0ZXh0IHg9IjciIHk9IjI0MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4rcXVlcnlGb3JMaXN0KGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0LCBza2lwOiBpbnQsIG1heDogaW50KTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiPjx0ZXh0IHg9IjciIHk9IjI1OCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4rcXVlcnlGb3JMaXN0KGlkOiBTdHJpbmcsIHNraXA6IGludCwgbWF4OiBpbnQpOiBMaXN0Jmx0O1QmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iMjc1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiPitxdWVyeUZvclBhZ2UocGFnZTogTGlzdCZsdDtUJmd0OywgaWQ6IFN0cmluZywgcGFyYW1PYmplY3Q6IE9iamVjdCwgc2tpcDogaW50LCBtYXg6IGludCk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiPjx0ZXh0IHg9IjciIHk9IjI5MiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4rcXVlcnlGb3JQYWdlKHBhZ2U6IExpc3QmbHQ7VCZndDssIGlkOiBTdHJpbmcsIHNraXA6IGludCwgbWF4OiBpbnQpOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIzMDkiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3F1ZXJ5V2l0aFJvd0hhbmRsZXIoaWQ6IFN0cmluZywgcGFyYW1ldGVyT2JqZWN0OiBPYmplY3QsIHJvd0hhbmRsZXI6IFJvd0hhbmRsZXIpOiB2b2lkPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iMzI2IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiPitxdWVyeVdpdGhSb3dIYW5kbGVyKGlkOiBTdHJpbmcsIHJvd0hhbmRsZXI6IFJvd0hhbmRsZXIpOiB2b2lkPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iMzQzIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiPitxdWVyeUZvck1hcChpZDogU3RyaW5nLCBwYXJhbWV0ZXJPYmplY3Q6IE9iamVjdCwga2V5UHJvcDogU3RyaW5nKTogTWFwJmx0O0ssViZndDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIzNjAiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3F1ZXJ5Rm9yTWFwKGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0LCBrZXlQcm9wOiBTdHJpbmcsIHZhbHVlUHJvcDogU3RyaW5nKTogTWFwJmx0O0ssViZndDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSIzNzciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3F1ZXJ5Rm9yTWFwKGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0LCBrZXlQcm9wOiBTdHJpbmcsIGtleVR5cGU6IENsYXNzJmx0O0smZ3Q7LCB2YWx1ZVByb3A6IFN0cmluZywgdmFsdWVUeXBlOiBDbGFzcyZsdDtWJmd0Oyk6IE1hcCZsdDtLLFYmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iMzk0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiPitzdGFydEJhdGNoKCk6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwzNDEpIj48dGV4dCB4PSI3IiB5PSI0MTEiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF82KSI+K3N0YXJ0QmF0Y2goYmF0Y2hTaXplOiBpbnQpOiB2b2lkPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iNDI4IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiPitleGVjdXRlQmF0Y2goKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMzQxKSI+PHRleHQgeD0iNyIgeT0iNDQ1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNikiPitleGVjdXRlQmF0Y2hEZXRhaWxlZCgpOiBMaXN0Jmx0O0JhdGNoUmVzdWx0Jmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDM0MSkiPjx0ZXh0IHg9IjciIHk9IjQ2MiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzYpIj4rcXVlcnlGb3JSZXN1bHRTZXQoaWQ6IFN0cmluZywgcGFyYW1ldGVyT2JqZWN0OiBPYmplY3QpOiBSZXN1bHRTZXQ8L3RleHQ+PC9nPgo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMzM1IiBoZWlnaHQ9IjE2NyIgc3R5bGU9ImZpbGw6I2ZmYWZhZjtmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDQyNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzcpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjMzNCIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw0MjUpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF83KSIvPgo8bGluZSB4MT0iMzM1IiB5MT0iMCIgeDI9IjMzNSIgeTI9IjE2NiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDQyNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzcpIi8+CjxsaW5lIHgxPSIzMzUiIHkxPSIxNjciIHgyPSIxIiB5Mj0iMTY3IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDI1KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNykiLz4KPGxpbmUgeDE9IjAiIHkxPSIxNjciIHgyPSIwIiB5Mj0iMSIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDQyNSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzcpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw0MjUpIj48dGV4dCB4PSI4OCIgeT0iMTciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF83KSI+Y29tLmliYXRpcy5zcWxtYXAuY2xpZW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDQyNSkiPjx0ZXh0IHg9Ijc0IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LXN0eWxlOml0YWxpYzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzcpIj5TcWxNYXBUcmFuc2FjdGlvbk1hbmFnZXI8L3RleHQ+PC9nPgo8bGluZSB4MT0iMCIgeTE9IjM3IiB4Mj0iMzM1IiB5Mj0iMzciIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw0MjUpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF83KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDI1KSI+PHRleHQgeD0iNyIgeT0iNTQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF83KSI+K3N0YXJ0VHJhbnNhY3Rpb24oKTogdm9pZDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw0MjUpIj48dGV4dCB4PSI3IiB5PSI3MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzcpIj4rc3RhcnRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklzb2xhdGlvbjogaW50KTogdm9pZDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw0MjUpIj48dGV4dCB4PSI3IiB5PSI4OCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzcpIj4rY29tbWl0VHJhbnNhY3Rpb24oKTogdm9pZDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSw0MjUpIj48dGV4dCB4PSI3IiB5PSIxMDUiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF83KSI+K2VuZFRyYW5zYWN0aW9uKCk6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDI1KSI+PHRleHQgeD0iNyIgeT0iMTIyIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNykiPitzZXRVc2VyQ29ubmVjdGlvbihjb25ubmVjdGlvbjogQ29ubmVjdGlvbik6IHZvaWQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsNDI1KSI+PHRleHQgeD0iNyIgeT0iMTM5IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfNykiPitnZXRDdXJyZW50Q29ubmVjdGlvbigpOiBDb25uZWN0aW9uPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDQyNSkiPjx0ZXh0IHg9IjciIHk9IjE1NiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzcpIj4rZ2V0RGF0YVNvdXJjZSgpOiBEYXRhU291cmNlPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjMzNSIgaGVpZ2h0PSIyNjMiIHN0eWxlPSJmaWxsOiNmZmQ3MDA7ZmlsbC1vcGFjaXR5OjAuNTsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDE3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOCkiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMzM0IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSIvPgo8bGluZSB4MT0iMzM1IiB5MT0iMCIgeDI9IjMzNSIgeTI9IjI2MiIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSIvPgo8bGluZSB4MT0iMzM1IiB5MT0iMjYzIiB4Mj0iMSIgeTI9IjI2MyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSIvPgo8bGluZSB4MT0iMCIgeTE9IjI2MyIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwxNykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzgpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDE3KSI+PHRleHQgeD0iMTEzIiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzgpIj5vcmcuaWJhdGlzLnBlcnNpc3Q8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwxNykiPjx0ZXh0IHg9IjExOSIgeT0iMzQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7Zm9udC1zdHlsZTppdGFsaWM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSI+RW50aXR5TWFuYWdlcjwvdGV4dD48L2c+CjxsaW5lIHgxPSIwIiB5MT0iMzciIHgyPSIzMzUiIHkyPSIzNyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwxNykiPjx0ZXh0IHg9IjciIHk9IjU0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOCkiPitpbml0RW50aXR5Q2xhc3MoZW50aXR5Q2xhc3M6IENsYXNzJmx0O0UmZ3Q7KTogRW50aXR5VHlwZSZsdDtFJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDE3KSI+PHRleHQgeD0iNyIgeT0iNzEiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSI+K2luc2VydEVudGl0eShjbHM6IENsYXNzJmx0O0UmZ3Q7LCBlbnRpdHk6IEUpOiBFPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMTcpIj48dGV4dCB4PSI3IiB5PSI4OCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzgpIj4rdXBkYXRlRW50aXR5KGNsczogQ2xhc3MmbHQ7RSZndDssIGVudGl0eTogRSk6IGludDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDE3KSI+PHRleHQgeD0iNyIgeT0iMTA1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOCkiPitkZWxldGVFbnRpdHkoY2xzOiBDbGFzcyZsdDtFJmd0Oywga2V5OiBLKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMTcpIj48dGV4dCB4PSI3IiB5PSIxMjIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSI+K2ZpbmRFbnRpdHkoY2xzOiBDbGFzcyZsdDtFJmd0Oywga2V5OiBLKTogRTwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDE3KSI+PHRleHQgeD0iNyIgeT0iMTM5IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOCkiPitleGVjdXRlUXVlcnlPYmplY3QoY3JpdGVyaWFRdWVyeTogQ3JpdGVyaWFRdWVyeSZsdDtUJmd0Oyk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwxNykiPjx0ZXh0IHg9IjciIHk9IjE1NiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzgpIj4rZXhlY3V0ZVF1ZXJ5KGNyaXRlcmlhUXVlcnk6IENyaXRlcmlhUXVlcnkmbHQ7VCZndDspOiBMaXN0Jmx0O1QmZ3Q7PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MjEsMTcpIj48dGV4dCB4PSI3IiB5PSIxNzMiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF84KSI+K2V4ZWN1dGVRdWVyeShjcml0ZXJpYVF1ZXJ5OiBDcml0ZXJpYVF1ZXJ5Jmx0O1QmZ3Q7LCBzdGFydFBvc2l0aW9uOiBpbnQsIG1heFJlc3VsdDogaW50KTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNTIxLDE3KSI+PHRleHQgeD0iNyIgeT0iMTkwIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOCkiPitleGVjdXRlUXVlcnlQYWdlKGNyaXRlcmlhUXVlcnk6IENyaXRlcmlhUXVlcnkmbHQ7VCZndDssIHBhZ2U6IExpc3QmbHQ7VCZndDssIHN0YXJ0UG9zaXRpb246IGludCwgbWF4UmVzdWx0OiBpbnQpOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwxNykiPjx0ZXh0IHg9IjciIHk9IjIwNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzgpIj4rZXhlY3V0ZVVwZGF0ZSh1cGRhdGVRdWVyeTogQ3JpdGVyaWFVcGRhdGUmbHQ7VCZndDspOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwxNykiPjx0ZXh0IHg9IjciIHk9IjIyNCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzgpIj4rZXhlY3V0ZURlbGV0ZShkZWxldGVRdWVyeTogQ3JpdGVyaWFEZWxldGUmbHQ7VCZndDspOiBpbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUyMSwxNykiPjx0ZXh0IHg9IjciIHk9IjI0MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzgpIj4rZ2V0Q3JpdGVyaWFCdWlsZGVyKCk6IENyaXRlcmlhQnVpbGRlcjwvdGV4dD48L2c+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIzMzUiIGhlaWdodD0iMTMxIiBzdHlsZT0iZmlsbDojZmZmZjAwO2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNyw2NzcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF85KSIvPgo8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSIzMzQiIHkyPSIwIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNyw2NzcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF85KSIvPgo8bGluZSB4MT0iMzM1IiB5MT0iMCIgeDI9IjMzNSIgeTI9IjEzMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMzcsNjc3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOSkiLz4KPGxpbmUgeDE9IjMzNSIgeTE9IjEzMSIgeDI9IjEiIHkyPSIxMzEiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDY3NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzkpIi8+CjxsaW5lIHgxPSIwIiB5MT0iMTMxIiB4Mj0iMCIgeTI9IjEiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDY3NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzkpIi8+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDY3NykiPjx0ZXh0IHg9Ijg4IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzkpIj5jb20uaWJhdGlzLnNxbG1hcC5jbGllbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNyw2NzcpIj48dGV4dCB4PSIxMjMiIHk9IjM0IiBzdHlsZT0iZmlsbDojOTkwMDMzO2ZvbnQtc3R5bGU6aXRhbGljOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOSkiPlNxbE1hcENsaWVudDwvdGV4dD48L2c+CjxsaW5lIHgxPSIwIiB5MT0iMzciIHgyPSIzMzUiIHkyPSIzNyIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMzcsNjc3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfOSkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMzcsNjc3KSI+PHRleHQgeD0iNyIgeT0iNTQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF85KSI+K29wZW5TZXNzaW9uKCk6IFNxbE1hcFNlc3Npb248L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNyw2NzcpIj48dGV4dCB4PSI3IiB5PSI3MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzkpIj4rb3BlblNlc3Npb24oY29ubjogQ29ubmVjdGlvbik6IFNxbE1hcFNlc3Npb248L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEzNyw2NzcpIj48dGV4dCB4PSI3IiB5PSI4OCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzkpIj4rZmx1c2hEYXRhQ2FjaGUoKTogdm9pZDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDY3NykiPjx0ZXh0IHg9IjciIHk9IjEwNSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzkpIj4rZmx1c2hEYXRhQ2FjaGUoY2FjaGVJZDogU3RyaW5nKTogdm9pZDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTM3LDY3NykiPjx0ZXh0IHg9IjciIHk9IjEyMiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzkpIj4rZmx1c2hFbnRpdHlDYWNoZShlbnRpdHlDbGFzczogQ2xhc3MmbHQ7PyZndDspOiB2b2lkPC90ZXh0PjwvZz4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjI2MyIgaGVpZ2h0PSI5NSIgc3R5bGU9ImZpbGw6I2YwZTY4YztmaWxsLW9wYWNpdHk6MC41OyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNjEsODU3KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTApIi8+CjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjI2MiIgeTI9IjAiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTYxLDg1NykiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzEwKSIvPgo8bGluZSB4MT0iMjYzIiB5MT0iMCIgeDI9IjI2MyIgeTI9Ijk0IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSw4NTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMCkiLz4KPGxpbmUgeDE9IjI2MyIgeTE9Ijk1IiB4Mj0iMSIgeTI9Ijk1IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSw4NTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMCkiLz4KPGxpbmUgeDE9IjAiIHkxPSI5NSIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSw4NTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMCkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNjEsODU3KSI+PHRleHQgeD0iODEiIHk9IjE3IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTApIj5vcmcuaWJhdGlzLmNsaWVudDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTYxLDg1NykiPjx0ZXh0IHg9Ijg3IiB5PSIzNCIgc3R5bGU9ImZpbGw6Izk5MDAzMztmb250LXN0eWxlOml0YWxpYzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzEwKSI+U3FsTWFwQ2xpZW50PC90ZXh0PjwvZz4KPGxpbmUgeDE9IjAiIHkxPSIzNyIgeDI9IjI2MyIgeTI9IjM3IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSw4NTcpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMCkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxNjEsODU3KSI+PHRleHQgeD0iNyIgeT0iNTQiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMCkiPitnZXREaWFsZWN0KCk6IERpYWxlY3Q8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSw4NTcpIj48dGV4dCB4PSI3IiB5PSI3MSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzEwKSI+K2dldFJlYWxEYXRhU291cmNlKCk6IERhdGFTb3VyY2U8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDE2MSw4NTcpIj48dGV4dCB4PSI3IiB5PSI4OCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzEwKSI+K2dldENhY2hlKGlkOiBTdHJpbmcpOiBDYWNoZTwvdGV4dD48L2c+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIzMzUiIGhlaWdodD0iMzM1IiBzdHlsZT0iZmlsbDojZmZlNGM0O2ZpbGwtb3BhY2l0eTowLjU7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiLz4KPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMzM0IiB5Mj0iMCIgc3R5bGU9InN0cm9rZTojOTkwMDMzOyIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIi8+CjxsaW5lIHgxPSIzMzUiIHkxPSIwIiB4Mj0iMzM1IiB5Mj0iMzM0IiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiLz4KPGxpbmUgeDE9IjMzNSIgeTE9IjMzNSIgeDI9IjEiIHkyPSIzMzUiIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSIvPgo8bGluZSB4MT0iMCIgeTE9IjMzNSIgeDI9IjAiIHkyPSIxIiBzdHlsZT0ic3Ryb2tlOiM5OTAwMzM7IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiLz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iMTE3IiB5PSIxNyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSI+b3JnLmliYXRpcy5jbGllbnQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIj48dGV4dCB4PSIxMDkiIHk9IjM0IiBzdHlsZT0iZmlsbDojOTkwMDMzO2ZvbnQtc3R5bGU6aXRhbGljOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIj5TcWxNYXBFeGVjdXRvcjI8L3RleHQ+PC9nPgo8bGluZSB4MT0iMCIgeTE9IjM3IiB4Mj0iMzM1IiB5Mj0iMzciIHN0eWxlPSJzdHJva2U6Izk5MDAzMzsiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwyOSkiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSIvPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIj48dGV4dCB4PSI3IiB5PSI1NCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSI+K2luc2VydEFyZ3MoaWQ6IFN0cmluZywgYXJnczogT2JqZWN0W10pOiBUPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iNzEiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiPit1cGRhdGVBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iODgiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiPitkZWxldGVBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iMTA1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIj4rcXVlcnlGb3JMaXN0QXJncyhpZDogU3RyaW5nLCBhcmdzOiBPYmplY3RbXSk6IExpc3QmbHQ7VCZndDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIj48dGV4dCB4PSI3IiB5PSIxMjIiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiPitxdWVyeUZvckxpc3RBcmdzKHNraXA6IGludCwgbWF4OiBpbnQsIGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogTGlzdCZsdDtUJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwyOSkiPjx0ZXh0IHg9IjciIHk9IjEzOSIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSI+K3F1ZXJ5Rm9yTWFwQXJncyhpZDogU3RyaW5nLCBrZXlQcm9wOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogTWFwJmx0O0ssViZndDs8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIj48dGV4dCB4PSI3IiB5PSIxNTYiIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiPitxdWVyeUZvck1hcEFyZ3MoaWQ6IFN0cmluZywga2V5UHJvcDogU3RyaW5nLCB2YWx1ZVByb3A6IFN0cmluZywgYXJnczogT2JqZWN0W10pOiBNYXAmbHQ7SyxWJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwyOSkiPjx0ZXh0IHg9IjciIHk9IjE3MyIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSI+K3F1ZXJ5Rm9yTWFwQXJncyhpZDogU3RyaW5nLCBrZXlQcm9wOiBTdHJpbmcsIGtleVR5cGU6IENsYXNzJmx0O0smZ3Q7LCB2YWx1ZVByb3A6IFN0cmluZywgdmFsdWVUeXBlOiBDbGFzcyZsdDtWJmd0OywgYXJnczogT2JqZWN0W10pOiBNYXAmbHQ7SyxWJmd0OzwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwyOSkiPjx0ZXh0IHg9IjciIHk9IjE5MCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSI+K3F1ZXJ5Rm9yT2JqZWN0QXJncyhpZDogU3RyaW5nLCBhcmdzOiBPYmplY3RbXSk6IFQ8L3RleHQ+PC9nPgo8ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDUsMjkpIj48dGV4dCB4PSI3IiB5PSIyMDciIHN0eWxlPSJmaWxsOiM5OTAwMzM7IiBjbGlwLXBhdGg9InVybCgjXzltM2kyMF8xMSkiPitxdWVyeUZvclBhZ2VBcmdzKHBhZ2U6IExpc3QmbHQ7VCZndDssIGlkOiBTdHJpbmcsIHNraXA6IGludCwgbWF4OiBpbnQsIGFyZ3M6IE9iamVjdFtdKTogaW50PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iMjI0IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIj4rcXVlcnlGb3JGaXJzdEFyZ3MoaWQ6IFN0cmluZywgYXJnczogT2JqZWN0W10pOiBUPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iMjQxIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIj4rcXVlcnlGb3JGaXJzdChpZDogU3RyaW5nKTogVDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwyOSkiPjx0ZXh0IHg9IjciIHk9IjI1OCIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSI+K3F1ZXJ5Rm9yRmlyc3QoaWQ6IFN0cmluZywgcGFyYW1ldGVyT2JqZWN0OiBPYmplY3QpOiBUPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iMjc1IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIj4rcXVlcnlXaXRoUm93SGFuZGxlckFyZ3MoaWQ6IFN0cmluZywgcm93SGFuZGxlcjogUm93SGFuZGxlciwgYXJnczogT2JqZWN0W10pOiB2b2lkPC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iMjkyIiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIj4rcXVlcnlGb3JSZXN1bHRTZXRBcmdzKGlkOiBTdHJpbmcsIGFyZ3M6IE9iamVjdFtdKTogUmVzdWx0U2V0PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1LDI5KSI+PHRleHQgeD0iNyIgeT0iMzA5IiBzdHlsZT0iZmlsbDojOTkwMDMzOyIgY2xpcC1wYXRoPSJ1cmwoI185bTNpMjBfMTEpIj4rcXVlcnlGb3JSZXN1bHRTZXQoaWQ6IFN0cmluZyk6IFJlc3VsdFNldDwvdGV4dD48L2c+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsNSwyOSkiPjx0ZXh0IHg9IjciIHk9IjMyNiIgc3R5bGU9ImZpbGw6Izk5MDAzMzsiIGNsaXAtcGF0aD0idXJsKCNfOW0zaTIwXzExKSI+K3F1ZXJ5Rm9yUmVzdWx0U2V0KGlkOiBTdHJpbmcsIHBhcmFtZXRlck9iamVjdDogT2JqZWN0KTogUmVzdWx0U2V0PC90ZXh0PjwvZz4KPGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwwLDApIj48dGV4dCB4PSIyIiB5PSIxMDQwIiBzdHlsZT0iZmlsbDojYzBjMGMwO2ZvbnQtZmFtaWx5OkltcGFjdDtmb250LXNpemU6MTFweDsiID4oYylqYmF0aXMub3JnPC90ZXh0PjwvZz48L2c+PC9zdmc+Cg=="></p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>In jBATIS, the <code>executeInsert</code> and <code>insert</code> APIs will return the generated key if the statement has <code>&lt;selectKey&gt;</code> or the number of records changed.</li>
    <li>When in no-auto batch mode, the <code>executeInsert</code>, <code>insert</code>, <code>executeUpdate</code>, <code>update</code>, <code>delete</code> APIs will return 0.</li>
    <li>When in auto batch mode, the <code>executeInsert</code>, <code>insert</code>, <code>executeUpdate</code>, <code>update</code>, <code>delete</code> APIs will return 0 or the number of records changed by the batch if the batch size reached.</li>
  </ul>
</blockquote>
<h3 id="transactions">Transactions<a class="headerlink" href="#_toc_transactions">←</a></h3>
<p>By default, calling any execute method on SqlMapClient instance (e.g. queryForObject() or insert()) will auto-commit or auto-rollback.
This means that each call to any execution method will be a single unit of work.
This is simple indeed, but not ideal if you have a number of statements that must execute as a single unit of work
(i.e. either succeed or fail as a group). This is where transactions come into play.</p>
<p>If you're using Global Transactions (configured by the SQL Map configuration file),
you can use autocommit and still achieve unit-of-work behavior.
However, it still might be ideal for performance reasons to demarcate transaction boundaries,
as it reduces the traffic on the connection pool and database connection initializations.</p>
<p>The SqlMapClient interface has methods that allow you to demarcate transactional boundaries.
A transaction can be started, committed or rolled back using the following methods on the <code>SqlMapClient</code> interface:</p>
<pre><code class="language-java hljs">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException
</span></code></pre>
<p>By starting a transaction you are retrieving a connection from the connection pool, and opening it to receive SQL queries and updates.
An example of using transactions is as follows:</p>
<pre><code class="language-java hljs">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateItemDescription</span><span class="hljs-params">(String itemId, String newDescription)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
        <span class="hljs-keyword">try</span> {
            sqlMap.startTransaction();
            Item item = sqlMap.queryForObject(<span class="hljs-string">"getItem"</span>, itemId);
            item.setDescription(newDescription);
            sqlMap.update(<span class="hljs-string">"updateItem"</span>, item);
            sqlMap.commitTransaction();
        } <span class="hljs-keyword">finally</span> {
            sqlMap.endTransaction();
        }
    }
</code></pre>
<p>Notice how endTransaction() is called regardless of an error. This is an important step to ensure cleanup.
The rule is: if you call <code>startTransaction()</code> be absolutely certain to call <code>endTransaction()</code> (whether you commit or not).</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Transactions cannot be nested. Calling startTransaction() from the same thread more than once, before calling commit() or rollback(), will cause an exception to be thrown.
  In other words, each thread can have <strong>at most</strong> one transaction open, per SqlMapClient instance.</p>
  <p>SqlMapClient transactions use Java's ThreadLocal store for storing transactional objects. This means that each thread that calls startTransaction() will get a unique Connection object for their transaction.
  The only way to return a connection to the DataSource (or close the connection) is to call commitTransaction() or endTransaction().
  Not doing so could cause your pool to run out of connections and lock up.</p>
  <p>Spring AOP can do auto transcation operation with jBATIS framework.</p>
</blockquote>
<h3 id="automatic-transactions">Automatic Transactions<a class="headerlink" href="#_toc_automatic-transactions">←</a></h3>
<p>Although using explicit transactions is recommended, there is a simplified semantic that can be used for simple requirements (generally read-only).
If you do not explicitly demarcate transactions using the startTransaction(), commitTransaction() and endTransaction() methods,
they will all be called automatically for you whenever you execute a statement outside of a transactional block as demonstrated in the above.
For example:</p>
<pre><code class="language-java hljs">    <span class="hljs-keyword">try</span> {
        Item item = sqlMap.queryForObject(<span class="hljs-string">"getItem"</span>, itemId);       
        item.setDescription(<span class="hljs-string">"TX1"</span>);

        <span class="hljs-comment">// No transaction demarcated, so transaction will be automatic (implied)       </span>
        sqlMap.update(<span class="hljs-string">"updateItem"</span>, item);       

        item.setDescription (newDescription);   
        item.setDescription (<span class="hljs-string">"TX2"</span>);

        <span class="hljs-comment">// No transaction demarcated, so transaction will be automatic (implied)      </span>
        sqlMap.update(<span class="hljs-string">"updateItem"</span>, item);  
    } <span class="hljs-keyword">catch</span> (SQLException e) {
        <span class="hljs-keyword">throw</span> (SQLException) e.fillInStackTrace();        
    }
</code></pre>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>Be very careful using automatic transactions, for although they can be attractive, you will run into trouble if your unit of work requires more than a single update to the database.
  In the above example, if the second call to "updateItem" fails, the item description will still be updated with the first new description of "TX1"  (i.e. this is not transactional behavior).</p>
</blockquote>
<h3 id="global-distributed-transactions">Global (DISTRIBUTED) Transactions<a class="headerlink" href="#_toc_global-distributed-transactions">←</a></h3>
<p>The Data Mapper framework supports global transactions as well. Global transactions, also known as distributed transactions,
will allow you to update multiple databases (or other JTA compliant resources) in the same unit of work (i.e. updates to multiple datasources can succeed or fail as a group).</p>
<h4 id="externalprogrammatic-global-transactions">External/Programmatic Global Transactions<a class="headerlink" href="#_toc_externalprogrammatic-global-transactions">←</a></h4>
<p>You can choose to manage global transactions externally, either programmatically (coded by hand), or by implementing another framework such as the very common EJB.
Using EJBs you can declaratively demarcate (set the boundaries of) a transaction in an EJB deployment descriptor.
Further discussion of how this is done is beyond the scope of this document. To enable support external or programmatic global transactions, you must set the <code>&lt;transactionManager&gt;</code> type attribute to <code>"EXTERNAL"</code>
in your SQL Map configuration file (see above).  When using externally controlled global transactions, the SQL Map transaction control methods are somewhat redundant,
because the begin, commit and rollback of transactions will be controlled by the external transaction manager.
However, there can be a performance benefit to still demarcating your transactions using the SqlMapClient methods startTransaction(), commitTransaction() and endTransaction()
(vs. allowing an automatic transaction to started and committed or rolled back).
By continuing to use these methods, you will maintain a consistent programming paradigm, as well as you will be able to reduce the number of requests for connections from the connection pool.
Further benefit is that in some cases you may need to change the order in which resources are closed (commitTransaction() or endTransaction()) versus when the global transaction is committed.
Different app servers and transaction managers have different rules (unfortunately).
Other than these simple considerations, there are really no changes required to your SQL Map code to make use of a global transaction.</p>
<h4 id="managed-global-transactions">Managed Global Transactions<a class="headerlink" href="#_toc_managed-global-transactions">←</a></h4>
<p>The SQL Map framework can also manage global transactions for you. To enable support for managed global transactions,
you must set the <code>&lt;transactionManager&gt;</code> type attribute to <code>"JTA"</code> in your SQL Map configuration file and set the <code>"UserTransaction"</code> property
to the full JNDI name of where the SqlMapClient instance will find the UserTransaction instance.
See the <code>&lt;transactionManager&gt;</code> discussion above for full configuration details.</p>
<p>Programming for global transactions is not much different, however there are some small considerations. Here is an example:</p>
<pre><code class="language-java hljs">    <span class="hljs-keyword">try</span> {
        orderSqlMap.startTransaction();
        storeSqlMap.startTransaction();

        orderSqlMap.insertOrder(...);
        orderSqlMap.updateQuantity(...);

        storeSqlMap.commitTransaction();
        orderSqlMap.commitTransaction();
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">try</span> {
            storeSqlMap.endTransaction();
        } <span class="hljs-keyword">finally</span> {
            orderSqlMap.endTransaction();
        }
    }
</code></pre>
<p>In this example, there are two SqlMapClient instances that we will assume are using two different databases.
The first SqlMapClient (orderSqlMap) that we use to start a transaction will also start the global transaction.
After that, all other activity is considered part of the global transaction until that same SqlMapClient (orderSqlMap) calls commitTransaction() and endTransaction(),
at which point the global transaction is committed and all other work is considered done.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong>
  Although this seems simple, it is very important that you don't overuse global (distributed) transactions.
  There are performance implications, as well as additional complex configuration requirements for your application server and database drivers.
  Although it looks easy, you might still experience some difficulties. Remember, EJBs have a lot more industry support and tools to help you along,
  and you still might be better off using Session EJBs for any work that requires distributed transactions.</p>
</blockquote>
<h3 id="multi-threaded-programming">Multi Threaded Programming<a class="headerlink" href="#_toc_multi-threaded-programming">←</a></h3>
<p>iBATIS supports multi threaded programming, but there are some considerations to be aware of.</p>
<p>The first, and foremost, consideration is that transactions must be entirely contained within a thread.
Stated another way, transactions cannot cross thread boundaries. For this reason, it is a good idea to think of starting threads to complete entire units of work.
It is generally not a good idea to have a pool of threads waiting to start and execute transactions - unless you can guarantee thread affinity for each unit of work.</p>
<p>Another consideration is that there can only be one active transaction at a time in each thread.
You can write code that executes more than one transaction in a thread, but the transactions must be in sequence, and not open at the same time.
This is an example of multiple serial transactions in a thread:</p>
<pre><code class="language-java hljs">    <span class="hljs-keyword">try</span> {
        orderSqlMap.startTransaction();
        storeSqlMap.startTransaction();
        orderSqlMap.insertOrder();
        orderSqlMap.updateQuantity();
        storeSqlMap.commitTransaction();
        orderSqlMap.commitTransaction();
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">try</span> {
            storeSqlMap.endTransaction();
        } <span class="hljs-keyword">finally</span> {
            orderSqlMap.endTransaction();
        }
    }
</code></pre>
<p>The important thing is that only one transaction is active at a time in the thread.
Of course, with automatic transactions each statement is a different transaction.</p>
<h3 id="batchs">Batchs<a class="headerlink" href="#_toc_batchs">←</a></h3>
<p>If you have a great number of non-query (insert/update/delete) statements to execute,
you might like to execute them as a batch to minimize network traffic and allow the JDBC driver to perform additional optimization (e.g. compression).
Using batches is simple with the SQL Map API, simple methods allow you to demarcate the boundaries of the batch:</p>
<pre><code class="language-java hljs">    <span class="hljs-keyword">try</span> {
        sqlMap.startTransaction();
        sqlMap.startBatch();
        <span class="hljs-comment">// ... execute statements in between</span>
        <span class="hljs-keyword">int</span> rowsUpdated = sqlMap.executeBatch(); <span class="hljs-comment">// optional</span>
        sqlMap.commitTransaction();
    } <span class="hljs-keyword">finally</span> {
        sqlMap.endTransaction();
    }
</code></pre>
<p>Upon calling executeBatch(), all batched statements will executed through the JDBC driver.
Calling executeBatch() is optional because the commit operation will execute the batch automatically if there is an open batch.
So you can call executeBatch() if you want to know the number of rows that were affected, or you can skip it and just call commitTransaction().</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <p>There must be ether <code>executeBatch()</code> or <code>commitTransaction()</code>, or both exists to end your batch.</p>
</blockquote>
<p>If you have a large number of operations to perform in a batch, you might want to issue periodic commits throughout the batch.
For example, if you're inserting 1000 more rows, you might want to commit every 200 rows to keep from creating huge transactions.
Here is an example:</p>
<pre><code class="language-java hljs">    <span class="hljs-keyword">try</span> {
        sqlMapClient.startBatch(<span class="hljs-number">200</span>); <span class="hljs-comment">// it's auto batch mode, so no need to re-start batch.</span>
        <span class="hljs-keyword">for</span> (Bean b : bs) {
            sqlMapClient.insert(<span class="hljs-string">"saveBean"</span>, b);
        }
        sqlMapClient.executeBatch(); <span class="hljs-comment">// it's needed, close the batch.</span>
    } <span class="hljs-keyword">catch</span> (Exception e) {
        logger.error(e.getMessage(), e);
    }
</code></pre>
<p>If you use manual batch mode to issue periodic commits,
it is important to know that you should call startBatch() after each periodic commit - because the commit will execute and end the batch.</p>
<pre><code class="language-java hljs">    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">int</span> totalRows = <span class="hljs-number">0</span>;
        sqlMap.startTransaction();
        sqlMap.startBatch(); <span class="hljs-comment">// it's manual batch mode</span>
        <span class="hljs-comment">// ... insert 100 rows</span>
        totalRows += sqlMap.executeBatch(); <span class="hljs-comment">// cause batch closed.</span>
        sqlMap.commitTransaction();

        sqlMap.startBatch(); <span class="hljs-comment">// so it's need to start a new batch</span>
        <span class="hljs-comment">// ... insert 100 rows</span>
        totalRows += sqlMap.executeBatch();
        sqlMap.commitTransaction();
        
        sqlMap.startBatch();
        <span class="hljs-comment">// ... insert 100 rows</span>
        totalRows += sqlMap.executeBatch();
        sqlMap.commitTransaction();

        <span class="hljs-comment">// etc.</span>
    } <span class="hljs-keyword">finally</span> {
        sqlMap.endTransaction();
    }
</code></pre>
<p>If you execute different mapped statements (i.e. inserts, then updates), iBATIS will break the batch into <code>sub batches</code> based on the generated SQL of the last statement executed.
For example, consider the following code:</p>
<pre><code class="language-java hljs">    sqlMap.startBatch();
    sqlMap.insert(<span class="hljs-string">"myInsert"</span>, parameterObject1);
    sqlMap.insert(<span class="hljs-string">"myInsert"</span>, parameterObject2);
    sqlMap.insert(<span class="hljs-string">"myInsert"</span>, parameterObject3);
    sqlMap.insert(<span class="hljs-string">"myInsert"</span>, parameterObject4);
    sqlMap.update(<span class="hljs-string">"myUpdate"</span>, parameterObject5);
    sqlMap.update(<span class="hljs-string">"myUpdate"</span>, parameterObject6);
    sqlMap.insert(<span class="hljs-string">"myInsert"</span>, parameterObject7);
    sqlMap.insert(<span class="hljs-string">"myInsert"</span>, parameterObject8);
    sqlMap.insert(<span class="hljs-string">"myInsert"</span>, parameterObject9);
    sqlMap.executeBatch();
</code></pre>
<p>jBATIS will execute this batch in two sub batches - one for the first four and the last three insert statements, another for the next two update statements.
(<strong>differ from iBATIS which split into three sub batches, even though the last three insert statements are the same as the first four,
iBATIS will still execute a different sub batch because the update statements were in between.</strong>)</p>
<p>Thus, iBATIS breaks your batch into <code>sub batches</code> based on the generated SQL of the last statement executed, and always create a new <code>sub batch</code>;
while jBATIS merge your batch into existing <code>sub batch</code> as much as possible, based on both the statement id and the generated SQL .</p>
<p>If a statements in your batch will flush some cache models, iBATIS <strong>improperly</strong> flush them at each time the statement added into the batch even <code>executeBatch()</code> is not called finally,
while jBATIS flush them only once after the batch execution - <code>executeBatch()</code> is called.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>A batch should be nested inside an explicit transaction. If you had never started a batch, then jBATIS will automatically start one(<strong>while iBATIS will execute each statement individually</strong>).</li>
    <li>The <strong>recommended practice</strong> is using <code>startBatch</code> and <code>executeBatch</code> always pairly, and optionally using <code>startTransaction</code>, <code>commitTransaction</code> and <code>endTransaction</code> together.</li>
    <li>You may execute any mapped statement within the batch demarcations, but you must ensure them successful without any execution order requirement.</li>
    <li>The executeBatch() method returns an <code>int</code> - the total number of records updated in the batch.
    If there are sub batches, iBATIS will add the number of rows updated in each sub batch to the total.
    Note that it is entirely legal for the JDBC driver to fail to return the number of records updated in a batch - in which case the executeBatch() method will return 0
    even though records have been updated.  The Oracle driver is a good example of a driver that behaves this way.</li>
    <li>You can use a different method to execute batches - <code>executeBatchDetailed</code>.
    This method functions the same as the regular executeBatch method, but it returns more detailed information about the row counts.</li>
  </ul>
</blockquote>
<h2 id="jbatis-persistence-api">jBATIS Persistence API<a class="headerlink" href="#_toc_jbatis-persistence-api">←</a></h2>
<p>jBATIS provides a lightweight JPA-like Persistence Framework for users. You can define you entity class like following code:</p>
<pre><code class="language-java hljs"><span class="hljs-keyword">import</span> org.ibatis.persist.Cacheable;
<span class="hljs-keyword">import</span> org.ibatis.persist.Column;
<span class="hljs-keyword">import</span> org.ibatis.persist.Entity;
<span class="hljs-keyword">import</span> org.ibatis.persist.Id;
<span class="hljs-keyword">import</span> org.ibatis.persist.Table;
<span class="hljs-keyword">import</span> org.ibatis.persist.Transient;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"my_table"</span>)
<span class="hljs-meta">@Cacheable</span>(type=<span class="hljs-string">"MEMORY"</span>, minutes=<span class="hljs-number">10</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>{
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"ID"</span>)
    <span class="hljs-keyword">int</span> id;
    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"NAME"</span>)
    String name;
    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"DATA"</span>)
    <span class="hljs-keyword">byte</span>[] data;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getData() {
        <span class="hljs-keyword">return</span> date;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReportData</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data)</span> </span>{
        <span class="hljs-keyword">this</span>.data = data;
    }
}
</code></pre>
<p>Then you can use your DAO to do something like JPA:</p>
<pre><code class="language-java hljs"><span class="hljs-keyword">import</span> org.ibatis.persist.criteria.CriteriaBuilder;
<span class="hljs-keyword">import</span> org.ibatis.persist.criteria.CriteriaQuery;
<span class="hljs-keyword">import</span> org.ibatis.persist.criteria.Root;
<span class="hljs-keyword">import</span> org.ibatis.spring.support.AbstractDaoSupport;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDaoSupport</span>&lt;<span class="hljs-title">MyBean</span>&gt; </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> MyBean <span class="hljs-title">findMyBean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>{
        CriteriaBuilder cb = getCriteriaBuilder();
        CriteriaQuery&lt;MyBean&gt; cq = cb.createQuery(MyBean.class);
        Root&lt;MyBean&gt; r = cq.from(MyBean.class);
        cq.where(cb.and(cb.gt(r.get(r.$().getId()), id), cb.like(r.get(r.$().getName()), name + <span class="hljs-string">"%"</span>)));
        <span class="hljs-comment">// select * from my_table where id &gt; :id and name like :name</span>
        <span class="hljs-keyword">return</span> getSqlMapClientTemplate().executeQueryObject(cq);
    }
}
</code></pre>
<h3 id="jbatis-persistence-entitymanager">jBATIS Persistence EntityManager<a class="headerlink" href="#_toc_jbatis-persistence-entitymanager">←</a></h3>
<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EntityManager</span> </span>{

    <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">EntityType&lt;E&gt; <span class="hljs-title">initEntityClass</span><span class="hljs-params">(Class&lt;E&gt; entityClass)</span></span>;
    &lt;E&gt; <span class="hljs-function">E <span class="hljs-title">insertEntity</span><span class="hljs-params">(Class&lt;E&gt; cls, E entity)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    &lt;E, K&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateEntity</span><span class="hljs-params">(Class&lt;E&gt; cls, E entity)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    &lt;E, K&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteEntity</span><span class="hljs-params">(Class&lt;E&gt; cls, K key)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    &lt;E, K&gt; <span class="hljs-function">E <span class="hljs-title">findEntity</span><span class="hljs-params">(Class&lt;E&gt; cls, K key)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">executeQueryObject</span><span class="hljs-params">(CriteriaQuery&lt;T&gt; criteriaQuery)</span></span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">executeQuery</span><span class="hljs-params">(CriteriaQuery&lt;T&gt; criteriaQuery)</span></span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">executeQuery</span><span class="hljs-params">(CriteriaQuery&lt;T&gt; criteriaQuery, <span class="hljs-keyword">int</span> startPosition, <span class="hljs-keyword">int</span> maxResult)</span></span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">executeQueryPage</span><span class="hljs-params">(CriteriaQuery&lt;T&gt; criteriaQuery, List&lt;T&gt; page, <span class="hljs-keyword">int</span> startPosition, <span class="hljs-keyword">int</span> maxResult)</span></span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">executeUpdate</span><span class="hljs-params">(CriteriaUpdate&lt;T&gt; updateQuery)</span></span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">executeDelete</span><span class="hljs-params">(CriteriaDelete&lt;T&gt; deleteQuery)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> CriteriaBuilder <span class="hljs-title">getCriteriaBuilder</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<h2 id="simpledatasource">SimpleDataSource<a class="headerlink" href="#_toc_simpledatasource">←</a></h2>
<p>The SimpleDataSource class is a simple implementation of a JDBC 2.0 compliant DataSource.
It supports a convenient set of connection pooling features and is completely synchronous which makes it a very lightweight and portable connection pooling solution.
SimpleDataSource is used exactly like any other JDBC DataSource implementation.</p>
<p>The constructor of SimpleDataSource requires a <code>Map&lt;Object,Object&gt;</code> parameter that takes a number of configuration properties.
The following table names and describes the properties.</p>
<table border="1">
  <thead>
    <tr><th>Property Name</th><th>Required</th><th>Default</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td>JDBC.Driver</td><td>Yes</td><td>n/a</td><td>The usual JDBC driver class name.</td></tr>
    <tr><td>JDBC.ConnectionURL</td><td>Yes</td><td>n/a</td><td>The usual JDBC connection URL.</td></tr>
    <tr><td>JDBC.Username</td><td>Yes</td><td>n/a</td><td>The username to log into the database.</td></tr>
    <tr><td>JDBC.Password</td><td>Yes</td><td>n/a</td><td>The password to log into the database.</td></tr>
    <tr><td>JDBC.DefaultAutoCommit</td><td>No</td><td>driver dependent</td><td>The default autocommit setting for all connections created by the pool.</td></tr>
    <tr><td>JDBC.DefaultTransactionIsolation</td><td>No</td><td>driver dependent</td><td>The default transaction isolation setting for all connections created by the pool.</td></tr>
    <tr><td>Pool.MaximumActiveConnections</td><td>No</td><td>10</td><td>Maximum number of connections that can be open at any given time.</td></tr>
    <tr><td>Pool.MaximumIdleConnections</td><td>No</td><td>5</td><td>The number of idle connections that will be stored in the pool.</td></tr>
    <tr><td>Pool.MaximumCheckoutTime</td><td>No</td><td>20000</td><td>The maximum length of time (milliseconds) that a connection can be "checked out" before it becomes a candidate for forced collection when <code>Pool.MaximumActiveConnections</code> is reached. <strong>-1 means no limit.</strong></td></tr>
    <tr><td>Pool.TimeToWait</td><td>No</td><td>20000</td><td>If a client is forced to wait for a connection (because they are all in use), this is the maximum length of time in (milliseconds) that the thread will wait before making a repeat attempt to acquire a connection.</td></tr>
    <tr><td>Pool.PingQuery</td><td>No</td><td>driver dependent</td><td>The ping query will be run against the database to test the connection.  In an environment where connections are not reliable, it is useful to use a ping query to guarantee that the pool will always return a good connection.</td></tr>
    <tr><td>Pool.PingEnabled</td><td>No</td><td>false</td><td>Enable or disable ping query. For most applications a ping query will not be necessary.</td></tr>
    <tr><td>Pool.PingConnectionsOlderThan</td><td>No</td><td>0</td><td>Connections that are older than the value (milliseconds) of this property will be tested using the ping query. This is useful if your database environment commonly drops connections after a period of time (e.g. 12 hours).</td></tr>
    <tr><td>Pool.PingConnectionsNotUsedFor</td><td>No</td><td>0</td><td>Connections that have been inactive for longer than the value (milliseconds) of this property will be tested using the ping query. This is useful if your database environment commonly drops connections after they have been inactive for a period of time (e.g. after 12 hours of inactivity).</td></tr>
    <tr><td>Pool.PingIdleConnectionsAfter</td><td>No</td><td>0</td><td>Idle connections that are older than the value (milliseconds) of this property will be tested using the ping query.</td></tr>
    <tr><td>Pool.EraseIdleConnectionsAfter</td><td>No</td><td>0</td><td>Idle connections will be erased if older than the value (milliseconds) of this property.</td></tr>
    <tr><td>Pool.ShutdownDelay</td><td>No</td><td>10000</td><td>When shutdown, The pool will be closed after delay the value (milliseconds) of this property.</td></tr>
    <tr><td>Pool.CommitOnReturn</td><td>No</td><td>false</td><td>If <code>true</code> and <code>autoCommit</code>=<code>false</code> then the pool can complete the transaction by calling <code>commit</code> on the connection as it is returned to the pool, otherwize, <code>rollback</code> is called.</td></tr>
    <tr><td>Pool.LogSqlOverdueThan</td><td>No</td><td>0</td><td>If sql execution time is longer than the value (milliseconds) of this property, The pool log some warn/info for user optimization.</td></tr>
    <tr><td>Driver.*</td><td>No</td><td>n/a</td><td>Many JDBC drivers support additional features configured by sending extra properties. To send such properties to your JDBC driver, you can specify them by prefixing them with "Driver." and then the name of the property.</td></tr>
  </tbody>
</table>
<p>Note these properties also work within the <code>ibatis.ini</code> and sqlMap-config.xml files.</p>
<h2 id="dignostic-jbatis-framework">Dignostic jBATIS Framework<a class="headerlink" href="#_toc_dignostic-jbatis-framework">←</a></h2>
<h3 id="setup-runtime-stats">Setup runtime stats<a class="headerlink" href="#_toc_setup-runtime-stats">←</a></h3>
<p>To dignostic jBATIS Framework, you should write you <code>ibatis.ini</code> in classpath as following:</p>
<pre><code class="language-prop hljs properties">...
cglib_cache_size=<span class="hljs-string">2048
</span>sql_executor_class=<span class="hljs-string">org.ibatis.client.SqlExecutor
</span>...
sql_executor_stats_sql=<span class="hljs-string">true
</span>run_stats_file=<span class="hljs-string">/path/file
</span></code></pre>
<h3 id="get-runtime-stats">Get runtime stats<a class="headerlink" href="#_toc_get-runtime-stats">←</a></h3>
<p>Then the runtime stats is turn on, with insignificant performance loss.
When you app is running, even in production enviroment, you can simply <code>touch /path/file</code> to make jBATIS log statistics info into <code>stderr</code> and its log.</p>
<blockquote>
  <p><strong><em>Important Notes:</em></strong></p>
  <ul>
    <li>If the last modified time or executable flag of the <code>run_stats_file</code> is changed, jBATIS soon log statistics info and also</li>
    <li>Setup cache model flush monitos by <code>Properties</code> loaded from <code>run_stats_file</code>. See <a href="#monitor_cache_flush_link">Monitor Cache Flush</a></li>
  </ul>
</blockquote>
<p>It include SIMPLE data source pool params and status, also include mapped statements stats and cache usage, looks like:</p>
<pre><code class="language-log">iBATIS run stats from ... to ...
PoolStatus ... :
iBATIS -  ---------------------------------------------------------------------------------
iBATIS -  jdbcDriver         com.mysql.jdbc.Driver
iBATIS -  jdbcUrl            jdbc:mysql://...
iBATIS -  jdbcUsername       ...              jdbcPassword             ******
iBATIS -  requestCount       344906           defaultAutoCommit        false
iBATIS -   idleConnections        2           transactionIsolation     Default
iBATIS -   activeConnections      2           driverProperties         {}
iBATIS -   reuseCount        344641           poolMaxActiveConnections 10
iBATIS -   closeCount             8           poolMaxIdleConnections   5
iBATIS -   eraseCount           253           poolMaxCheckoutTime      -1
iBATIS -   claimedOverdue         0           poolTimeToWait           20000
iBATIS -   badCount               0           poolPingIdleConnsAfter   100000
iBATIS -  avgRequestTime     0                poolEraseIdleConnsAfter  900000
iBATIS -  avgCheckoutTime    1                poolPingConnsOlderThan   0
iBATIS -  avgOverdueUseTime  0                poolPingConnsNotUsedFor  0
iBATIS -  waitCount          0                poolPingEnabled          false
iBATIS -  avgWaitTime        0                poolPingQuery            SELECT 1
iBATIS -  maxIdleCount       5                poolShutdownDelay        10000
iBATIS -  maxActiveCount     7                poolCommitOnReturn       false
iBATIS -  sql_exec_threshold 2000             poolLogSqlOverdueThan    0
iBATIS -  ---------------------------------------------------------------------------------
SqlExecutor ... :
iBATIS -  -----------------------    sql stats:  ...  -------------------------------------
iBATIS -      count  avg.time  id/sql
iBATIS -         23         0  findAll...
iBATIS -         12        11  ~update...
iBATIS -          1        30  findFree...
...
iBATIS -  -----------------------  cache stats:  ...  -------------------------------------
iBATIS -   requests      hits    flushs       age   age.max  id
iBATIS -        117       109         1      1373     28800  monitor.get...
iBATIS -          0         0         1      1373      3000  org.apache...
...
iBATIS -  -----------------------  roots stats:  ...  -------------------------------------
iBATIS -     flushs       age  id
iBATIS -         43      1347  host...
iBATIS -          1      1170  ~alert...
...
iBATIS -  ---------------------------------------------------------------------------------
</code></pre>
<p>In above,</p>
<ul>
  <li><code>requestCount - reuseCount - claimedOverdue</code> ≈ <code>activeConnections + idleConnections + closeCount + eraseCount + badCount</code>, Just only concurrency count cause almost-equal-to.</li>
  <li>the <code>age</code> of caches and cache roots both means the period in seconds between its last flush time and now.</li>
  <li>the <code>age.max</code> of caches means the flush interval in seconds, <code>-1</code> means never expired and <code>0</code> means it's not <code>CacheModel</code> instance.</li>
  <li><code>~</code> prefixed sql id means it is executed in a batch, and the <code>count</code> is the times that the batch committed.</li>
  <li><code>~</code> prefixed cache root id means it is fake, because no cache has tagged by it.</li>
</ul>
<p>So, you can easily optimize your application according to these stats information,
such as ajust you connection pool size, setup some cache model for use, optimize some slow sql, or add some index in database...</p>
</body></html>